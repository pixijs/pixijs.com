"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["2167"],{76978:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>d,metadata:()=>s,assets:()=>l,toc:()=>p,contentTitle:()=>c});var s=JSON.parse('{"id":"examples/mesh-and-shaders/shader-toy-mesh","title":"Shader Toy Mesh","description":"","source":"@site/versioned_docs/version-7.x/examples/mesh-and-shaders/shader-toy-mesh.mdx","sourceDirName":"examples/mesh-and-shaders","slug":"/examples/mesh-and-shaders/shader-toy-mesh","permalink":"/7.x/examples/mesh-and-shaders/shader-toy-mesh","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"7.x","sidebarPosition":9,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":9,"custom_edit_url":null,"title":"Shader Toy Mesh"},"sidebar":"examplesSidebar","previous":{"title":"Interleaving Geometry","permalink":"/7.x/examples/mesh-and-shaders/interleaving-geometry"},"next":{"title":"Multi Pass Shader Generated Mesh","permalink":"/7.x/examples/mesh-and-shaders/multi-pass-shader-generated-mesh"}}'),i=t("85893"),a=t("50065"),r=t("67963"),o=t("99883");let d={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:9,custom_edit_url:null,title:"Shader Toy Mesh"},c=void 0,l={},p=[];function m(e){return(0,i.jsx)(r.N,{files:{"index.js":"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Build geometry.\nconst geometry = new PIXI.Geometry()\n    .addAttribute(\n        'aVertexPosition', // the attribute name\n        [\n            -100,\n            -100, // x, y\n            100,\n            -100, // x, y\n            100,\n            100,\n            -100,\n            100,\n        ], // x, y\n        2,\n    ) // the size of the attribute\n    .addAttribute(\n        'aUvs', // the attribute name\n        [\n            0,\n            0, // u, v\n            1,\n            0, // u, v\n            1,\n            1,\n            0,\n            1,\n        ], // u, v\n        2,\n    ) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\nconst fragmentSrc = `\n//Based on this: https://www.shadertoy.com/view/wtlSWX\nprecision mediump float;\n\nvarying vec2 vUvs;\n\nuniform sampler2D noise;\nuniform float time;\n\n// Distance function. Just calculates the height (z) from x,y plane with really simple length check.\n// Its not exact as there could be shorter distances.\nvec2 dist(vec3 p)\n{\n    float id = floor(p.x)+floor(p.y);\n    id = mod(id, 2.);\n    float h = texture2D(noise, vec2(p.x, p.y)*0.04).r*5.1;\n    return vec2(h-p.z,id);\n}\n\n//Light calculation.\nvec3 calclight(vec3 p, vec3 rd)\n{\n    vec2 eps = vec2( 0., 0.001);\n    vec3 n = normalize( vec3(\n    dist(p+eps.yxx).x - dist(p-eps.yxx).x,\n    dist(p+eps.xyx).x - dist(p-eps.xyx).x,\n    dist(p+eps.xxy).x - dist(p-eps.xxy).x\n    ));\n\n    vec3 d = vec3( max( 0., dot( -rd ,n)));\n\n    return d;\n}\n\nvoid main()\n{\n    vec2 uv = vec2(vUvs.x,1.-vUvs.y);\n    uv *=2.;\n    uv-=1.;\n\n    vec3 cam = vec3(0.,time -2., -3.);\n    vec3 target = vec3(sin(time)*0.1, time+cos(time)+2., 0. );\n    float fov = 2.2;\n    vec3 forward = normalize( target - cam);\n    vec3 up = normalize(cross( forward, vec3(0., 1.,0.)));\n    vec3 right = normalize( cross( up, forward));\n    vec3 raydir = normalize(vec3( uv.x *up + uv.y * right + fov*forward));\n\n    //Do the raymarch\n    vec3 col = vec3(0.);\n    float t = 0.;\n    for( int i = 0; i < 100; i++)\n    {\n    vec3 p = t * raydir + cam;\n    vec2 d = dist(p);\n    t+=d.x*0.5;//Jump only half of the distance as height function used is not really the best for heightmaps.\n    if(d.x < 0.001)\n    {\n        vec3 bc = d.y < 0.5 ? vec3(1.0, .8, 0.) :\n                vec3(0.8,0.0, 1.0);\n        col = vec3( 1.) * calclight(p, raydir) * (1. - t/150.) *bc;\n        break;\n    }\n    if(t > 1000.)\n    {\n        break;\n    }\n    }\n    gl_FragColor = vec4(col, 1.);\n}`;\n\nconst uniforms = {\n    noise: PIXI.Texture.from('https://pixijs.com/assets/perlin.jpg'),\n    time: 0,\n};\n// Make sure repeat wrap is used and no mipmapping.\n\nuniforms.noise.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;\nuniforms.noise.baseTexture.mipmap = false;\n\n// Build the shader and the quad.\nconst shader = PIXI.Shader.from(vertexSrc, fragmentSrc, uniforms);\nconst quad = new PIXI.Mesh(geometry, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\n// start the animation..\nlet time = 0;\n\napp.ticker.add((delta) =>\n{\n    time += 1 / 60;\n    quad.shader.uniforms.time = time;\n    quad.scale.set(Number(Math.cos(time)) + 2, Number(Math.sin(time * 0.7)) + 2);\n});\n"},dependencies:{"pixi.js":o.npm}})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},99883:function(e){e.exports=JSON.parse('{"versionLabel":"v7.x","version":"7.4.2","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.4.2","build":"https://pixijs.download/v7.4.2/pixi.min.js","docs":"https://pixijs.download/v7.4.2/docs/index.html","npm":"7.4.2","prerelease":false,"latest":false}')}}]);