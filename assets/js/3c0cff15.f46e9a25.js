"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["3136"],{85586:function(e,n,t){t.r(n),t.d(n,{default:()=>p,frontMatter:()=>i,metadata:()=>o,assets:()=>u,toc:()=>d,contentTitle:()=>c});var o=JSON.parse('{"id":"examples/advanced/collision-detection","title":"Collision Detection","description":"","source":"@site/docs/examples/advanced/collision-detection.mdx","sourceDirName":"examples/advanced","slug":"/examples/advanced/collision-detection","permalink":"/8.x/examples/advanced/collision-detection","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":5,"custom_edit_url":null,"title":"Collision Detection"},"sidebar":"examplesSidebar","previous":{"title":"Screen Shot","permalink":"/8.x/examples/advanced/screen-shot"},"next":{"title":"Spinners","permalink":"/8.x/examples/advanced/spinners"}}'),a=t("85893"),r=t("50065"),s=t("67963");let i={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:5,custom_edit_url:null,title:"Collision Detection"},c=void 0,u={},d=[];function l(e){return(0,a.jsx)(s.N,{files:{"index.js":"import { Application, Assets, Point, Sprite, Texture } from 'pixi.js';\n\n// Based somewhat on this article by Spicy Yoghurt\n// URL for further reading: https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics\n(async () =>\n{\n    // Create a new application\n    const app = new Application();\n\n    // Initialize the application\n    await app.init({ background: '#111', resizeTo: window });\n\n    // Append the application canvas to the document body\n    document.body.appendChild(app.canvas);\n\n    // Options for how objects interact\n    // How fast the red square moves\n    const movementSpeed = 0.05;\n\n    // Strength of the impulse push between two objects\n    const impulsePower = 5;\n\n    // Test For Hit\n    // A basic AABB check between two different squares\n    function testForAABB(object1, object2)\n    {\n        const bounds1 = object1.getBounds();\n        const bounds2 = object2.getBounds();\n\n        return (\n            bounds1.x < bounds2.x + bounds2.width\n            && bounds1.x + bounds1.width > bounds2.x\n            && bounds1.y < bounds2.y + bounds2.height\n            && bounds1.y + bounds1.height > bounds2.y\n        );\n    }\n\n    // Calculates the results of a collision, allowing us to give an impulse that\n    // shoves objects apart\n    function collisionResponse(object1, object2)\n    {\n        if (!object1 || !object2)\n        {\n            return new Point(0);\n        }\n\n        const vCollision = new Point(object2.x - object1.x, object2.y - object1.y);\n\n        const distance = Math.sqrt(\n            (object2.x - object1.x) * (object2.x - object1.x) + (object2.y - object1.y) * (object2.y - object1.y),\n        );\n\n        const vCollisionNorm = new Point(vCollision.x / distance, vCollision.y / distance);\n\n        const vRelativeVelocity = new Point(\n            object1.acceleration.x - object2.acceleration.x,\n            object1.acceleration.y - object2.acceleration.y,\n        );\n\n        const speed = vRelativeVelocity.x * vCollisionNorm.x + vRelativeVelocity.y * vCollisionNorm.y;\n\n        const impulse = (impulsePower * speed) / (object1.mass + object2.mass);\n\n        return new Point(impulse * vCollisionNorm.x, impulse * vCollisionNorm.y);\n    }\n\n    // Calculate the distance between two given points\n    function distanceBetweenTwoPoints(p1, p2)\n    {\n        const a = p1.x - p2.x;\n        const b = p1.y - p2.y;\n\n        return Math.hypot(a, b);\n    }\n\n    // The green square we will knock about\n    const greenSquare = new Sprite(Texture.WHITE);\n\n    greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\n    greenSquare.width = 100;\n    greenSquare.height = 100;\n    greenSquare.tint = 0x00ff00;\n    greenSquare.acceleration = new Point(0);\n    greenSquare.mass = 3;\n\n    // The square you move around\n    const redSquare = new Sprite(Texture.WHITE);\n\n    redSquare.position.set(0, 0);\n    redSquare.width = 100;\n    redSquare.height = 100;\n    redSquare.tint = 0xff0000;\n    redSquare.acceleration = new Point(0);\n    redSquare.mass = 1;\n\n    const mouseCoords = { x: 0, y: 0 };\n\n    app.stage.eventMode = 'static';\n    app.stage.hitArea = app.screen;\n    app.stage.on('mousemove', (event) =>\n    {\n        mouseCoords.x = event.global.x;\n        mouseCoords.y = event.global.y;\n    });\n\n    // Listen for animate update\n    app.ticker.add((time) =>\n    {\n        const delta = time.deltaTime;\n\n        // Applied deacceleration for both squares, done by reducing the\n        // acceleration by 0.01% of the acceleration every loop\n        redSquare.acceleration.set(redSquare.acceleration.x * 0.99, redSquare.acceleration.y * 0.99);\n        greenSquare.acceleration.set(greenSquare.acceleration.x * 0.99, greenSquare.acceleration.y * 0.99);\n\n        // Check whether the green square ever moves off the screen\n        // If so, reverse acceleration in that direction\n        if (greenSquare.x < 0 || greenSquare.x > app.screen.width - 100)\n        {\n            greenSquare.acceleration.x = -greenSquare.acceleration.x;\n        }\n\n        if (greenSquare.y < 0 || greenSquare.y > app.screen.height - 100)\n        {\n            greenSquare.acceleration.y = -greenSquare.acceleration.y;\n        }\n\n        // If the green square pops out of the cordon, it pops back into the\n        // middle\n        if (\n            greenSquare.x < -30\n            || greenSquare.x > app.screen.width + 30\n            || greenSquare.y < -30\n            || greenSquare.y > app.screen.height + 30\n        )\n        {\n            greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\n        }\n\n        // If the mouse is off screen, then don't update any further\n        if (\n            app.screen.width > mouseCoords.x\n            || mouseCoords.x > 0\n            || app.screen.height > mouseCoords.y\n            || mouseCoords.y > 0\n        )\n        {\n            // Get the red square's center point\n            const redSquareCenterPosition = new Point(\n                redSquare.x + redSquare.width * 0.5,\n                redSquare.y + redSquare.height * 0.5,\n            );\n\n            // Calculate the direction vector between the mouse pointer and\n            // the red square\n            const toMouseDirection = new Point(\n                mouseCoords.x - redSquareCenterPosition.x,\n                mouseCoords.y - redSquareCenterPosition.y,\n            );\n\n            // Use the above to figure out the angle that direction has\n            const angleToMouse = Math.atan2(toMouseDirection.y, toMouseDirection.x);\n\n            // Figure out the speed the square should be travelling by, as a\n            // function of how far away from the mouse pointer the red square is\n            const distMouseRedSquare = distanceBetweenTwoPoints(mouseCoords, redSquareCenterPosition);\n            const redSpeed = distMouseRedSquare * movementSpeed;\n\n            // Calculate the acceleration of the red square\n            redSquare.acceleration.set(Math.cos(angleToMouse) * redSpeed, Math.sin(angleToMouse) * redSpeed);\n        }\n\n        // If the two squares are colliding\n        if (testForAABB(greenSquare, redSquare))\n        {\n            // Calculate the changes in acceleration that should be made between\n            // each square as a result of the collision\n            const collisionPush = collisionResponse(greenSquare, redSquare);\n            // Set the changes in acceleration for both squares\n\n            redSquare.acceleration.set(collisionPush.x * greenSquare.mass, collisionPush.y * greenSquare.mass);\n            greenSquare.acceleration.set(-(collisionPush.x * redSquare.mass), -(collisionPush.y * redSquare.mass));\n        }\n\n        greenSquare.x += greenSquare.acceleration.x * delta;\n        greenSquare.y += greenSquare.acceleration.y * delta;\n\n        redSquare.x += redSquare.acceleration.x * delta;\n        redSquare.y += redSquare.acceleration.y * delta;\n    });\n\n    // Add to stage\n    app.stage.addChild(redSquare, greenSquare);\n})();\n"}})}function p(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);