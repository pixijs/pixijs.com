"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["5396"],{42196:function(e,n,s){s.r(n),s.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>t,assets:()=>l,toc:()=>d,contentTitle:()=>r});var t=JSON.parse('{"id":"guides/components/assets","title":"Assets","description":"The Assets package","source":"@site/docs/guides/components/assets.md","sourceDirName":"guides/components","slug":"/guides/components/assets","permalink":"/8.x/guides/components/assets","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/pixijs.com/tree/main/docs/guides/components/assets.md","tags":[],"version":"current","frontMatter":{},"sidebar":"guidesSidebar","previous":{"title":"Render Layers","permalink":"/8.x/guides/advanced/render-layers"},"next":{"title":"Containers","permalink":"/8.x/guides/components/containers"}}'),a=s("85893"),i=s("50065");let o={},r="Assets",l={},d=[{value:"The Assets package",id:"the-assets-package",level:2},{value:"Getting started",id:"getting-started",level:2},{value:"Making our first Assets Promise",id:"making-our-first-assets-promise",level:2},{value:"Working with unrecognizable URLs",id:"working-with-unrecognizable-urls",level:2},{value:"Warning about solved promises",id:"warning-about-solved-promises",level:2},{value:"Using Async/Await",id:"using-asyncawait",level:2},{value:"Loading multiple assets",id:"loading-multiple-assets",level:2},{value:"Background loading",id:"background-loading",level:2}];function c(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"assets",children:"Assets"})}),"\n",(0,a.jsx)(n.h2,{id:"the-assets-package",children:"The Assets package"}),"\n",(0,a.jsxs)(n.p,{children:["The Assets package is a modern replacement for the old ",(0,a.jsx)(n.code,{children:"Loader"})," class. It is a promise-based resource management solution that will download, cache and parse your assets into something you can use. The downloads can be simultaneous and in the background, meaning faster startup times for your app, the cache ensures that you never download the same asset twice and the extensible parser system allows you to easily extend and customize the process to your needs."]}),"\n",(0,a.jsx)(n.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Assets"})," relies heavily on JavaScript Promises that all modern browsers support, however, if your target browser ",(0,a.jsx)(n.a,{href:"https://caniuse.com/promises",children:"doesn't support promises"})," you should look into ",(0,a.jsx)(n.a,{href:"https://github.com/zloirock/core-js#ecmascript-promise",children:"polyfilling them"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"making-our-first-assets-promise",children:"Making our first Assets Promise"}),"\n",(0,a.jsxs)(n.p,{children:["To quickly use the ",(0,a.jsx)(n.code,{children:"Assets"})," instance, you just need to call ",(0,a.jsx)(n.code,{children:"Assets.load"})," and pass in an asset. This will return a promise that when resolved will yield the value you seek.\nIn this example, we will load a texture and then turn it into a sprite."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { Application, Assets, Sprite } from 'pixi.js';\n\n// Create a new application\nconst app = new Application();\n\n// Initialize the application\nawait app.init({ background: '#1099bb', resizeTo: window });\n\n// Append the application canvas to the document body\ndocument.body.appendChild(app.canvas);\n\n// Start loading right away and create a promise\nconst texturePromise = Assets.load('https://pixijs.com/assets/bunny.png');\n\n// When the promise resolves, we have the texture!\ntexturePromise.then((resolvedTexture) =>\n{\n    // create a new Sprite from the resolved loaded Texture\n    const bunny = Sprite.from(resolvedTexture);\n\n    // center the sprite's anchor point\n    bunny.anchor.set(0.5);\n\n    // move the sprite to the center of the screen\n    bunny.x = app.screen.width / 2;\n    bunny.y = app.screen.height / 2;\n\n    app.stage.addChild(bunny);\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["One very important thing to keep in mind while using ",(0,a.jsx)(n.code,{children:"Assets"})," is that all requests are cached and if the URL is the same, the promise returned will also be the same.\nTo show it in code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"promise1 = Assets.load('bunny.png')\npromise2 = Assets.load('bunny.png')\n// promise1 === promise2\n"})}),"\n",(0,a.jsx)(n.p,{children:"Out of the box, the following assets types can be loaded without the need for external plugins:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Textures (",(0,a.jsx)(n.code,{children:"avif"}),", ",(0,a.jsx)(n.code,{children:"webp"}),", ",(0,a.jsx)(n.code,{children:"png"}),", ",(0,a.jsx)(n.code,{children:"jpg"}),", ",(0,a.jsx)(n.code,{children:"gif"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["Sprite sheets (",(0,a.jsx)(n.code,{children:"json"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["Bitmap fonts (",(0,a.jsx)(n.code,{children:"xml"}),", ",(0,a.jsx)(n.code,{children:"fnt"}),", ",(0,a.jsx)(n.code,{children:"txt"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["Web fonts (",(0,a.jsx)(n.code,{children:"ttf"}),", ",(0,a.jsx)(n.code,{children:"woff"}),", ",(0,a.jsx)(n.code,{children:"woff2"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["Json files (",(0,a.jsx)(n.code,{children:"json"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["Text files (",(0,a.jsx)(n.code,{children:"txt"}),")"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"More types can be added fairly easily by creating additional loader parsers."}),"\n",(0,a.jsx)(n.h2,{id:"working-with-unrecognizable-urls",children:"Working with unrecognizable URLs"}),"\n",(0,a.jsxs)(n.p,{children:["With the basic syntax, asset types are recognized by their file extension - for instance ",(0,a.jsx)(n.code,{children:"https://pixijs.com/assets/bunny.png"})," ends with ",(0,a.jsx)(n.code,{children:".png"})," so ",(0,a.jsx)(n.code,{children:"Assets.load"})," can figure it should use the texture loader."]}),"\n",(0,a.jsx)(n.p,{children:"In some cases you may not have control over the URLs and you have to work with ambiguous URLs without recognizable extensions. In this situation, you can specify an explicit loader:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"promise = Assets.load({\n  src: 'https://example.com/ambiguous-file-name',\n  loadParser: 'loadTextures'\n})\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here are some of the ",(0,a.jsx)(n.code,{children:"loader"})," values you can use:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Textures: ",(0,a.jsx)(n.code,{children:"loadTextures"})]}),"\n",(0,a.jsxs)(n.li,{children:["Web fonts: ",(0,a.jsx)(n.code,{children:"loadWebFont"})]}),"\n",(0,a.jsxs)(n.li,{children:["Json files: ",(0,a.jsx)(n.code,{children:"loadJson"})]}),"\n",(0,a.jsxs)(n.li,{children:["Text files: ",(0,a.jsx)(n.code,{children:"loadTxt"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"warning-about-solved-promises",children:"Warning about solved promises"}),"\n",(0,a.jsxs)(n.p,{children:["When an asset is downloaded, it is cached as a promise inside the ",(0,a.jsx)(n.code,{children:"Assets"})," instance and if you try to download it again you will get a reference to the already resolved promise.\nHowever promise handlers ",(0,a.jsx)(n.code,{children:".then(...)"}),"/",(0,a.jsx)(n.code,{children:".catch(...)"}),"/",(0,a.jsx)(n.code,{children:".finally(...)"})," are always asynchronous, this means that even if a promise was already resolved the code below the ",(0,a.jsx)(n.code,{children:".then(...)"}),"/",(0,a.jsx)(n.code,{children:".catch(...)"}),"/",(0,a.jsx)(n.code,{children:".finally(...)"})," will execute before the code inside them.\nSee this example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"console.log(1);\nalreadyResolvedPromise.then(() => console.log(2));\nconsole.log(3);\n\n// Console output:\n// 1\n// 3\n// 2\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To learn more about why this happens you will need to learn about ",(0,a.jsx)(n.a,{href:"https://javascript.info/microtask-queue",children:"Microtasks"}),", however, using async functions should mitigate this problem."]}),"\n",(0,a.jsx)(n.h2,{id:"using-asyncawait",children:"Using Async/Await"}),"\n",(0,a.jsxs)(n.p,{children:["There is a way to work with promises that is more intuitive and easier to read: ",(0,a.jsx)(n.code,{children:"async"}),"/",(0,a.jsx)(n.code,{children:"await"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["To use it we first need to create a function/method and mark it as ",(0,a.jsx)(n.code,{children:"async"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"async function test() {\n    // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This function now wraps the return value in a promise and allows us to use the ",(0,a.jsx)(n.code,{children:"await"})," keyword before a promise to halt the execution of the code until it is resolved and gives us the value."]}),"\n",(0,a.jsx)(n.p,{children:"See this example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// Create a new application\nconst app = new Application();\n// Initialize the application\nawait app.init({ background: '#1099bb', resizeTo: window });\n// Append the application canvas to the document body\ndocument.body.appendChild(app.canvas);\nconst texture = await Assets.load('https://pixijs.com/assets/bunny.png');\n// Create a new Sprite from the awaited loaded Texture\nconst bunny = Sprite.from(texture);\n// Center the sprite's anchor point\nbunny.anchor.set(0.5);\n// Move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\napp.stage.addChild(bunny);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"texture"})," variable now is not a promise but the resolved texture that resulted after waiting for this promise to resolve."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const texture = await Assets.load('examples/assets/bunny.png');\n"})}),"\n",(0,a.jsx)(n.p,{children:"This allows us to write more readable code without falling into callback hell and to better think when our program halts and yields."}),"\n",(0,a.jsx)(n.h2,{id:"loading-multiple-assets",children:"Loading multiple assets"}),"\n",(0,a.jsxs)(n.p,{children:["We can add assets to the cache and then load them all simultaneously by using ",(0,a.jsx)(n.code,{children:"Assets.add(...)"})," and then calling ",(0,a.jsx)(n.code,{children:"Assets.load(...)"})," with all the keys you want to have loaded.\nSee the following example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// Append the application canvas to the document body\ndocument.body.appendChild(app.canvas);\n// Add the assets to load\nAssets.add({ alias: 'flowerTop', src: 'https://pixijs.com/assets/flowerTop.png' });\nAssets.add({ alias: 'eggHead', src: 'https://pixijs.com/assets/eggHead.png' });\n// Load the assets and get a resolved promise once both are loaded\nconst texturesPromise = Assets.load(['flowerTop', 'eggHead']); // => Promise<{flowerTop: Texture, eggHead: Texture}>\n// When the promise resolves, we have the texture!\ntexturesPromise.then((textures) =>\n{\n    // Create a new Sprite from the resolved loaded Textures\n    const flower = Sprite.from(textures.flowerTop);\n    flower.anchor.set(0.5);\n    flower.x = app.screen.width * 0.25;\n    flower.y = app.screen.height / 2;\n    app.stage.addChild(flower);\n    const egg = Sprite.from(textures.eggHead);\n    egg.anchor.set(0.5);\n    egg.x = app.screen.width * 0.75;\n    egg.y = app.screen.height / 2;\n    app.stage.addChild(egg);\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["However, if you want to take full advantage of ",(0,a.jsx)(n.code,{children:"@pixi/Assets"})," you should use bundles.\nBundles are just a way to group assets together and can be added manually by calling ",(0,a.jsx)(n.code,{children:"Assets.addBundle(...)"}),"/",(0,a.jsx)(n.code,{children:"Assets.loadBundle(...)"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"  Assets.addBundle('animals', {\n    bunny: 'bunny.png',\n    chicken: 'chicken.png',\n    thumper: 'thumper.png',\n  });\n\n const assets = await Assets.loadBundle('animals');\n"})}),"\n",(0,a.jsxs)(n.p,{children:["However, the best way to handle bundles is to use a manifest and call ",(0,a.jsx)(n.code,{children:"Assets.init({manifest})"})," with said manifest (or even better, an URL pointing to it).\nSplitting our assets into bundles that correspond to screens or stages of our app will come in handy for loading in the background while the user is using the app instead of locking them in a single monolithic loading screen."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n   "bundles":[\n      {\n         "name":"load-screen",\n         "assets":[\n            {\n               "alias":"background",\n               "src":"sunset.png"\n            },\n            {\n               "alias":"bar",\n               "src":"load-bar.{png,webp}"\n            }\n         ]\n      },\n      {\n         "name":"game-screen",\n         "assets":[\n            {\n               "alias":"character",\n               "src":"robot.png"\n            },\n            {\n               "alias":"enemy",\n               "src":"bad-guy.png"\n            }\n         ]\n      }\n   ]\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'Assets.init({manifest: "path/manifest.json"});\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Beware that ",(0,a.jsxs)(n.strong,{children:["you can only call ",(0,a.jsx)(n.code,{children:"init"})," once"]}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Remember there is no downside in repeating URLs since they will all be cached, so if you need the same asset in two bundles you can duplicate the request without any extra cost!"}),"\n",(0,a.jsx)(n.h2,{id:"background-loading",children:"Background loading"}),"\n",(0,a.jsxs)(n.p,{children:["The old approach to loading was to use ",(0,a.jsx)(n.code,{children:"Loader"})," to load all your assets at the beginning of your app, but users are less patient now and want content to be instantly available so the practices are moving towards loading the bare minimum needed to show the user some content and, while they are interacting with that, we keep loading the following content in the background."]}),"\n",(0,a.jsxs)(n.p,{children:["Luckily, ",(0,a.jsx)(n.code,{children:"Assets"})," has us covered with a system that allows us to load everything in the background and in case we need some assets right now, bump them to the top of the queue so we can minimize loading times."]}),"\n",(0,a.jsxs)(n.p,{children:["To achieve this, we have the methods ",(0,a.jsx)(n.code,{children:"Assets.backgroundLoad(...)"})," and ",(0,a.jsx)(n.code,{children:"Assets.backgroundLoadBundle(...)"})," that will passively begin to load these assets in the background. So when you finally come to loading them you will get a promise that resolves to the loaded assets immediately."]}),"\n",(0,a.jsxs)(n.p,{children:["When you finally need the assets to show, you call the usual ",(0,a.jsx)(n.code,{children:"Assets.load(...)"})," or ",(0,a.jsx)(n.code,{children:"Assets.loadBundle(...)"})," and you will get the corresponding promise."]}),"\n",(0,a.jsx)(n.p,{children:"The best way to do this is using bundles, see the following example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { Application, Assets, Sprite } from 'pixi.js';\n\n// Create a new application\nconst app = new Application();\n\nasync function init()\n{\n    // Initialize the application\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Append the application canvas to the document body\n    document.body.appendChild(app.canvas);\n\n    // Manifest example\n    const manifestExample = {\n        bundles: [\n            {\n                name: 'load-screen',\n                assets: [\n                    {\n                        alias: 'flowerTop',\n                        src: 'https://pixijs.com/assets/flowerTop.png',\n                    },\n                ],\n            },\n            {\n                name: 'game-screen',\n                assets: [\n                    {\n                        alias: 'eggHead',\n                        src: 'https://pixijs.com/assets/eggHead.png',\n                    },\n                ],\n            },\n        ],\n    };\n\n    await Assets.init({ manifest: manifestExample });\n\n    // Bundles can be loaded in the background too!\n    Assets.backgroundLoadBundle(['load-screen', 'game-screen']);\n}\n\ninit();\n"})}),"\n",(0,a.jsx)(n.p,{children:"We create one bundle for each screen our game will have and set them all to start downloading at the beginning of our app. If the user progresses slowly enough in our app then they should never get to see a loading screen after the first one!"})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);