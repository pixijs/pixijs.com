"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["2253"],{73808:function(e,n,t){t.d(n,{A1:()=>i});var i={colors:{surface1:"#ffffff",surface2:"#F3F3F3",surface3:"#f5f5f5",clickable:"#959da5",base:"#24292e",disabled:"#d1d4d8",hover:"#24292e",accent:"#24292e"},syntax:{keyword:"#d73a49",property:"#005cc5",plain:"#24292e",static:"#032f62",string:"#032f62",definition:"#6f42c1",punctuation:"#24292e",tag:"#22863a",comment:{color:"#6a737d",fontStyle:"normal"}},font:{body:'-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',mono:'"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',size:"13px",lineHeight:"20px"}}},35684:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>l,default:()=>m,toc:()=>u,metadata:()=>i,assets:()=>d,contentTitle:()=>c});var i=JSON.parse('{"id":"examples/advanced/spinners","title":"Spinners","description":"","source":"@site/versioned_docs/version-7.x/examples/advanced/spinners.mdx","sourceDirName":"examples/advanced","slug":"/examples/advanced/spinners","permalink":"/7.x/examples/advanced/spinners","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"7.x","sidebarPosition":6,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":6,"custom_edit_url":null,"title":"Spinners"},"sidebar":"examplesSidebar","previous":{"title":"Collision Detection","permalink":"/7.x/examples/advanced/collision-detection"},"next":{"title":"Basic","permalink":"/7.x/examples/sprite/basic"}}'),a=t(85893),s=t(50065),r=t(31531),o=t(99883);let l={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:6,custom_edit_url:null,title:"Spinners"},c=void 0,d={},u=[];function p(e){return(0,a.jsx)(r.N,{files:{"index.js":"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n/* ---------------------------------------\n Spinner 1. Square with radial completion.\n -------------------------------------- */\nconst generateSpinner1 = (position) => {\n  const container = new PIXI.Container();\n\n  container.position = position;\n  app.stage.addChild(container);\n\n  const base = PIXI.Sprite.from('https://pixijs.com/assets/bg_scene_rotate.jpg');\n  const size = 100;\n\n  base.width = size;\n  base.height = size;\n\n  const bottom = PIXI.Sprite.from('https://pixijs.com/assets/bg_rotate.jpg');\n\n  bottom.width = size;\n  bottom.height = size;\n\n  const mask = new PIXI.Graphics();\n\n  mask.position.set(size / 2, size / 2);\n  base.mask = mask;\n  window.mask = mask;\n\n  container.addChild(bottom);\n  container.addChild(base);\n  container.addChild(mask);\n\n  let phase = 0;\n\n  return (delta) => {\n    // Update phase\n    phase += delta / 60;\n    phase %= Math.PI * 2;\n\n    // Calculate target point.\n    const x = Math.cos(phase - Math.PI / 2) * size;\n    const y = Math.sin(phase - Math.PI / 2) * size;\n\n    const segments = [\n      [-size / 2, -size / 2, size / 2, -size / 2], // top segment\n      [size / 2, -size / 2, size / 2, size / 2], // right\n      [-size / 2, size / 2, size / 2, size / 2], // bottom\n      [-size / 2, -size / 2, -size / 2, size / 2], // left\n    ];\n\n    // Find the intersecting segment.\n    let intersection = null;\n    let winding = 0;\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      const hit = intersect(0, 0, x, y, segment[0], segment[1], segment[2], segment[3]);\n\n      if (hit) {\n        intersection = hit;\n        if (i === 0) winding = hit.x > 0 ? 0 : 4;\n        else winding = i;\n        break;\n      }\n    }\n\n    const corners = [\n      size / 2,\n      -size / 2, // Top right\n      size / 2,\n      size / 2, // Bottom right\n      -size / 2,\n      size / 2, // Bottom left\n      -size / 2,\n      -size / 2, // Top left,\n      0,\n      -size / 2, // End point\n    ];\n\n    // Redraw mask\n    mask.clear();\n    mask.lineStyle(2, 0xff0000, 1);\n    mask.beginFill(0xff0000, 1);\n    mask.moveTo(0, -size / 2);\n    mask.lineTo(0, 0);\n\n    mask.lineTo(intersection.x, intersection.y);\n\n    // fill the corners\n    for (let i = winding; i < corners.length / 2; i++) {\n      mask.lineTo(corners[i * 2], corners[i * 2 + 1]);\n    }\n    mask.endFill();\n  };\n};\n\n/* -----------------------\n Spinner 2. Scaling balls.\n ---------------------- */\nconst generateSpinner2 = (position) => {\n  const container = new PIXI.Container();\n\n  container.position = position;\n  app.stage.addChild(container);\n\n  const size = 100;\n  const ballAmount = 7;\n  const balls = [];\n\n  for (let i = 0; i < ballAmount; i++) {\n    const ball = PIXI.Sprite.from('https://pixijs.com/assets/circle.png');\n\n    ball.anchor.set(0.5);\n    container.addChild(ball);\n    ball.position.set(\n      size / 2 + (Math.cos((i / ballAmount) * Math.PI * 2) * size) / 3,\n      size / 2 + (Math.sin((i / ballAmount) * Math.PI * 2) * size) / 3,\n    );\n    balls.push(ball);\n  }\n\n  let phase = 0;\n\n  return (delta) => {\n    // Update phase\n    phase += delta / 60;\n    phase %= Math.PI * 2;\n\n    // Update ball scales\n    balls.forEach((b, i) => {\n      const sin = Math.sin((i / ballAmount) * Math.PI - phase);\n      // Multiply sin with itself to get more steeper edge.\n\n      b.scale.set(Math.abs(sin * sin * sin * 0.5) + 0.5);\n    });\n  };\n};\n\n/* ---------------------\n Spinner 3. Radial mask.\n -------------------- */\nconst generateSpinner3 = (position) => {\n  const container = new PIXI.Container();\n\n  container.position = position;\n  app.stage.addChild(container);\n\n  const base = PIXI.Sprite.from('https://pixijs.com/assets/bg_scene_rotate.jpg');\n  const size = 100;\n\n  base.width = size;\n  base.height = size;\n\n  const mask = new PIXI.Graphics();\n\n  mask.position.set(size / 2, size / 2);\n  base.mask = mask;\n  window.mask = mask;\n\n  container.addChild(base);\n  container.addChild(mask);\n\n  let phase = 0;\n\n  return (delta) => {\n    // Update phase\n    phase += delta / 60;\n    phase %= Math.PI * 2;\n\n    const angleStart = 0 - Math.PI / 2;\n    const angle = phase + angleStart;\n    const radius = 50;\n\n    const x1 = Math.cos(angleStart) * radius;\n    const y1 = Math.sin(angleStart) * radius;\n\n    // Redraw mask\n    mask.clear();\n    mask.lineStyle(2, 0xff0000, 1);\n    mask.beginFill(0xff0000, 1);\n    mask.moveTo(0, 0);\n    mask.lineTo(x1, y1);\n    mask.arc(0, 0, radius, angleStart, angle, false);\n    mask.lineTo(0, 0);\n    mask.endFill();\n  };\n};\n\n/* ---------------------------------\n Spinner 4. Rounded rectangle edges.\n ------------------------------- */\nconst generateSpinner4 = (position) => {\n  const container = new PIXI.Container();\n\n  container.position = position;\n  app.stage.addChild(container);\n\n  const size = 100;\n  const arcRadius = 15;\n\n  const base = PIXI.Sprite.from('https://pixijs.com/assets/bg_scene_rotate.jpg');\n\n  base.width = size;\n  base.height = size;\n\n  // For better performance having assets prerounded would be better than masking.\n  const roundingMask = new PIXI.Graphics();\n\n  roundingMask.beginFill(0, 1);\n  roundingMask.lineStyle(1, 0xff0000, 1);\n  roundingMask.drawRoundedRect(0, 0, size, size, arcRadius);\n  roundingMask.endFill();\n  base.mask = roundingMask;\n\n  // The edge could be replaced with image as well.\n  const lineSize = 5;\n  const edge = new PIXI.Graphics();\n\n  edge.lineStyle(lineSize, 0xff0000, 1);\n  edge.drawRoundedRect(0, 0, size, size, arcRadius);\n  edge.endFill();\n\n  // Mask in this example works basically the same way as in example 1.\n  // Except it is reversed and calculates the mask in straight lines in edges.\n  const mask = new PIXI.Graphics();\n\n  mask.position.set(size / 2, size / 2);\n  edge.mask = mask;\n\n  container.addChild(base);\n  container.addChild(roundingMask);\n  container.addChild(edge);\n  container.addChild(mask);\n\n  let phase = 0;\n\n  return (delta) => {\n    // Update phase\n    phase += delta / 160;\n    phase %= Math.PI * 2;\n\n    // Calculate target point.\n    const x = Math.cos(phase - Math.PI / 2) * size;\n    const y = Math.sin(phase - Math.PI / 2) * size;\n    // Line segments\n    const segments = [\n      [-size / 2 + lineSize, -size / 2 + lineSize, size / 2 - lineSize, -size / 2 + lineSize], // top segment\n      [size / 2 - lineSize, -size / 2 + lineSize, size / 2 - lineSize, size / 2 - lineSize], // right\n      [-size / 2 + lineSize, size / 2 - lineSize, size / 2 - lineSize, size / 2 - lineSize], // bottom\n      [-size / 2 + lineSize, -size / 2 + lineSize, -size / 2 + lineSize, size / 2 - lineSize], // left\n    ];\n    // To which dir should mask continue at each segment\n    let outDir = [\n      [0, -1],\n      [1, 0],\n      [0, 1],\n      [-1, 0],\n    ];\n\n    // Find the intersecting segment.\n    let intersection = null;\n    let winding = 0;\n    // What direction should the line continue after hit has been found before hitting the line size\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      const hit = intersect(0, 0, x, y, segment[0], segment[1], segment[2], segment[3]);\n\n      if (hit) {\n        intersection = hit;\n        if (i === 0) winding = hit.x < 0 ? 0 : 4;\n        else winding = 4 - i;\n        outDir = outDir[i];\n        break;\n      }\n    }\n\n    const corners = [\n      -size / 2 - lineSize,\n      -size / 2 - lineSize, // Top left,\n      -size / 2 - lineSize,\n      size / 2 + lineSize, // Bottom left\n      size / 2 + lineSize,\n      size / 2 + lineSize, // Bottom right\n      size / 2 + lineSize,\n      -size / 2 - lineSize, // Top right\n    ];\n\n    // Redraw mask\n    mask.clear();\n    mask.lineStyle(2, 0x00ff00, 1);\n    mask.beginFill(0xff0000, 1);\n\n    mask.moveTo(0, 0);\n    mask.moveTo(0, -size / 2 - lineSize);\n\n    // fill the corners\n    for (let i = 0; i < winding; i++) {\n      mask.lineTo(corners[i * 2], corners[i * 2 + 1]);\n    }\n\n    mask.lineTo(intersection.x + outDir[0] * lineSize * 2, intersection.y + outDir[1] * lineSize * 2);\n    mask.lineTo(intersection.x, intersection.y);\n    mask.lineTo(0, 0);\n\n    mask.endFill();\n  };\n};\n\n/* ---------------------\n Spinner 5. Rounded rectangle fixed length spinner by jonlepage\n -------------------- */\nconst generateSpinner5 = (position) => {\n  const container = new PIXI.Container();\n\n  container.position = position;\n  app.stage.addChild(container);\n\n  const halfCircle = new PIXI.Graphics();\n\n  halfCircle.beginFill(0xff0000);\n  halfCircle.lineStyle(2, 0xffffff);\n  halfCircle.arc(0, 0, 100, 0, Math.PI);\n  halfCircle.endFill();\n  halfCircle.position.set(50, 50);\n\n  const rectangle = new PIXI.Graphics();\n\n  rectangle.lineStyle(2, 0xffffff, 1);\n  rectangle.drawRoundedRect(0, 0, 100, 100, 16);\n  rectangle.endFill();\n  rectangle.mask = halfCircle;\n\n  container.addChild(rectangle);\n  container.addChild(halfCircle);\n\n  let phase = 0;\n\n  return (delta) => {\n    // Update phase\n    phase += delta / 6;\n    phase %= Math.PI * 2;\n\n    halfCircle.rotation = phase;\n  };\n};\n\nconst onTick = [\n  generateSpinner1(new PIXI.Point(50, 50)),\n  generateSpinner2(new PIXI.Point(160, 50)),\n  generateSpinner3(new PIXI.Point(270, 50)),\n  generateSpinner4(new PIXI.Point(380, 50)),\n  generateSpinner5(new PIXI.Point(490, 50)),\n];\n\n// Listen for animate update\napp.ticker.add((delta) => {\n  // Call tick handling for each spinner.\n  onTick.forEach((cb) => {\n    cb(delta);\n  });\n});\n\n/**\n * Helper functions\n\n    line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/\n    Determine the intersection point of two line segments\n    Return FALSE if the lines don't intersect\n\n    Code modified from original to match pixi examples linting rules.\n*/\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false;\n  }\n\n  const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return false;\n  }\n\n  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return false;\n  }\n\n  // Return a object with the x and y coordinates of the intersection\n  const x = x1 + ua * (x2 - x1);\n  const y = y1 + ua * (y2 - y1);\n\n  return { x, y };\n}\n"},dependencies:{"pixi.js":o.npm}})}function m(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},18064:function(e,n,t){t.d(n,{M:()=>S});var i=t(67294);let a={colors:{surface1:"#242426",surface2:"#444950",surface3:"#44475a",clickable:"#fff",base:"#f8f8f2",disabled:"#6272a4",hover:"#f8f8f2",accent:"#e91e63",error:"#f8f8f2",errorSurface:"#44475a"},syntax:{plain:"#f8f8f2",comment:{color:"#6272a4",fontStyle:"italic"},keyword:"#ff79c6",tag:"#ff79c6",punctuation:"#ff79c6",definition:"#f8f8f2",property:"#50fa7b",static:"#bd93f9",string:"#f1fa8c"},font:{body:'-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',mono:'"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',size:"13px",lineHeight:"20px"}},s=e=>{let n=e.split(".");return n[n.length-1]},r=e=>{let n=s(e);return"js"===n?"javascript":"ts"===n?"typescript":"vert"===n||"frag"===n?"glsl":n},o=e=>(0,i.useMemo)(()=>r(e),[e]),l=async e=>{let n=`pixi-definitions-${e}`,t=JSON.parse(localStorage.getItem(n))||null;if(!t)try{let t=await fetch(`https://cdn.jsdelivr.net/npm/pixi.js@${e}/dist/pixi.js.d.ts`),i=await t.text();if(i.startsWith("// Generated by dts-bundle-generator"))return localStorage.setItem(n,JSON.stringify(i)),i;return null}catch(e){return console.error("Failed to fetch pixi.js types:",e),null}return t},c=(e,n="latest")=>{(0,i.useEffect)(()=>{let t=async e=>{let t=await l(n),i=`declare module 'pixi.js' { ${t} }`,a=`
            declare module '*.wgsl' {
                const shader: 'string';
                export default shader;
            }

            declare module '*.vert' {
                const shader: 'string';
                export default shader;
            }

            declare module '*.frag' {
                const shader: 'string';
                export default shader;
            }`;e.languages.typescript.typescriptDefaults.addExtraLib(i,"file:///node_modules/pixi.js/index.d.ts"),e.languages.typescript.javascriptDefaults.addExtraLib(i,"file:///node_modules/pixi.js/index.d.ts"),e.languages.typescript.typescriptDefaults.addExtraLib(a),e.languages.typescript.javascriptDefaults.addExtraLib(a);let{languages:s}=e,r="glsl";s.register({id:r,extensions:[".frag",".vert"]}),s.setLanguageConfiguration(r,{comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"',notIn:["string"]},{open:"'",close:"'",notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]}),s.setMonarchTokensProvider(r,{tokenPostfix:".glsl",defaultToken:"invalid",directives:["#","#define","#undef","#if","#ifdef","#ifndef","#else","#elif","#endif","#error","#pragma","#extension","#version","#line"],macros:["__LINE__","__FILE__","__VERSION__"],storage:["in","out","uniform","layout","attribute","varying","precision","highp","mediump","lowp"],types:["void","bool","int","uint","float","double","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","uvec2","uvec3","uvec4","dvec2","dvec3","dvec4","mat2","mat3","mat4","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","dmat2","dmat3","dmat4","dmat2x2","dmat2x3","dmat2x4","dmat3x2","dmat3x3","dmat3x4","dmat4x2","dmat4x3","dmat4x4","sampler1D","texture1D","image1D","sampler1DShadow","sampler1DArray","texture1DArray","image1DArray","sampler1DArrayShadow","sampler2D","texture2D","image2D","sampler2DShadow","sampler2DArray","texture2DArray","image2DArray","sampler2DArrayShadow","sampler2DMS","texture2DMS","image2DMS","sampler2DMSArray","texture2DMSArray","image2DMSArray","sampler2DRect","texture2DRect","image2DRect","sampler2DRectShadow","sampler3D","texture3D","image3D","samplerCube","textureCube","imageCube","samplerCubeShadow","samplerCubeArray","textureCubeArray","imageCubeArray","samplerCubeArrayShadow","samplerBuffer","textureBuffer","imageBuffer","subpassInput","subpassInputMS","isampler1D","itexture1D","iimage1D","isampler1DArray","itexture1DArray","iimage1DArray","isampler2D","itexture2D","iimage2D","isampler2DArray","itexture2DArray","iimage2DArray","isampler2DMS","itexture2DMS","iimage2DMS","isampler2DMSArray","itexture2DMSArray","iimage2DMSArray","isampler2DRect","itexture2DRect","iimage2DRect","isampler3D","itexture3D","iimage3D","isamplerCube","itextureCube","iimageCube","isamplerCubeArray","itextureCubeArray","iimageCubeArray","isamplerBuffer","itextureBuffer","iimageBuffer","isubpassInput","isubpassInputMS","usampler1D","utexture1D","uimage1D","usampler1DArray","utexture1DArray","uimage1DArray","usampler2D","utexture2D","uimage2D","usampler2DArray","utexture2DArray","uimage2DArray","usampler2DMS","utexture2DMS","uimage2DMS","usampler2DMSArray","utexture2DMSArray","uimage2DMSArray","usampler2DRect","utexture2DRect","uimage2DRect","usampler3D","utexture3D","uimage3D","usamplerCube","utextureCube","uimageCube","usamplerCubeArray","utextureCubeArray","uimageCubeArray","usamplerBuffer","utextureBuffer","uimageBuffer","atomic_uint","usubpassInput","usubpassInputMS","sampler","samplerShadow"],operators:["*","+","-","/","~","!","%","<<",">>","<",">","<=",">=","==","!=","&","^","|","&&","^^","||","=","+=","-=","*=","/=","%=","<<=",">>=","&=","^=","|="],builtin_vars:["gl_VertexID","gl_InstanceID","gl_VertexIndex","gl_InstanceIndex","gl_DrawID","gl_BaseVertex","gl_BaseInstance","gl_Position","gl_PointSize","gl_ClipDistance","gl_CullDistance","gl_Color","gl_SecondaryColor","gl_Normal","gl_Vertex","gl_MultiTexCoord0","gl_MultiTexCoord1","gl_MultiTexCoord2","gl_MultiTexCoord3","gl_MultiTexCoord4","gl_MultiTexCoord5","gl_MultiTexCoord6","gl_MultiTexCoord7","gl_FogCoord"],constants:["gl_MaxVertexAttribs","gl_MaxVertexUniformVectors","gl_MaxVertexUniformComponents","gl_MaxVertexOutputComponents"],intsuffix:"[uU]?",floatsuffix:"([fF]|(fl|FL))?",tokenizer:{root:[[/\/\/.*$/,"comment.line"],[/\/\*/,"comment.block","@comment"],[/#[a-z]*/,{cases:{"@directives":"keyword.control.preprocessor","@default":"invalid"}}],["GL_ES","meta.preprocessor"],[/__[A-Z_]+__/,{cases:{"@macros":"meta.preprocessor","@default":"invalid"}}],[/[{}()\[\]]/,"@brackets"],[/(true|false)/,"constant"],[/[\=\+\-\*\/\>\<\&\|\%\!\^]+/,{cases:{"@operators":"operator","@default":"invalid"}}],[/[a-zA-Z][a-zA-Z0-9_]*(?=\()/,"entity.name.function"],[/[a-zA-Z][a-zA-Z0-9_]*/,{cases:{"@storage":"storage.type","@types":"entity.name.type","@builtin_vars":"keyword","@default":"variable.name"}}],[/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/,"number.float"],[/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/,"number.float"],[/0[xX][0-9a-fA-F](@intsuffix)/,"number.hex"],[/0[0-7](@intsuffix)/,"number.octal"],[/\d+(@intsuffix)/,"number"],[/[;,.]/,"delimiter"]],comment:[["\\*/","comment.block","@pop"],[".*","comment.block"]]}})};e&&t(e)},[e,n])};var d=t(93862),u=t(35283),p=t(51443),m=t(85893);function f({fontSize:e=12,style:n,pixiVersion:t,handleEditorCodeChanged:a}){let{code:s,updateCode:r}=(0,d.m4)(),{sandpack:l}=(0,d.X3)(),f=function(){let[e,n]=(0,i.useState)(null),t=(0,i.useRef)(!0),a=(0,i.useRef)(null);return(0,i.useEffect)(()=>{let e=p._m.__getMonacoInstance();if(e)return void n(e);if(!a.current){p._m.config({"vs/nls":{availableLanguages:{}}});try{a.current=p._m.init(),a.current.then(e=>{t.current&&n(e)}).catch(e=>{t.current&&"cancelation"!==e.type&&console.error("Monaco initialization error:",e)})}catch(e){console.error("Failed to initialize Monaco:",e)}}return()=>{t.current=!1}},[]),e}(),h=o(l.activeFile),{colorMode:g}=(0,u.I)();return c(f,t),(0,m.jsxs)(d.el,{style:{height:"100%",margin:0,...n},children:[(0,m.jsx)(d.aM,{}),(0,m.jsx)("div",{style:{flex:1,paddingTop:8,background:"dark"===g?"#1e1e1e":"#FFFFFE"},children:(0,m.jsx)(p.ML,{width:"100%",height:"100%",language:h,theme:"dark"===g?"vs-dark":"light",defaultValue:s,onChange:e=>{r(e||""),a?.(e)},options:{minimap:{enabled:!1},scrollBeyondLastLine:!1,wordWrap:"on",automaticLayout:!0,fontSize:e}},l.activeFile)})]})}let h=({onClick:e})=>(0,m.jsx)(d.z,{style:{position:"relative"},onClick:e,children:(0,m.jsx)(d.zD,{})}),g=({onSelectionChange:e,defaultSelection:n="both"})=>{let[t,a]=(0,i.useState)(n),{colorMode:s}=(0,u.I)(),r=n=>{a(n),e(n)},o={height:"100%",width:"max-content",padding:"0 16px",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",color:"dark"===s?"#F6F8FA":"#2E3138",border:"none"},l="dark"===s?"#22232A":"#e2e2e2";return(0,m.jsxs)("div",{style:{height:32,width:"100%",overflow:"hidden",backgroundColor:"dark"===s?"#2E3138":"#F6F8FA",display:"flex",justifyContent:"right",borderBottomLeftRadius:4,borderBottomRightRadius:4},children:[(0,m.jsx)("button",{onClick:()=>r("editor"),style:{backgroundColor:"editor"===t?l:"transparent",...o},children:"Editor"}),(0,m.jsx)("button",{onClick:()=>r("preview"),style:{backgroundColor:"preview"===t?l:"transparent",...o},children:"Preview"}),(0,m.jsx)("button",{onClick:()=>r("both"),style:{backgroundColor:"both"===t?l:"transparent",...o},children:"Both"})]})};function x(e){let{viewType:n,showConsole:t,fontSize:a,pixiVersion:s}=e,[r,o]=(0,i.useState)(t),[l,c]=(0,i.useState)(n),u=(0,m.jsx)(m.Fragment,{children:(0,m.jsx)(h,{onClick:()=>o(e=>!e)})});return(0,m.jsxs)("div",{style:{height:"100%",width:"100%",display:"flex",flexDirection:"column"},children:[(0,m.jsxs)(d.sp,{style:{height:"100%",overflow:"hidden",borderBottomLeftRadius:0,borderBottomRightRadius:0,flexWrap:"nowrap"},children:[(0,m.jsx)(f,{fontSize:a,style:{flexGrow:+("preview"!==l),flexShrink:+("preview"!==l),flexBasis:"editor"===l?"100%":0,width:"100%",overflow:"hidden"},pixiVersion:s,handleEditorCodeChanged:e.handleEditorCodeChanged}),(0,m.jsxs)(d.el,{style:{height:"100%",width:"100%"},children:[(0,m.jsx)(d.Gj,{style:{flexGrow:100*("editor"!==l),flexShrink:100*("editor"!==l),flexBasis:"editor"!==l?"100%":0,overflow:"hidden"},showOpenInCodeSandbox:!1,actionsChildren:u}),r&&(0,m.jsx)("div",{style:{flexGrow:35*!!r,flexShrink:35*!!r,flexBasis:r?"35%":0,width:"100%",overflow:"hidden"},children:(0,m.jsx)(d.Tq,{showHeader:!1})})]})]}),(0,m.jsx)(g,{onSelectionChange:e=>{c(e)},defaultSelection:l})]})}var b=t(73808),y=t(646);function S({viewType:e="both",showConsole:n=!1,width:t="100%",height:s="100%",dependencies:r={"pixi.js":"latest"},files:o={"index.js":"// Your code here"},fontSize:l=12,handleEditorCodeChanged:c}){let{colorMode:p}=(0,u.I)(),f={...o};delete f["index.js"];let[h]=(0,i.useState)({"/index.html":{code:'<!doctype html>\n<html>\n  <head>\n    <title>PixiJS Playground</title>\n    <meta charset="UTF-8" />\n    <link rel="stylesheet" href="./styles.css" />\n  </head>\n  <body>\n    <script src="index.js"><\/script>\n  </body>\n</html>\n',hidden:!0},"/styles.css":{code:"body {\n  margin: 0;\n  overflow: hidden;\n}\n",hidden:!0},"sandbox.config.json":{code:'{"infiniteLoopProtection": false}',hidden:!0},"index.ts":{code:"",hidden:!0,active:!1},"index.js":{code:o["index.js"]??"// Your code here",hidden:!1,active:!0},...f});return(0,m.jsx)(y.Z,{children:()=>(0,m.jsx)(d.oT,{template:"vanilla-ts",theme:"dark"===p?a:b.A1,files:h,customSetup:{dependencies:r,entry:"index.html"},style:{height:s,width:t,margin:"0 auto",maxWidth:"100%"},options:{recompileDelay:500},children:(0,m.jsx)(x,{handleEditorCodeChanged:c,viewType:e,showConsole:n,fontSize:l,pixiVersion:r["pixi.js"]})})})}},31531:function(e,n,t){t.d(n,{N:()=>r});var i=t(18064),a=t(18146),s=t(85893);function r(e){return(0,a.J)("example",!0),(0,s.jsx)(i.M,{height:"calc(100vh - 325px)",fontSize:14,...e})}},18146:function(e,n,t){t.d(n,{J:()=>a});var i=t(67294);let a=(e,n=!0)=>{(0,i.useEffect)(()=>{let t=document.querySelector("main > .container");if(null!==t&&n)return t.classList.add(e),()=>{t.classList.remove(e)}},[e,n])}},50065:function(e,n,t){t.d(n,{Z:()=>o,a:()=>r});var i=t(67294);let a={},s=i.createContext(a);function r(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},99883:function(e){e.exports=JSON.parse('{"versionLabel":"v7.x","version":"7.4.2","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.4.2","build":"https://pixijs.download/v7.4.2/pixi.min.js","docs":"https://pixijs.download/v7.4.2/docs/index.html","npm":"7.4.2","prerelease":false,"latest":false}')}}]);