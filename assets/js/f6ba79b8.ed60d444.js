"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["3566"],{39112:function(e,n,i){i.r(n),i.d(n,{frontMatter:()=>l,default:()=>h,toc:()=>c,metadata:()=>s,assets:()=>o,contentTitle:()=>a});var s=JSON.parse('{"id":"guides/production/performance-tips","title":"Performance Tips","description":"General","source":"@site/versioned_docs/version-7.x/guides/production/performance-tips.md","sourceDirName":"guides/production","slug":"/guides/production/performance-tips","permalink":"/7.x/guides/production/performance-tips","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/pixijs.com/tree/main/versioned_docs/version-7.x/guides/production/performance-tips.md","tags":[],"version":"7.x","frontMatter":{},"sidebar":"guidesSidebar","previous":{"title":"Textures","permalink":"/7.x/guides/components/textures"},"next":{"title":"Upgrading PixiJS","permalink":"/7.x/guides/migrations/upgrading"}}'),t=i(85893),r=i(50065);let l={},a="Performance Tips",o={},c=[{value:"General",id:"general",level:3},{value:"Sprites",id:"sprites",level:3},{value:"Graphics",id:"graphics",level:3},{value:"Texture",id:"texture",level:3},{value:"Text",id:"text",level:3},{value:"Masks",id:"masks",level:3},{value:"Filters",id:"filters",level:3},{value:"BlendModes",id:"blendmodes",level:3},{value:"CacheAsBitmap",id:"cacheasbitmap",level:3},{value:"Events",id:"events",level:3}];function d(e){let n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"performance-tips",children:"Performance Tips"})}),"\n",(0,t.jsx)(n.h3,{id:"general",children:"General"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Only optimize when you need to! PixiJS can handle a fair amount of content off the bat"}),"\n",(0,t.jsx)(n.li,{children:"Be mindful of the complexity of your scene. The more objects you add the slower things will end up"}),"\n",(0,t.jsx)(n.li,{children:"Order can help, for example sprite / graphic / sprite / graphic is slower than sprite / sprite / graphic / graphic"}),"\n",(0,t.jsxs)(n.li,{children:["Some older mobile devices run things a little slower. Passing in the option ",(0,t.jsx)(n.code,{children:"useContextAlpha: false"})," and ",(0,t.jsx)(n.code,{children:"antialias: false"})," to the Renderer or Application can help with performance"]}),"\n",(0,t.jsxs)(n.li,{children:["Culling is disabled by default as it's often better to do this at an application level or set objects to be ",(0,t.jsx)(n.code,{children:"cullable = true"}),". If you are GPU-bound it will improve performance; if you are CPU-bound it will degrade performance"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"sprites",children:"Sprites"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use Spritesheets where possible to minimize total textures"}),"\n",(0,t.jsx)(n.li,{children:"Sprites can be batched with up to 16 different textures (dependent on hardware)"}),"\n",(0,t.jsx)(n.li,{children:"This is the fastest way to render content"}),"\n",(0,t.jsx)(n.li,{children:"On older devices use smaller low resolution textures"}),"\n",(0,t.jsxs)(n.li,{children:["Add the extention ",(0,t.jsx)(n.code,{children:"@0.5x.png"})," to the 50% scale-down spritesheet so PixiJS will visually-double them automatically"]}),"\n",(0,t.jsx)(n.li,{children:"Draw order can be important"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"graphics",children:"Graphics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Graphics objects are fastest when they are not modified constantly (not including the transform, alpha or tint!)"}),"\n",(0,t.jsx)(n.li,{children:"Graphics objects are batched when under a certain size (100 points or smaller)"}),"\n",(0,t.jsx)(n.li,{children:"Small Graphics objects are as fast as Sprites (rectangles, triangles)"}),"\n",(0,t.jsx)(n.li,{children:"Using 100s of graphics complex objects can be slow, in this instance use sprites (you can create a texture)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"texture",children:"Texture"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Textures are automatically managed by a Texture Garbage Collector"}),"\n",(0,t.jsxs)(n.li,{children:["You can also manage them yourself by using ",(0,t.jsx)(n.code,{children:"texture.destroy()"})]}),"\n",(0,t.jsx)(n.li,{children:"If you plan to destroy more than one at once add a random delay to their destruction to remove freezing"}),"\n",(0,t.jsx)(n.li,{children:"Delay texture destroy if you plan to delete a lot of textures yourself"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"text",children:"Text"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Avoid changing it on every frame as this can be expensive (each time it draws to a canvas and then uploads to GPU)"}),"\n",(0,t.jsx)(n.li,{children:"Bitmap Text gives much better performance for dynamically changing text"}),"\n",(0,t.jsxs)(n.li,{children:["Text resolution matches the renderer resolution, decrease resolution yourself by setting the ",(0,t.jsx)(n.code,{children:"resolution"})," property, which can consume less memory"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"masks",children:"Masks"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Masks can be expensive if too many are used: e.g., 100s of masks will really slow things down"}),"\n",(0,t.jsx)(n.li,{children:"Axis-aligned Rectangle masks are the fastest (as the use scissor rect)"}),"\n",(0,t.jsx)(n.li,{children:"Graphics masks are second fastest (as they use the stencil buffer)"}),"\n",(0,t.jsx)(n.li,{children:"Sprite masks are the third fastest (they uses filters). They are really expensive. Do not use too many in your scene!"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"filters",children:"Filters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Release memory: ",(0,t.jsx)(n.code,{children:"displayObject.filters = null"})]}),"\n",(0,t.jsxs)(n.li,{children:["If you know the size of them: ",(0,t.jsx)(n.code,{children:"displayObject.filterArea = new PIXI.Rectangle(x,y,w,h)"}),". This can speed things up as it means the object does not need to be measured"]}),"\n",(0,t.jsx)(n.li,{children:"Filters are expensive, using too many will start to slow things down!"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"blendmodes",children:"BlendModes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Different blend modes will cause batches to break (de-optimize)"}),"\n",(0,t.jsx)(n.li,{children:"SceenSprite / NormalSprite / SceenSprite / NormalSprite would be 4 draw calls"}),"\n",(0,t.jsx)(n.li,{children:"SceenSprite / SceenSprite / NormalSprite / NormalSprite would be 2 draw calls"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"cacheasbitmap",children:"CacheAsBitmap"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Setting to ",(0,t.jsx)(n.code,{children:"true"})," turns an object into a Sprite by caching it as a Texture"]}),"\n",(0,t.jsx)(n.li,{children:"It has a one time cost when it is activated as it draws the object to a Texture"}),"\n",(0,t.jsx)(n.li,{children:"Avoid changing this on elements frequently"}),"\n",(0,t.jsx)(n.li,{children:"If you have a complicated item that has lots of sprites / filters AND does not move then this will speed up rendering!"}),"\n",(0,t.jsx)(n.li,{children:"Do not need apply to sprites as they are already Textures"}),"\n",(0,t.jsx)(n.li,{children:"Do not use if the object where its children are constantly changing as this will slow things down"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If an object has no interactive children use ",(0,t.jsx)(n.code,{children:"interactiveChildren = false"}),". The event system will then be able to avoid crawling through the object"]}),"\n",(0,t.jsxs)(n.li,{children:["Setting ",(0,t.jsx)(n.code,{children:"hitArea = new PIXI.Rectangle(x,y,w,h)"})," as above should stop the event system from crawling through the object"]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},50065:function(e,n,i){i.d(n,{Z:()=>a,a:()=>l});var s=i(67294);let t={},r=s.createContext(t);function l(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);