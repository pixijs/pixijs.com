"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["2424"],{26266:function(e,r,s){s.r(r),s.d(r,{frontMatter:()=>o,default:()=>u,toc:()=>l,metadata:()=>t,assets:()=>c,contentTitle:()=>d});var t=JSON.parse('{"id":"guides/components/textures","title":"Textures","description":"Learn how PixiJS handles textures, their lifecycle, creation, and types, including how to manage GPU resources effectively.","source":"@site/docs/guides/components/textures.md","sourceDirName":"guides/components","slug":"/guides/components/textures","permalink":"/8.x/guides/components/textures","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/pixijs.com/tree/main/docs/guides/components/textures.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"description":"Learn how PixiJS handles textures, their lifecycle, creation, and types, including how to manage GPU resources effectively."},"sidebar":"guidesSidebar","previous":{"title":"Renderers","permalink":"/8.x/guides/components/renderers/"},"next":{"title":"Scene Objects","permalink":"/8.x/guides/components/scene-objects/"}}'),n=s(85893),i=s(50065);let o={sidebar_position:3,description:"Learn how PixiJS handles textures, their lifecycle, creation, and types, including how to manage GPU resources effectively."},d="Textures",c={},l=[{value:"Texture Lifecycle",id:"texture-lifecycle",level:2},{value:"Lifecycle Flow",id:"lifecycle-flow",level:3},{value:"Loading Textures",id:"loading-textures",level:3},{value:"Preparing Textures",id:"preparing-textures",level:3},{value:"Texture vs. TextureSource",id:"texture-vs-texturesource",level:2},{value:"Texture Creation",id:"texture-creation",level:2},{value:"Destroying Textures",id:"destroying-textures",level:2},{value:"Unload Texture from GPU",id:"unload-texture-from-gpu",level:2},{value:"Texture Types",id:"texture-types",level:2},{value:"Common Texture Properties",id:"common-texture-properties",level:2},{value:"Common TextureSource Properties",id:"common-texturesource-properties",level:2},{value:"API Reference",id:"api-reference",level:2}];function a(e){let r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"textures",children:"Textures"})}),"\n",(0,n.jsx)(r.p,{children:"Textures are one of the most essential components in the PixiJS rendering pipeline. They define the visual content used by Sprites, Meshes, and other renderable objects. This guide covers how textures are loaded, created, and used, along with the various types of data sources PixiJS supports."}),"\n",(0,n.jsx)(r.h2,{id:"texture-lifecycle",children:"Texture Lifecycle"}),"\n",(0,n.jsx)(r.p,{children:"The texture system is built around two major classes:"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"TextureSource"})}),": Represents a pixel source, such as an image, canvas, or video."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"Texture"})}),": Defines a view into a ",(0,n.jsx)(r.code,{children:"TextureSource"}),", including sub-rectangles, trims, and transformations."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"lifecycle-flow",children:"Lifecycle Flow"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"Source File/Image -> TextureSource -> Texture -> Sprite (or other display object)\n"})}),"\n",(0,n.jsx)(r.h3,{id:"loading-textures",children:"Loading Textures"}),"\n",(0,n.jsxs)(r.p,{children:["Textures can be loaded asynchronously using the ",(0,n.jsx)(r.code,{children:"Assets"})," system:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"const texture = await Assets.load('myTexture.png');\n\nconst sprite = new Sprite(texture);\n"})}),"\n",(0,n.jsx)(r.h3,{id:"preparing-textures",children:"Preparing Textures"}),"\n",(0,n.jsxs)(r.p,{children:["Even after you've loaded your textures, the images still need to be pushed to the GPU and decoded. Doing this for a large number of source images can be slow and cause lag spikes when your project first loads. To solve this, you can use the ",(0,n.jsx)(r.a,{href:"https://pixijs.download/release/docs/rendering.PrepareSystem.html",children:"Prepare"})," plugin, which allows you to pre-load textures in a final step before displaying your project."]}),"\n",(0,n.jsx)(r.h2,{id:"texture-vs-texturesource",children:"Texture vs. TextureSource"}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"TextureSource"})," handles the raw pixel data and GPU upload. A ",(0,n.jsx)(r.code,{children:"Texture"})," is a lightweight view on that source, with metadata such as trimming, frame rectangle, UV mapping, etc. Multiple ",(0,n.jsx)(r.code,{children:"Texture"})," instances can share a single ",(0,n.jsx)(r.code,{children:"TextureSource"}),", such as in a sprite sheet."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"const sheet = await Assets.load('spritesheet.json');\nconst heroTexture = sheet.textures['hero.png'];\n"})}),"\n",(0,n.jsx)(r.h2,{id:"texture-creation",children:"Texture Creation"}),"\n",(0,n.jsx)(r.p,{children:"You can manually create textures using the constructor:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"const mySource = new TextureSource({ resource: myImage });\nconst texture = new Texture({ source: mySource });\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Set ",(0,n.jsx)(r.code,{children:"dynamic: true"})," in the ",(0,n.jsx)(r.code,{children:"Texture"})," options if you plan to modify its ",(0,n.jsx)(r.code,{children:"frame"}),", ",(0,n.jsx)(r.code,{children:"trim"}),", or ",(0,n.jsx)(r.code,{children:"source"})," at runtime."]}),"\n",(0,n.jsx)(r.h2,{id:"destroying-textures",children:"Destroying Textures"}),"\n",(0,n.jsxs)(r.p,{children:["Once you're done with a Texture, you may wish to free up the memory (both WebGL-managed buffers and browser-based) that it uses. To do so, you should call ",(0,n.jsx)(r.code,{children:"Assets.unload('texture.png')"}),", or ",(0,n.jsx)(r.code,{children:"texture.destroy()"})," if you have created the texture outside of Assets."]}),"\n",(0,n.jsxs)(r.p,{children:["This is a particularly good idea for short-lived imagery like cut-scenes that are large and will only be used once. If a texture is destroyed that was loaded via ",(0,n.jsx)(r.code,{children:"Assets"})," then the assets class will automatically remove it from the cache for you."]}),"\n",(0,n.jsx)(r.h2,{id:"unload-texture-from-gpu",children:"Unload Texture from GPU"}),"\n",(0,n.jsxs)(r.p,{children:["If you want to unload a texture from the GPU but keep it in memory, you can call ",(0,n.jsx)(r.code,{children:"texture.source.unload()"}),". This will remove the texture from the GPU but keep the source in memory."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"// Load the texture\nconst texture = await Assets.load('myTexture.png');\n\n// ... Use the texture\n\n// Unload the texture from the GPU\ntexture.source.unload();\n"})}),"\n",(0,n.jsx)(r.h2,{id:"texture-types",children:"Texture Types"}),"\n",(0,n.jsxs)(r.p,{children:["PixiJS supports multiple ",(0,n.jsx)(r.code,{children:"TextureSource"})," types, depending on the kind of input data:"]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Texture Type"}),(0,n.jsx)(r.th,{children:"Description"})]})}),(0,n.jsxs)(r.tbody,{children:[(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:"ImageSource"})}),(0,n.jsx)(r.td,{children:"HTMLImageElement, ImageBitmap, SVG's, VideoFrame, etc."})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:"CanvasSource"})}),(0,n.jsx)(r.td,{children:"HTMLCanvasElement or OffscreenCanvas"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:"VideoSource"})}),(0,n.jsx)(r.td,{children:"HTMLVideoElement with optional auto-play and update FPS"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:"BufferImageSource"})}),(0,n.jsx)(r.td,{children:"TypedArray or ArrayBuffer with explicit width, height, and format"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:"CompressedSource"})}),(0,n.jsx)(r.td,{children:"Array of compressed mipmaps (Uint8Array[])"})]})]})]}),"\n",(0,n.jsx)(r.h2,{id:"common-texture-properties",children:"Common Texture Properties"}),"\n",(0,n.jsxs)(r.p,{children:["Here are some important properties of the ",(0,n.jsx)(r.code,{children:"Texture"})," class:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"frame"}),": Rectangle defining the visible portion within the source."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"orig"}),": Original untrimmed dimensions."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"trim"}),": Defines trimmed regions to exclude transparent space."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"uvs"}),": UV coordinates generated from ",(0,n.jsx)(r.code,{children:"frame"})," and ",(0,n.jsx)(r.code,{children:"rotate"}),"."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"rotate"}),": GroupD8 rotation value for atlas compatibility."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"defaultAnchor"}),": Default anchor when used in Sprites."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"defaultBorders"}),": Used for 9-slice scaling."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"source"}),": The ",(0,n.jsx)(r.code,{children:"TextureSource"})," instance."]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"common-texturesource-properties",children:"Common TextureSource Properties"}),"\n",(0,n.jsxs)(r.p,{children:["Here are some important properties of the ",(0,n.jsx)(r.code,{children:"TextureSource"})," class:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"resolution"}),": Affects render size relative to actual pixel size."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"format"}),": Texture format (e.g., ",(0,n.jsx)(r.code,{children:"rgba8unorm"}),", ",(0,n.jsx)(r.code,{children:"bgra8unorm"}),", etc.)"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"alphaMode"}),": Controls how alpha is interpreted on upload."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"wrapMode"})," / ",(0,n.jsx)(r.code,{children:"scaleMode"}),": Controls how texture is sampled outside of bounds or when scaled."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"autoGenerateMipmaps"}),": Whether to generate mipmaps on upload."]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["You can set these properties when creating a ",(0,n.jsx)(r.code,{children:"TextureSource"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"texture.source.scaleMode = 'linear';\ntexture.source.wrapMode = 'repeat';\n"})}),"\n",(0,n.jsx)(r.hr,{}),"\n",(0,n.jsx)(r.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://pixijs.download/release/docs/rendering.Texture.html",children:"Texture"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://pixijs.download/release/docs/rendering.TextureSource.html",children:"TextureSource"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://pixijs.download/release/docs/rendering.TextureStyle.html",children:"TextureStyle"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://pixijs.download/release/docs/rendering.RenderTexture.html",children:"RenderTexture"})}),"\n"]})]})}function u(e={}){let{wrapper:r}={...(0,i.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}}}]);