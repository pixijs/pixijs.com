"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["2345"],{32068:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>c,metadata:()=>o,assets:()=>d,toc:()=>l,contentTitle:()=>u});var o=JSON.parse('{"id":"examples/advanced/collision-detection","title":"Collision Detection","description":"","source":"@site/versioned_docs/version-7.x/examples/advanced/collision-detection.mdx","sourceDirName":"examples/advanced","slug":"/examples/advanced/collision-detection","permalink":"/7.x/examples/advanced/collision-detection","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"7.x","sidebarPosition":5,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":5,"custom_edit_url":null,"title":"Collision Detection"},"sidebar":"examplesSidebar","previous":{"title":"Screen Shot","permalink":"/7.x/examples/advanced/screen-shot"},"next":{"title":"Spinners","permalink":"/7.x/examples/advanced/spinners"}}'),r=t("85893"),s=t("50065"),a=t("67963"),i=t("99883");let c={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:5,custom_edit_url:null,title:"Collision Detection"},u=void 0,d={},l=[];function p(e){return(0,r.jsx)(a.N,{files:{"index.js":"import * as PIXI from 'pixi.js';\n\n// Based somewhat on this article by Spicy Yoghurt\n// URL for further reading: https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics\nconst app = new PIXI.Application({ background: '#111', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Options for how objects interact\n// How fast the red square moves\nconst movementSpeed = 0.05;\n\n// Strength of the impulse push between two objects\nconst impulsePower = 5;\n\n// Test For Hit\n// A basic AABB check between two different squares\nfunction testForAABB(object1, object2)\n{\n    const bounds1 = object1.getBounds();\n    const bounds2 = object2.getBounds();\n\n    return (\n        bounds1.x < bounds2.x + bounds2.width\n        && bounds1.x + bounds1.width > bounds2.x\n        && bounds1.y < bounds2.y + bounds2.height\n        && bounds1.y + bounds1.height > bounds2.y\n    );\n}\n\n// Calculates the results of a collision, allowing us to give an impulse that\n// shoves objects apart\nfunction collisionResponse(object1, object2)\n{\n    if (!object1 || !object2)\n    {\n        return new PIXI.Point(0);\n    }\n\n    const vCollision = new PIXI.Point(object2.x - object1.x, object2.y - object1.y);\n\n    const distance = Math.sqrt(\n        (object2.x - object1.x) * (object2.x - object1.x) + (object2.y - object1.y) * (object2.y - object1.y),\n    );\n\n    const vCollisionNorm = new PIXI.Point(vCollision.x / distance, vCollision.y / distance);\n\n    const vRelativeVelocity = new PIXI.Point(\n        object1.acceleration.x - object2.acceleration.x,\n        object1.acceleration.y - object2.acceleration.y,\n    );\n\n    const speed = vRelativeVelocity.x * vCollisionNorm.x + vRelativeVelocity.y * vCollisionNorm.y;\n\n    const impulse = (impulsePower * speed) / (object1.mass + object2.mass);\n\n    return new PIXI.Point(impulse * vCollisionNorm.x, impulse * vCollisionNorm.y);\n}\n\n// Calculate the distance between two given points\nfunction distanceBetweenTwoPoints(p1, p2)\n{\n    const a = p1.x - p2.x;\n    const b = p1.y - p2.y;\n\n    return Math.hypot(a, b);\n}\n\n// The green square we will knock about\nconst greenSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\n\ngreenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\ngreenSquare.width = 100;\ngreenSquare.height = 100;\ngreenSquare.tint = 0x00ff00;\ngreenSquare.acceleration = new PIXI.Point(0);\ngreenSquare.mass = 3;\n\n// The square you move around\nconst redSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\n\nredSquare.position.set(0, 0);\nredSquare.width = 100;\nredSquare.height = 100;\nredSquare.tint = 0xff0000;\nredSquare.acceleration = new PIXI.Point(0);\nredSquare.mass = 1;\n\nconst mouseCoords = { x: 0, y: 0 };\n\napp.stage.eventMode = 'static';\napp.stage.hitArea = app.screen;\napp.stage.on('mousemove', (event) =>\n{\n    mouseCoords.x = event.global.x;\n    mouseCoords.y = event.global.y;\n});\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // Applied deacceleration for both squares, done by reducing the\n    // acceleration by 0.01% of the acceleration every loop\n    redSquare.acceleration.set(redSquare.acceleration.x * 0.99, redSquare.acceleration.y * 0.99);\n    greenSquare.acceleration.set(greenSquare.acceleration.x * 0.99, greenSquare.acceleration.y * 0.99);\n\n    // Check whether the green square ever moves off the screen\n    // If so, reverse acceleration in that direction\n    if (greenSquare.x < 0 || greenSquare.x > app.screen.width - 100)\n    {\n        greenSquare.acceleration.x = -greenSquare.acceleration.x;\n    }\n\n    if (greenSquare.y < 0 || greenSquare.y > app.screen.height - 100)\n    {\n        greenSquare.acceleration.y = -greenSquare.acceleration.y;\n    }\n\n    // If the green square pops out of the cordon, it pops back into the\n    // middle\n    if (\n        greenSquare.x < -30\n        || greenSquare.x > app.screen.width + 30\n        || greenSquare.y < -30\n        || greenSquare.y > app.screen.height + 30\n    )\n    {\n        greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\n    }\n\n    // If the mouse is off screen, then don't update any further\n    if (app.screen.width > mouseCoords.x || mouseCoords.x > 0 || app.screen.height > mouseCoords.y || mouseCoords.y > 0)\n    {\n        // Get the red square's center point\n        const redSquareCenterPosition = new PIXI.Point(\n            redSquare.x + redSquare.width * 0.5,\n            redSquare.y + redSquare.height * 0.5,\n        );\n\n        // Calculate the direction vector between the mouse pointer and\n        // the red square\n        const toMouseDirection = new PIXI.Point(\n            mouseCoords.x - redSquareCenterPosition.x,\n            mouseCoords.y - redSquareCenterPosition.y,\n        );\n\n        // Use the above to figure out the angle that direction has\n        const angleToMouse = Math.atan2(toMouseDirection.y, toMouseDirection.x);\n\n        // Figure out the speed the square should be travelling by, as a\n        // function of how far away from the mouse pointer the red square is\n        const distMouseRedSquare = distanceBetweenTwoPoints(mouseCoords, redSquareCenterPosition);\n        const redSpeed = distMouseRedSquare * movementSpeed;\n\n        // Calculate the acceleration of the red square\n        redSquare.acceleration.set(Math.cos(angleToMouse) * redSpeed, Math.sin(angleToMouse) * redSpeed);\n    }\n\n    // If the two squares are colliding\n    if (testForAABB(greenSquare, redSquare))\n    {\n        // Calculate the changes in acceleration that should be made between\n        // each square as a result of the collision\n        const collisionPush = collisionResponse(greenSquare, redSquare);\n        // Set the changes in acceleration for both squares\n\n        redSquare.acceleration.set(collisionPush.x * greenSquare.mass, collisionPush.y * greenSquare.mass);\n        greenSquare.acceleration.set(-(collisionPush.x * redSquare.mass), -(collisionPush.y * redSquare.mass));\n    }\n\n    greenSquare.x += greenSquare.acceleration.x * delta;\n    greenSquare.y += greenSquare.acceleration.y * delta;\n\n    redSquare.x += redSquare.acceleration.x * delta;\n    redSquare.y += redSquare.acceleration.y * delta;\n});\n\n// Add to stage\napp.stage.addChild(redSquare, greenSquare);\n"},dependencies:{"pixi.js":i.npm}})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},99883:function(e){e.exports=JSON.parse('{"versionLabel":"v7.x","version":"7.4.2","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.4.2","build":"https://pixijs.download/v7.4.2/pixi.min.js","docs":"https://pixijs.download/v7.4.2/docs/index.html","npm":"7.4.2","prerelease":false,"latest":false}')}}]);