"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["5380"],{75269:function(n,e,o){o.r(e),o.d(e,{frontMatter:()=>s,default:()=>u,toc:()=>m,metadata:()=>t,assets:()=>l,contentTitle:()=>c});var t=JSON.parse('{"id":"examples/mesh-and-shaders/shader-toy-mesh","title":"Shader Toy Mesh","description":"<ExampleEditor","source":"@site/docs/examples/mesh-and-shaders/shader-toy-mesh.mdx","sourceDirName":"examples/mesh-and-shaders","slug":"/examples/mesh-and-shaders/shader-toy-mesh","permalink":"/8.x/examples/mesh-and-shaders/shader-toy-mesh","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":9,"custom_edit_url":null,"title":"Shader Toy Mesh"},"sidebar":"examplesSidebar","previous":{"title":"Instanced Geometry","permalink":"/8.x/examples/mesh-and-shaders/instanced-geometry"},"next":{"title":"Multipass Mesh","permalink":"/8.x/examples/mesh-and-shaders/multipass-mesh"}}'),a=o(85893),r=o(50065),i=o(31531);let s={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:9,custom_edit_url:null,title:"Shader Toy Mesh"},c=void 0,l={},m=[];function d(n){return(0,a.jsx)(i.N,{files:{"index.js":"import { Application, Geometry, Mesh, Shader } from 'pixi.js';\nimport fragment from './shaderToy.frag';\nimport vertex from './shaderToy.vert';\n\n(async () => {\n  // Create a new application\n  const app = new Application();\n\n  // Initialize the application\n  await app.init({\n    resizeTo: window,\n    preference: 'webgl',\n  });\n\n  // Append the application canvas to the document body\n  document.body.appendChild(app.canvas);\n\n  const quadGeometry = new Geometry({\n    attributes: {\n      aPosition: [\n        -100,\n        -100, // x, y\n        100,\n        -100, // x, y\n        100,\n        100, // x, y,\n        -100,\n        100, // x, y,\n      ],\n      aUV: [0, 0, 1, 0, 1, 1, 0, 1],\n    },\n    indexBuffer: [0, 1, 2, 0, 2, 3],\n  });\n\n  const shader = Shader.from({\n    gl: {\n      vertex,\n      fragment,\n    },\n    resources: {\n      shaderToyUniforms: {\n        iResolution: { value: [640, 360, 1], type: 'vec3<f32>' },\n        iTime: { value: 0, type: 'f32' },\n      },\n    },\n  });\n\n  const quad = new Mesh({\n    geometry: quadGeometry,\n    shader,\n  });\n\n  quad.width = app.screen.width;\n  quad.height = app.screen.height;\n  quad.x = app.screen.width / 2;\n  quad.y = app.screen.height / 2;\n\n  app.stage.addChild(quad);\n\n  app.ticker.add(() => {\n    shader.resources.shaderToyUniforms.uniforms.iTime += app.ticker.elapsedMS / 1000;\n  });\n})();\n","shaderToy.vert":"// code copied from here https://www.shadertoy.com/view/XcS3zK Created by liamegan\n#version 300 es\nin vec2 aPosition;\n\nuniform mat3 uProjectionMatrix;\nuniform mat3 uWorldTransformMatrix;\n\nuniform mat3 uTransformMatrix;\n\nvoid main() {\n\n    mat3 mvp = uProjectionMatrix * uWorldTransformMatrix * uTransformMatrix;\n    gl_Position = vec4((mvp * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n}","shaderToy.frag":"// code copied from here https://www.shadertoy.com/view/XcS3zK Created by liamegan\n#version 300 es\n#define HW_PERFORMANCE 1\nuniform vec3      iResolution;\nuniform float     iTime;\nuniform float     iChannelTime[4];\nuniform vec4      iMouse;\nuniform vec4      iDate;\nuniform float     iSampleRate;\nuniform vec3      iChannelResolution[4];\nuniform int       iFrame;\nuniform float     iTimeDelta;\nuniform float     iFrameRate;\nuniform sampler2D iChannel0;\nuniform struct {\nsampler2D sampler;\nvec3  size;\nfloat time;\nint   loaded;\n}\niCh0;\nuniform sampler2D iChannel1;\nuniform struct {\nsampler2D sampler;\nvec3  size;\nfloat time;\nint   loaded;\n}\niCh1;\nuniform sampler2D iChannel2;\nuniform struct {\nsampler2D sampler;\nvec3  size;\nfloat time;\nint   loaded;\n}\niCh2;\nuniform sampler2D iChannel3;\nuniform struct {\nsampler2D sampler;\nvec3  size;\nfloat time;\nint   loaded;\n}\niCh3;\nvoid mainImage( out vec4 c, in vec2 f );\nvoid st_assert( bool cond );\nvoid st_assert( bool cond, int v );\nout vec4 shadertoy_out_color;\nvoid st_assert( bool cond, int v ) {\nif(!cond) {\nif(v == 0)shadertoy_out_color.x = -1.0;\nelse if(v == 1)shadertoy_out_color.y = -1.0;\nelse if(v == 2)shadertoy_out_color.z = -1.0;\nelse shadertoy_out_color.w = -1.0;\n}\n\n}\nvoid st_assert( bool cond        ) {\nif(!cond)shadertoy_out_color.x = -1.0;\n}\nvoid main( void ) {\nshadertoy_out_color = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 color = vec4(1e20);\nmainImage( color, gl_FragCoord.xy );\nif(shadertoy_out_color.x<0.0) color = vec4(1.0, 0.0, 0.0, 1.0);\nif(shadertoy_out_color.y<0.0) color = vec4(0.0, 1.0, 0.0, 1.0);\nif(shadertoy_out_color.z<0.0) color = vec4(0.0, 0.0, 1.0, 1.0);\nif(shadertoy_out_color.w<0.0) color = vec4(1.0, 1.0, 0.0, 1.0);\nshadertoy_out_color = vec4(color.xyz, 1.0);\n}\n/* Shading constants */\n/* --------------------- */\nconst vec3 LP = vec3(-0.6, 0.7, -0.3);  // light position\n\nconst vec3 LC = vec3(.85, 0.80, 0.70);    // light colour\n\nconst vec3 HC1 = vec3(.5, .4, .3);      // hemisphere light colour 1\n\nconst vec3 HC2 = vec3(0.1, .1, .6)*.5;    // hemisphere light colour 2\n\nconst vec3 HLD = vec3(0, 1, 0);           // hemisphere light direction\n\nconst vec3 BC = vec3(0.25, 0.25, 0.25);   // back light colour\n\nconst vec3 FC = vec3(1.30, 1.20, 1.00);   // fresnel colour\n\nconst float AS = .5;                    // ambient light strength\n\nconst float DS = 1.;                    // diffuse light strength\n\nconst float BS = .3;                    // back light strength\n\nconst float FS = .3;                    // fresnel strength\n\n/* Raymarching constants */\n/* --------------------- */\nconst float MAX_TRACE_DISTANCE = 10.;             // max trace distance\n\nconst float INTERSECTION_PRECISION = 0.0001;       // precision of the intersection\n\nconst int NUM_OF_TRACE_STEPS = 64;               // max number of trace steps\n\nconst float STEP_MULTIPLIER = 1.;                 // the step mutliplier - ie, how much further to progress on each step\n\n\n/* Structures */\n/* ---------- */\nstruct Camera {\nvec3 ro;\nvec3 rd;\nvec3 forward;\nvec3 right;\nvec3 up;\nfloat FOV;\n};\nstruct Surface {\nfloat len;\nvec3 position;\nvec3 colour;\nfloat id;\nfloat steps;\nfloat AO;\n};\nstruct Model {\nfloat dist;\nvec3 colour;\nfloat id;\n};\n/* Utilities */\n/* ---------- */\nvec2 toScreenspace(in vec2 p) {\nvec2 uv = (p - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\nreturn uv;\n}\nmat2 R(float a) {\nfloat c = cos(a);\nfloat s = sin(a);\nreturn mat2(c, -s, s, c);\n}\nCamera getCamera(in vec2 uv, in vec3 pos, in vec3 target) {\nvec3 f = normalize(target - pos);\nvec3 r = normalize(vec3(f.z, 0., -f.x));\nvec3 u = normalize(cross(f, r));\nfloat FOV = 1.+cos(iTime*.1)*.8;\nreturn Camera(\npos, normalize(f + FOV * uv.x * r + FOV * uv.y * u), f, r, u, FOV\n);\n}\n//--------------------------------\n// Modelling\n//--------------------------------\nfloat G( vec3 p ) {\nreturn dot(sin(p.yzx), cos(p.zxy));\n}\nModel model(vec3 p) {\nfloat t = iTime*.1;\np.xz *= R(t);\np.xy *= R(.3);\np.xy -= .5;\nfloat d = abs(-(length(vec2(p.y, length(p.xz)-2.))-1.8+cos(t)*.3));\n\n// x variability\n\n//float gs = 3.+p.x;\n//float g = G(p.yxz*gs)/max(4., gs);\n// mixing on the y\n//float g = mix(g, abs(g)-.4, cos(p.y*2.));\n// regular\nfloat g = G(p.yxz*4.)/4.;\nd = length(vec2(d, g))-.3;\nvec3 colour = vec3(g);\nreturn Model(d, colour, 1.);\n}\nModel map( vec3 p ) {\nreturn model(p);\n}\n/* Modelling utilities */\n/* ---------- */\n// I *think* I borrowed this from Shane, but probably orginally comes from IQ. \n// Calculates the normal by taking a very small distance, // remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ) {\nvec3 eps = vec3( 0.001, 0.0, 0.0 );\nvec3 nor = vec3(\nmap(pos+eps.xyy).dist - map(pos-eps.xyy).dist, map(pos+eps.yxy).dist - map(pos-eps.yxy).dist, map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\nreturn normalize(nor);\n}\n//--------------------------------\n// Raymarcher\n//--------------------------------\nSurface march( in Camera cam ) {\nfloat h = 1e4; // local distance\n\nfloat d = 0.; // ray depth\n\nfloat id = -1.; // surace id\n\nfloat s = 0.; // number of steps\n\nfloat ao = 0.; // march space AO. Simple weighted accumulator. Not really AO, but \xaf\\_(\u30C4)_/\xaf\n\nvec3 p; // ray position\n\nvec3 c; // surface colour\n\n\nfor( int i = 0; i< NUM_OF_TRACE_STEPS ; i++ ) {\nif( abs(h) < INTERSECTION_PRECISION || d > MAX_TRACE_DISTANCE ) break;\np = cam.ro+cam.rd*d;\nModel m = map( p );\nh = m.dist;\nd += h * STEP_MULTIPLIER;\nid = m.id;\ns += 1.;\nao += max(h, 0.);\nc = m.colour;\n}\nif( d >= MAX_TRACE_DISTANCE ) id = -1.0;\nreturn Surface( d, p, c, id, s, ao );\n}\n//--------------------------------\n// Shading\n//--------------------------------\n/*\n* Soft shadows and AO curtesy of Inigo Quilez\n* https://iquilezles.org/articles/rmshadows\n*/\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\nfloat res = 1.0;\nfloat t = mint;\nfor( int i = 0; i<16; i++ ) {\nfloat h = map( ro + rd*t ).dist;\nres = min( res, 8.0*h/t );\nt += clamp( h, 0.02, 0.10 );\nif( h<0.001 || t>tmax ) break;\n}\nreturn clamp( res, 0.0, 1.0 );\n}\nfloat AO( in vec3 pos, in vec3 nor ) {\nfloat occ = 0.0;\nfloat sca = 1.0;\nfor( int i = 0; i<5; i++ ) {\nfloat hr = 0.01 + 0.12*float(i)/4.0;\nvec3 aopos = nor * hr + pos;\nfloat dd = map( aopos ).dist;\nocc += -(dd-hr)*sca;\nsca *= 0.95;\n}\nreturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\nvec3 shade(vec3 col, vec3 pos, vec3 nor, vec3 ref, Camera cam) {\nvec3 plp = LP - pos; // point light\n\n\nfloat o = AO( pos, nor );                 // Ambient occlusion\n\nvec3  l = normalize( plp );                    // light direction\n\n\nfloat d = clamp( dot( nor, l ), 0.0, 1.0 )*DS;   // diffuse component\n\nfloat b = clamp( dot( nor, normalize(vec3(-l.x, 0, -l.z))), 0.0, 1.0 )*clamp( 1.0-pos.y, 0.0, 1.0)*BS; // back light component\n\nfloat f = pow( clamp(1.0+dot(nor, cam.rd), 0.0, 1.0), 2.0 )*FS; // fresnel component\n\n\nvec3 c = vec3(0.0);\nc += d*LC;                           // diffuse light integration\n\nc += mix(HC1, HC2, dot(nor, HLD))*AS;        // hemisphere light integration (ambient)\n\nc += b*BC*o;       // back light integration\n\nc += f*FC*o;       // fresnel integration\n\n\nreturn col*c;\n}\nvec3 render(Surface surface, Camera cam, vec2 uv) {\nvec3 colour = vec3(.04, .045, .05);\ncolour = vec3(.35, .5, .75);\nvec3 colourB = vec3(.9, .85, .8);\ncolour = mix(colourB, colour, pow(length(uv), 2.)/1.5);\nif (surface.id > -1.) {\nvec3 surfaceNormal = calcNormal( surface.position );\nvec3 ref = reflect(cam.rd, surfaceNormal);\ncolour = surfaceNormal;\nvec3 pos = surface.position;\nfloat t = iTime;\nvec3 col = mix(\nmix(\nvec3(.8, .3, .6), vec3(.6, .3, .8), dot(surfaceNormal, surfaceNormal.zxy)\n), vec3(1), smoothstep(0., .1, cos(surface.colour.r*40.))\n);\ncolour = shade(col, pos, surfaceNormal, ref, cam);\n}\nreturn colour;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec3 c = vec3(0);\nfor(int x = 0; x<2; x++) {\nfor(int y = 0; y<2; y++) {\nvec2 uv = toScreenspace(fragCoord+vec2(x, y)*.5);\nCamera cam = getCamera(uv, vec3(1.5, 0, 1.5), vec3(0));\nSurface surface = march(cam);\nc += render(surface, cam, uv);\n}\n\n}\nfragColor = vec4(c*.25, 1);\n}\n#define Kpre86x"}})}function u(n={}){let{wrapper:e}={...(0,r.a)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},31531:function(n,e,o){o.d(e,{N:()=>i});var t=o(958),a=o(18146),r=o(85893);function i(n){return(0,a.J)("example",!0),(0,r.jsx)(t.M,{height:"calc(100vh - 325px)",fontSize:14,...n})}}}]);