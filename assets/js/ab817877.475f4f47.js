"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["6225"],{84118:function(e,s,n){n.r(s),n.d(s,{frontMatter:()=>o,default:()=>h,toc:()=>r,metadata:()=>t,assets:()=>d,contentTitle:()=>l});var t=JSON.parse('{"id":"guides/components/assets","title":"Assets","description":"The Assets package","source":"@site/versioned_docs/version-7.x/guides/components/assets.md","sourceDirName":"guides/components","slug":"/guides/components/assets","permalink":"/7.x/guides/components/assets","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/pixijs.com/tree/main/versioned_docs/version-7.x/guides/components/assets.md","tags":[],"version":"7.x","frontMatter":{},"sidebar":"guidesSidebar","previous":{"title":"Scene Graph","permalink":"/7.x/guides/basics/scene-graph"},"next":{"title":"Containers","permalink":"/7.x/guides/components/containers"}}'),i=n(85893),a=n(50065);let o={},l="Assets",d={},r=[{value:"The Assets package",id:"the-assets-package",level:2},{value:"Getting started",id:"getting-started",level:2},{value:"Making our first Assets Promise",id:"making-our-first-assets-promise",level:2},{value:"Warning about solved promises",id:"warning-about-solved-promises",level:2},{value:"Using Async/Await",id:"using-asyncawait",level:2},{value:"Loading multiple assets",id:"loading-multiple-assets",level:2},{value:"Background loading",id:"background-loading",level:2}];function c(e){let s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"assets",children:"Assets"})}),"\n",(0,i.jsx)(s.h2,{id:"the-assets-package",children:"The Assets package"}),"\n",(0,i.jsxs)(s.p,{children:["The Assets package is a modern replacement for the old ",(0,i.jsx)(s.code,{children:"PIXI.Loader"})," class. It is a promise-based resource management solution that will download, cache and parse your assets into something you can use. The downloads can be simultaneous and in the background, meaning faster startup times for your app, the cache ensures that you never download the same asset twice and the extensible parser system allows you to easily extend and customize the process to your needs."]}),"\n",(0,i.jsx)(s.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"@pixi/assets"})," package doesn't come bundled with PixiJS in version 6.x and must be added externally, however it will become integrated with version 7. The class that does all the heavy lifting is called ",(0,i.jsx)(s.code,{children:"AssetsClass"})," but you don't need to create your own instance since you will find one ready to use in ",(0,i.jsx)(s.code,{children:"PIXI.Assets"}),".\nThis package relies heavily on JavaScript Promises that all modern browsers support, however, if your target browser ",(0,i.jsx)(s.a,{href:"https://caniuse.com/promises",children:"doesn't support promises"})," you should look into ",(0,i.jsx)(s.a,{href:"https://github.com/zloirock/core-js#ecmascript-promise",children:"polyfilling them"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"making-our-first-assets-promise",children:"Making our first Assets Promise"}),"\n",(0,i.jsxs)(s.p,{children:["To quickly use the ",(0,i.jsx)(s.code,{children:"PIXI.Assets"})," instance, you just need to call ",(0,i.jsx)(s.code,{children:"PIXI.Assets.load"})," and pass in an asset. This will return a promise that when resolved will yield the value you seek.\nIn this example, we will load a texture and then turn it into a sprite."]}),"\n",(0,i.jsx)("div",{class:"responsive-4-3",children:(0,i.jsx)("iframe",{src:"https://pixijs.io/examples/?embed=1&showcode=1#/assets/promise.js"})}),"\n",(0,i.jsxs)(s.p,{children:["One very important thing to keep in mind while using ",(0,i.jsx)(s.code,{children:"Assets"})," is that all requests are cached and if the URL is the same, the promise returned will also be the same.\nTo show it in code:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"promise1 = PIXI.Assets.load('bunny.png');\npromise2 = PIXI.Assets.load('bunny.png');\n\n//promise1 === promise2\n"})}),"\n",(0,i.jsx)(s.p,{children:"Out of the box, the following assets types can be loaded without the need for external plugins:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Textures (",(0,i.jsx)(s.code,{children:"avif"}),", ",(0,i.jsx)(s.code,{children:"webp"}),", ",(0,i.jsx)(s.code,{children:"png"}),", ",(0,i.jsx)(s.code,{children:"jpg"}),", ",(0,i.jsx)(s.code,{children:"gif"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Sprite sheets (",(0,i.jsx)(s.code,{children:"json"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Bitmap fonts (",(0,i.jsx)(s.code,{children:"xml"}),", ",(0,i.jsx)(s.code,{children:"fnt"}),", ",(0,i.jsx)(s.code,{children:"txt"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Web fonts (",(0,i.jsx)(s.code,{children:"ttf"}),", ",(0,i.jsx)(s.code,{children:"woff"}),", ",(0,i.jsx)(s.code,{children:"woff2"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Json files (",(0,i.jsx)(s.code,{children:"json"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Text files (",(0,i.jsx)(s.code,{children:"txt"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"More types can be added fairly easily by creating additional loader parsers."}),"\n",(0,i.jsx)(s.h2,{id:"warning-about-solved-promises",children:"Warning about solved promises"}),"\n",(0,i.jsxs)(s.p,{children:["When an asset is downloaded, it is cached as a promise inside the ",(0,i.jsx)(s.code,{children:"Assets"})," instance and if you try to download it again you will get a reference to the already resolved promise.\nHowever promise handlers ",(0,i.jsx)(s.code,{children:".then(...)"}),"/",(0,i.jsx)(s.code,{children:".catch(...)"}),"/",(0,i.jsx)(s.code,{children:".finally(...)"})," are always asynchronous, this means that even if a promise was already resolved the code below the ",(0,i.jsx)(s.code,{children:".then(...)"}),"/",(0,i.jsx)(s.code,{children:".catch(...)"}),"/",(0,i.jsx)(s.code,{children:".finally(...)"})," will execute before the code inside them.\nSee this example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"console.log(1);\nalreadyResolvedPromise.then(() => console.log(2));\nconsole.log(3);\n\n// Console output:\n// 1\n// 3\n// 2\n"})}),"\n",(0,i.jsxs)(s.p,{children:["To learn more about why this happens you will need to learn about ",(0,i.jsx)(s.a,{href:"https://javascript.info/microtask-queue",children:"Microtasks"}),", however, using async functions should mitigate this problem."]}),"\n",(0,i.jsx)(s.h2,{id:"using-asyncawait",children:"Using Async/Await"}),"\n",(0,i.jsxs)(s.p,{children:["There is a way to work with promises that is more intuitive and easier to read: ",(0,i.jsx)(s.code,{children:"async"}),"/",(0,i.jsx)(s.code,{children:"await"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["To use it we first need to create a function/method and mark it as ",(0,i.jsx)(s.code,{children:"async"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"async function test() {\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(s.p,{children:["This function now wraps the return value in a promise and allows us to use the ",(0,i.jsx)(s.code,{children:"await"})," keyword before a promise to halt the execution of the code until it is resolved and gives us the value."]}),"\n",(0,i.jsx)(s.p,{children:"See this example:"}),"\n",(0,i.jsx)("div",{class:"responsive-4-3",children:(0,i.jsx)("iframe",{src:"https://pixijs.io/examples/?embed=1&showcode=1#/assets/async.js"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"texture"})," variable now is not a promise but the resolved texture that resulted after waiting for this promise to resolve."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"const texture = await PIXI.Assets.load('examples/assets/bunny.png');\n"})}),"\n",(0,i.jsx)(s.p,{children:"This allows us to write more readable code without falling into callback hell and to better think when our program halts and yields."}),"\n",(0,i.jsx)(s.h2,{id:"loading-multiple-assets",children:"Loading multiple assets"}),"\n",(0,i.jsxs)(s.p,{children:["We can add assets to the cache and then load them all simultaneously by using ",(0,i.jsx)(s.code,{children:"PIXI.Assets.add(...)"})," and then calling ",(0,i.jsx)(s.code,{children:"PIXI.Assets.load(...)"})," with all the keys you want to have loaded.\nSee the following example:"]}),"\n",(0,i.jsx)("div",{class:"responsive-4-3",children:(0,i.jsx)("iframe",{src:"https://pixijs.io/examples/?embed=1&showcode=1#/assets/multiple.js"})}),"\n",(0,i.jsxs)(s.p,{children:["However, if you want to take full advantage of ",(0,i.jsx)(s.code,{children:"@pixi/Assets"})," you should use bundles.\nBundles are just a way to group assets together and can be added manually by calling ",(0,i.jsx)(s.code,{children:"PIXI.Assets.addBundle(...)"}),"/",(0,i.jsx)(s.code,{children:"PIXI.Assets.loadBundle(...)"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"PIXI.Assets.addBundle('animals', {\n  bunny: 'bunny.png',\n  chicken: 'chicken.png',\n  thumper: 'thumper.png',\n});\n\nconst assets = await PIXI.Assets.loadBundle('animals');\n"})}),"\n",(0,i.jsxs)(s.p,{children:["However, the best way to handle bundles is to use a manifest and call ",(0,i.jsx)(s.code,{children:"PIXI.Assets.init({manifest})"})," with said manifest (or even better, an URL pointing to it).\nSplitting our assets into bundles that correspond to screens or stages of our app will come in handy for loading in the background while the user is using the app instead of locking them in a single monolithic loading screen."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-json",children:'{\n  "bundles": [\n    {\n      "name": "load-screen",\n      "assets": [\n        {\n          "name": "background",\n          "srcs": "sunset.png"\n        },\n        {\n          "name": "bar",\n          "srcs": "load-bar.{png,webp}"\n        }\n      ]\n    },\n    {\n      "name": "game-screen",\n      "assets": [\n        {\n          "name": "character",\n          "srcs": "robot.png"\n        },\n        {\n          "name": "enemy",\n          "srcs": "bad-guy.png"\n        }\n      ]\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"PIXI.Assets.init({ manifest: 'path/manifest.json' });\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Beware that ",(0,i.jsxs)(s.strong,{children:["you can only call ",(0,i.jsx)(s.code,{children:"init"})," once"]}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Remember there is no downside in repeating URLs since they will all be cached, so if you need the same asset in two bundles you can duplicate the request without any extra cost!"}),"\n",(0,i.jsx)(s.h2,{id:"background-loading",children:"Background loading"}),"\n",(0,i.jsxs)(s.p,{children:["The old approach to loading was to use ",(0,i.jsx)(s.code,{children:"PIXI.Loader"})," to load all your assets at the beginning of your app, but users are less patient now and want content to be instantly available so the practices are moving towards loading the bare minimum needed to show the user some content and, while they are interacting with that, we keep loading the following content in the background."]}),"\n",(0,i.jsxs)(s.p,{children:["Luckily, ",(0,i.jsx)(s.code,{children:"@pixi/assets"})," has us covered with a system that allows us to load everything in the background and in case we need some assets right now, bump them to the top of the queue so we can minimize loading times."]}),"\n",(0,i.jsxs)(s.p,{children:["To achieve this, we have the methods ",(0,i.jsx)(s.code,{children:"PIXI.Assets.backgroundLoad(...)"})," and ",(0,i.jsx)(s.code,{children:"PIXI.Assets.backgroundLoadBundle(...)"})," that will passively begin to load these assets in the background. So when you finally come to loading them you will get a promise that resolves to the loaded assets immediately."]}),"\n",(0,i.jsxs)(s.p,{children:["When you finally need the assets to show, you call the usual ",(0,i.jsx)(s.code,{children:"PIXI.Assets.load(...)"})," or ",(0,i.jsx)(s.code,{children:"PIXI.Assets.loadBundle(...)"})," and you will get the corresponding promise."]}),"\n",(0,i.jsx)(s.p,{children:"The best way to do this is using bundles, see the following example:"}),"\n",(0,i.jsx)("div",{class:"responsive-4-3",children:(0,i.jsx)("iframe",{src:"https://pixijs.io/examples/?embed=1&showcode=1#/assets/bundle.js"})}),"\n",(0,i.jsx)(s.p,{children:"We create one bundle for each screen our game will have and set them all to start downloading at the beginning of our app. If the user progresses slowly enough in our app then they should never get to see a loading screen after the first one!"})]})}function h(e={}){let{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},50065:function(e,s,n){n.d(s,{Z:()=>l,a:()=>o});var t=n(67294);let i={},a=t.createContext(i);function o(e){let s=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);