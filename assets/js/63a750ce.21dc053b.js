"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[3997],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return t?r.createElement(h,s(s({ref:n},c),{},{components:t})):r.createElement(h,s({ref:n},c))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[d]="string"==typeof e?e:o,s[1]=i;for(var p=2;p<a;p++)s[p]=t[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},65013:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var r=t(87462),o=(t(67294),t(3905));const a={hide_table_of_contents:!0},s="Slots",i={unversionedId:"examples/advanced/slots",id:"examples/advanced/slots",title:"Slots",description:"",source:"@site/docs/examples/advanced/slots.md",sourceDirName:"examples/advanced",slug:"/examples/advanced/slots",permalink:"/examples/advanced/slots",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/docs/examples/advanced/slots.md",tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"examplesSidebar",previous:{title:"Screenshot",permalink:"/examples/advanced/screenshot"},next:{title:"Spinners",permalink:"/examples/advanced/spinners"}},l={},p=[],c={toc:p};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"slots"},"Slots"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:"playground",playground:!0},"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application<HTMLCanvasElement>({ background: '#1099bb', resizeTo: window });\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load([\n    'https://beta.pixijs.com/assets/eggHead.png',\n    'https://beta.pixijs.com/assets/flowerTop.png',\n    'https://beta.pixijs.com/assets/helmlok.png',\n    'https://beta.pixijs.com/assets/skully.png',\n]).then(onAssetsLoaded);\n\nconst REEL_WIDTH = 160;\nconst SYMBOL_SIZE = 150;\n\n// onAssetsLoaded handler builds the example.\nfunction onAssetsLoaded() {\n    // Create different slot symbols.\n    const slotTextures = [\n        PIXI.Texture.from('https://beta.pixijs.com/assets/eggHead.png'),\n        PIXI.Texture.from('https://beta.pixijs.com/assets/flowerTop.png'),\n        PIXI.Texture.from('https://beta.pixijs.com/assets/helmlok.png'),\n        PIXI.Texture.from('https://beta.pixijs.com/assets/skully.png'),\n    ];\n\n    // Build the reels\n    const reels = [];\n    const reelContainer = new PIXI.Container();\n    for (let i = 0; i < 5; i++) {\n        const rc = new PIXI.Container();\n        rc.x = i * REEL_WIDTH;\n        reelContainer.addChild(rc);\n\n        const reel = {\n            container: rc,\n            symbols: [],\n            position: 0,\n            previousPosition: 0,\n            blur: new PIXI.filters.BlurFilter(),\n        };\n        reel.blur.blurX = 0;\n        reel.blur.blurY = 0;\n        rc.filters = [reel.blur];\n\n        // Build the symbols\n        for (let j = 0; j < 4; j++) {\n            const symbol = new PIXI.Sprite(slotTextures[Math.floor(Math.random() * slotTextures.length)]);\n            // Scale the symbol to fit symbol area.\n            symbol.y = j * SYMBOL_SIZE;\n            symbol.scale.x = symbol.scale.y = Math.min(SYMBOL_SIZE / symbol.width, SYMBOL_SIZE / symbol.height);\n            symbol.x = Math.round((SYMBOL_SIZE - symbol.width) / 2);\n            reel.symbols.push(symbol);\n            rc.addChild(symbol);\n        }\n        reels.push(reel);\n    }\n    app.stage.addChild(reelContainer);\n\n    // Build top & bottom covers and position reelContainer\n    const margin = (app.screen.height - SYMBOL_SIZE * 3) / 2;\n    reelContainer.y = margin;\n    reelContainer.x = Math.round(app.screen.width - REEL_WIDTH * 5);\n    const top = new PIXI.Graphics();\n    top.beginFill(0, 1);\n    top.drawRect(0, 0, app.screen.width, margin);\n    const bottom = new PIXI.Graphics();\n    bottom.beginFill(0, 1);\n    bottom.drawRect(0, SYMBOL_SIZE * 3 + margin, app.screen.width, margin);\n\n    // Add play text\n    const style = new PIXI.TextStyle({\n        fontFamily: 'Arial',\n        fontSize: 36,\n        fontStyle: 'italic',\n        fontWeight: 'bold',\n        fill: ['#ffffff', '#00ff99'], // gradient\n        stroke: '#4a1850',\n        strokeThickness: 5,\n        dropShadow: true,\n        dropShadowColor: '#000000',\n        dropShadowBlur: 4,\n        dropShadowAngle: Math.PI / 6,\n        dropShadowDistance: 6,\n        wordWrap: true,\n        wordWrapWidth: 440,\n    });\n\n    const playText = new PIXI.Text('Spin the wheels!', style);\n    playText.x = Math.round((bottom.width - playText.width) / 2);\n    playText.y = app.screen.height - margin + Math.round((margin - playText.height) / 2);\n    bottom.addChild(playText);\n\n    // Add header text\n    const headerText = new PIXI.Text('PIXI MONSTER SLOTS!', style);\n    headerText.x = Math.round((top.width - headerText.width) / 2);\n    headerText.y = Math.round((margin - headerText.height) / 2);\n    top.addChild(headerText);\n\n    app.stage.addChild(top);\n    app.stage.addChild(bottom);\n\n    // Set the interactivity.\n    bottom.interactive = true;\n    bottom.cursor = 'pointer';\n    bottom.addListener('pointerdown', () => {\n        startPlay();\n    });\n\n    let running = false;\n\n    // Function to start playing.\n    function startPlay() {\n        if (running) return;\n        running = true;\n\n        for (let i = 0; i < reels.length; i++) {\n            const r = reels[i];\n            const extra = Math.floor(Math.random() * 3);\n            const target = r.position + 10 + i * 5 + extra;\n            const time = 2500 + i * 600 + extra * 600;\n            tweenTo(r, 'position', target, time, backout(0.5), null, i === reels.length - 1 ? reelsComplete : null);\n        }\n    }\n\n    // Reels done handler.\n    function reelsComplete() {\n        running = false;\n    }\n\n    // Listen for animate update.\n    app.ticker.add((delta) => {\n    // Update the slots.\n        for (let i = 0; i < reels.length; i++) {\n            const r = reels[i];\n            // Update blur filter y amount based on speed.\n            // This would be better if calculated with time in mind also. Now blur depends on frame rate.\n            r.blur.blurY = (r.position - r.previousPosition) * 8;\n            r.previousPosition = r.position;\n\n            // Update symbol positions on reel.\n            for (let j = 0; j < r.symbols.length; j++) {\n                const s = r.symbols[j];\n                const prevy = s.y;\n                s.y = ((r.position + j) % r.symbols.length) * SYMBOL_SIZE - SYMBOL_SIZE;\n                if (s.y < 0 && prevy > SYMBOL_SIZE) {\n                    // Detect going over and swap a texture.\n                    // This should in proper product be determined from some logical reel.\n                    s.texture = slotTextures[Math.floor(Math.random() * slotTextures.length)];\n                    s.scale.x = s.scale.y = Math.min(SYMBOL_SIZE / s.texture.width, SYMBOL_SIZE / s.texture.height);\n                    s.x = Math.round((SYMBOL_SIZE - s.width) / 2);\n                }\n            }\n        }\n    });\n}\n\n// Very simple tweening utility function. This should be replaced with a proper tweening library in a real product.\nconst tweening = [];\nfunction tweenTo(object, property, target, time, easing, onchange, oncomplete) {\n    const tween = {\n        object,\n        property,\n        propertyBeginValue: object[property],\n        target,\n        easing,\n        time,\n        change: onchange,\n        complete: oncomplete,\n        start: Date.now(),\n    };\n\n    tweening.push(tween);\n    return tween;\n}\n// Listen for animate update.\napp.ticker.add((delta) => {\n    const now = Date.now();\n    const remove = [];\n    for (let i = 0; i < tweening.length; i++) {\n        const t = tweening[i];\n        const phase = Math.min(1, (now - t.start) / t.time);\n\n        t.object[t.property] = lerp(t.propertyBeginValue, t.target, t.easing(phase));\n        if (t.change) t.change(t);\n        if (phase === 1) {\n            t.object[t.property] = t.target;\n            if (t.complete) t.complete(t);\n            remove.push(t);\n        }\n    }\n    for (let i = 0; i < remove.length; i++) {\n        tweening.splice(tweening.indexOf(remove[i]), 1);\n    }\n});\n\n// Basic lerp funtion.\nfunction lerp(a1, a2, t) {\n    return a1 * (1 - t) + a2 * t;\n}\n\n// Backout function from tweenjs.\n// https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js\nfunction backout(amount) {\n    return (t) => (--t * t * ((amount + 1) * t + amount) + 1);\n}\n")))}d.isMDXComponent=!0}}]);