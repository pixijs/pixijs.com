"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[5791],{3472:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>n,metadata:()=>s,toc:()=>u});var i=a(7462),l=(a(7294),a(3905));const n={},r="Performance Tips",s={unversionedId:"guides/production/performance-tips",id:"version-7.x/guides/production/performance-tips",title:"Performance Tips",description:"General",source:"@site/versioned_docs/version-7.x/guides/production/performance-tips.md",sourceDirName:"guides/production",slug:"/guides/production/performance-tips",permalink:"/7.x/guides/production/performance-tips",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/versioned_docs/version-7.x/guides/production/performance-tips.md",tags:[],version:"7.x",frontMatter:{},sidebar:"guidesSidebar",previous:{title:"Textures",permalink:"/7.x/guides/components/textures"},next:{title:"Upgrading PixiJS",permalink:"/7.x/guides/migrations/upgrading"}},o={},u=[{value:"General",id:"general",level:3},{value:"Sprites",id:"sprites",level:3},{value:"Graphics",id:"graphics",level:3},{value:"Texture",id:"texture",level:3},{value:"Text",id:"text",level:3},{value:"Masks",id:"masks",level:3},{value:"Filters",id:"filters",level:3},{value:"BlendModes",id:"blendmodes",level:3},{value:"CacheAsBitmap",id:"cacheasbitmap",level:3},{value:"Events",id:"events",level:3}],p={toc:u};function d(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,i.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"performance-tips"},"Performance Tips"),(0,l.kt)("h3",{id:"general"},"General"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Only optimize when you need to! PixiJS can handle a fair amount of content off the bat"),(0,l.kt)("li",{parentName:"ul"},"Be mindful of the complexity of your scene. The more objects you add the slower things will end up"),(0,l.kt)("li",{parentName:"ul"},"Order can help, for example sprite / graphic / sprite / graphic is slower than sprite / sprite / graphic / graphic"),(0,l.kt)("li",{parentName:"ul"},"Some older mobile devices run things a little slower. Passing in the option ",(0,l.kt)("inlineCode",{parentName:"li"},"useContextAlpha: false")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"antialias: false")," to the Renderer or Application can help with performance"),(0,l.kt)("li",{parentName:"ul"},"Culling is disabled by default as it's often better to do this at an application level or set objects to be ",(0,l.kt)("inlineCode",{parentName:"li"},"cullable = true"),". If you are GPU-bound it will improve performance; if you are CPU-bound it will degrade performance")),(0,l.kt)("h3",{id:"sprites"},"Sprites"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Use Spritesheets where possible to minimize total textures"),(0,l.kt)("li",{parentName:"ul"},"Sprites can be batched with up to 16 different textures (dependent on hardware)"),(0,l.kt)("li",{parentName:"ul"},"This is the fastest way to render content"),(0,l.kt)("li",{parentName:"ul"},"On older devices use smaller low resolution textures"),(0,l.kt)("li",{parentName:"ul"},"Add the extention ",(0,l.kt)("inlineCode",{parentName:"li"},"@0.5x.png")," to the 50% scale-down spritesheet so PixiJS will visually-double them automatically"),(0,l.kt)("li",{parentName:"ul"},"Draw order can be important")),(0,l.kt)("h3",{id:"graphics"},"Graphics"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Graphics objects are fastest when they are not modified constantly (not including the transform, alpha or tint!)"),(0,l.kt)("li",{parentName:"ul"},"Graphics objects are batched when under a certain size (100 points or smaller)"),(0,l.kt)("li",{parentName:"ul"},"Small Graphics objects are as fast as Sprites (rectangles, triangles)"),(0,l.kt)("li",{parentName:"ul"},"Using 100s of graphics complex objects can be slow, in this instance use sprites (you can create a texture)")),(0,l.kt)("h3",{id:"texture"},"Texture"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Textures are automatically managed by a Texture Garbage Collector"),(0,l.kt)("li",{parentName:"ul"},"You can also manage them yourself by using ",(0,l.kt)("inlineCode",{parentName:"li"},"texture.destroy()")),(0,l.kt)("li",{parentName:"ul"},"If you plan to destroy more than one at once add a random delay to their destruction to remove freezing"),(0,l.kt)("li",{parentName:"ul"},"Delay texture destroy if you plan to delete a lot of textures yourself")),(0,l.kt)("h3",{id:"text"},"Text"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Avoid changing it on every frame as this can be expensive (each time it draws to a canvas and then uploads to GPU)"),(0,l.kt)("li",{parentName:"ul"},"Bitmap Text gives much better performance for dynamically changing text"),(0,l.kt)("li",{parentName:"ul"},"Text resolution matches the renderer resolution, decrease resolution yourself by setting the ",(0,l.kt)("inlineCode",{parentName:"li"},"resolution")," property, which can consume less memory")),(0,l.kt)("h3",{id:"masks"},"Masks"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Masks can be expensive if too many are used: e.g., 100s of masks will really slow things down"),(0,l.kt)("li",{parentName:"ul"},"Axis-aligned Rectangle masks are the fastest (as the use scissor rect)"),(0,l.kt)("li",{parentName:"ul"},"Graphics masks are second fastest (as they use the stencil buffer)"),(0,l.kt)("li",{parentName:"ul"},"Sprite masks are the third fastest (they uses filters). They are really expensive. Do not use too many in your scene!")),(0,l.kt)("h3",{id:"filters"},"Filters"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Release memory: ",(0,l.kt)("inlineCode",{parentName:"li"},"displayObject.filters = null")),(0,l.kt)("li",{parentName:"ul"},"If you know the size of them: ",(0,l.kt)("inlineCode",{parentName:"li"},"displayObject.filterArea = new PIXI.Rectangle(x,y,w,h)"),". This can speed things up as it means the object does not need to be measured"),(0,l.kt)("li",{parentName:"ul"},"Filters are expensive, using too many will start to slow things down!")),(0,l.kt)("h3",{id:"blendmodes"},"BlendModes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Different blend modes will cause batches to break (de-optimize)"),(0,l.kt)("li",{parentName:"ul"},"SceenSprite / NormalSprite / SceenSprite / NormalSprite would be 4 draw calls"),(0,l.kt)("li",{parentName:"ul"},"SceenSprite / SceenSprite / NormalSprite / NormalSprite would be 2 draw calls")),(0,l.kt)("h3",{id:"cacheasbitmap"},"CacheAsBitmap"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Setting to ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," turns an object into a Sprite by caching it as a Texture"),(0,l.kt)("li",{parentName:"ul"},"It has a one time cost when it is activated as it draws the object to a Texture"),(0,l.kt)("li",{parentName:"ul"},"Avoid changing this on elements frequently"),(0,l.kt)("li",{parentName:"ul"},"If you have a complicated item that has lots of sprites / filters AND does not move then this will speed up rendering!"),(0,l.kt)("li",{parentName:"ul"},"Do not need apply to sprites as they are already Textures"),(0,l.kt)("li",{parentName:"ul"},"Do not use if the object where its children are constantly changing as this will slow things down")),(0,l.kt)("h3",{id:"events"},"Events"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If an object has no interactive children use ",(0,l.kt)("inlineCode",{parentName:"li"},"interactiveChildren = false"),". The event system will then be able to avoid crawling through the object"),(0,l.kt)("li",{parentName:"ul"},"Setting ",(0,l.kt)("inlineCode",{parentName:"li"},"hitArea = new PIXI.Rectangle(x,y,w,h)")," as above should stop the event system from crawling through the object")))}d.isMDXComponent=!0}}]);