"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["1206"],{94438:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>d,default:()=>c,toc:()=>m,metadata:()=>r,assets:()=>p,contentTitle:()=>l});var r=JSON.parse('{"id":"examples/mesh-and-shaders/multi-pass-shader-generated-mesh","title":"Multi Pass Shader Generated Mesh","description":"","source":"@site/versioned_docs/version-7.x/examples/mesh-and-shaders/multi-pass-shader-generated-mesh.mdx","sourceDirName":"examples/mesh-and-shaders","slug":"/examples/mesh-and-shaders/multi-pass-shader-generated-mesh","permalink":"/7.x/examples/mesh-and-shaders/multi-pass-shader-generated-mesh","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"7.x","sidebarPosition":12,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":12,"custom_edit_url":null,"title":"Multi Pass Shader Generated Mesh"},"sidebar":"examplesSidebar","previous":{"title":"Shader Toy Mesh","permalink":"/7.x/examples/mesh-and-shaders/shader-toy-mesh"},"next":{"title":"Texture Rotate","permalink":"/7.x/examples/textures/texture-rotate"}}'),i=t(85893),a=t(50065),s=t(31531),o=t(99883);let d={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:12,custom_edit_url:null,title:"Multi Pass Shader Generated Mesh"},l=void 0,p={},m=[];function u(e){return(0,i.jsx)(s.N,{files:{"index.js":"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ height: 640, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Build geometry.\nconst geometry = new PIXI.Geometry()\n  .addAttribute(\n    'aVertexPosition', // the attribute name\n    [\n      0,\n      0, // x, y\n      200,\n      0, // x, y\n      200,\n      200,\n      0,\n      200,\n    ], // x, y\n    2,\n  ) // the size of the attribute\n  .addAttribute(\n    'aUvs', // the attribute name\n    [\n      0,\n      0, // u, v\n      1,\n      0, // u, v\n      1,\n      1,\n      0,\n      1,\n    ], // u, v\n    2,\n  ) // the size of the attribute\n  .addIndex([0, 1, 2, 0, 2, 3]);\n\n// Vertex shader. Use same shader for all passes.\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\n// Load a perlinnoise texture for one of the shaders.\nconst perlinTexture = PIXI.Texture.from('https://pixijs.com/assets/perlin.jpg');\n\n// First pass, generates a grid.\nconst fragmentGridSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float zoom;\n\nvoid main()\n{\n    //Generate a simple grid.\n    //Offset uv so that center is 0,0 and edges are -1,1\n    vec2 uv = (vUvs-vec2(0.5))*2.0;\n    vec2 gUv = floor(uv*zoom);\n    vec4 color1 = vec4(0.8, 0.8, 0.8, 1.0);\n    vec4 color2 = vec4(0.4, 0.4, 0.4, 1.0);\n    vec4 outColor = mod(gUv.x + gUv.y, 2.) < 0.5 ? color1 : color2;\n    gl_FragColor = outColor;\n\n}`;\n\nconst gridUniforms = {\n  zoom: 10,\n};\nconst gridShader = PIXI.Shader.from(vertexSrc, fragmentGridSrc, gridUniforms);\n// Sharing textures and meshes is possible.\n// But for simplicity each pass has its own output texture and mesh in this example.\nconst gridTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst gridQuad = new PIXI.Mesh(geometry, gridShader);\nconst gridContainer = new PIXI.Container();\n\ngridContainer.addChild(gridQuad);\n\n// Second pass. Takes grid as input and makes it ripple.\nconst fragmentRippleSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float amount;\nuniform float phase;\nuniform sampler2D texIn;\n\nvoid main()\n{\n    //Generate a simple grid.\n    vec2 uv = vUvs;\n    //Calculate distance from center\n    float distance = length( uv - vec2(0.5));\n    vec4 color = texture2D(texIn, uv);\n    color.rgb *= sin(distance*25.0+phase) * amount+1.;\n    gl_FragColor = color;\n}`;\nconst rippleUniforms = {\n  amount: 0.5,\n  phase: 0,\n  texIn: gridTexture,\n};\nconst rippleShader = PIXI.Shader.from(vertexSrc, fragmentRippleSrc, rippleUniforms);\nconst rippleTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst rippleQuad = new PIXI.Mesh(geometry, rippleShader);\nconst rippleContainer = new PIXI.Container();\n\nrippleContainer.addChild(rippleQuad);\n\n// Second effect. Generates a filtered noise.\nconst fragmentNoiseSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float limit;\nuniform sampler2D noise;\n\nvoid main()\n{\n    float color = texture2D(noise, vUvs).r;\n    color = step(limit, color);\n    gl_FragColor = vec4(color);\n}`;\nconst noiseUniforms = {\n  limit: 0.5,\n  noise: perlinTexture,\n};\nconst noiseShader = PIXI.Shader.from(vertexSrc, fragmentNoiseSrc, noiseUniforms);\nconst noiseTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst noiseQuad = new PIXI.Mesh(geometry, noiseShader);\nconst noiseContainer = new PIXI.Container();\n\nnoiseContainer.addChild(noiseQuad);\n\n// Third effect\nconst fragmentWaveSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float amplitude;\nuniform float time;\n\nvoid main()\n{\n    //Offset uv so that center is 0,0 and edges are -1,1\n    vec2 uv = (vUvs-vec2(0.5))*2.0;\n\n    vec3 outColor = vec3(0.);\n\n    //Simple wavefunctions inversed and with small offsets.\n    outColor += 5./length(uv.y*200. - 50.0*sin( uv.x*0.25+ time*0.25)*amplitude);\n    outColor += 4./length(uv.y*300. - 100.0*sin(uv.x*0.5+time*0.5)*amplitude*1.2);\n    outColor += 3./length(uv.y*400. - 150.0*sin(uv.x*0.75+time*0.75)*amplitude*1.4);\n    outColor += 2./length(uv.y*500. - 200.0*sin(uv.x+time)*amplitude*1.6);\n\n    gl_FragColor = vec4(outColor,1.0);\n}`;\nconst waveUniforms = {\n  amplitude: 0.75,\n  time: 0,\n};\nconst waveShader = PIXI.Shader.from(vertexSrc, fragmentWaveSrc, waveUniforms);\nconst waveTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst waveQuad = new PIXI.Mesh(geometry, waveShader);\nconst waveContainer = new PIXI.Container();\n\nwaveContainer.addChild(waveQuad);\n\n// Final combination pass\nconst fragmentCombineSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\n\nuniform sampler2D texRipple;\nuniform sampler2D texNoise;\nuniform sampler2D texWave;\n\nvoid main()\n{\n    //Read color from all\n    vec4 ripple = texture2D(texRipple, vUvs);\n    vec4 noise = texture2D(texNoise, vUvs);\n    vec4 wave = texture2D(texWave, vUvs);\n\n    gl_FragColor = mix(ripple, wave,noise.r);\n}`;\nconst combineUniforms = {\n  texRipple: rippleTexture,\n  texNoise: noiseTexture,\n  texWave: waveTexture,\n};\nconst combineShader = PIXI.Shader.from(vertexSrc, fragmentCombineSrc, combineUniforms);\nconst combineQuad = new PIXI.Mesh(geometry, combineShader);\n\ngridContainer.position.set(10, 10);\nrippleContainer.position.set(220, 10);\nnoiseContainer.position.set(10, 220);\nwaveContainer.position.set(10, 430);\ncombineQuad.position.set(430, 220);\n\n// Add all phases to stage so all the phases can be seen separately.\napp.stage.addChild(gridContainer);\napp.stage.addChild(rippleContainer);\napp.stage.addChild(noiseContainer);\napp.stage.addChild(waveContainer);\napp.stage.addChild(combineQuad);\n\n// start the animation..\nlet time = 0;\n\napp.ticker.add(() => {\n  time += 1 / 60;\n  // gridQuad.shader.uniforms.zoom = Math.sin(time)*5+10;\n  rippleQuad.shader.uniforms.phase = -time;\n  waveQuad.shader.uniforms.time = time;\n  noiseQuad.shader.uniforms.limit = Math.sin(time * 0.5) * 0.35 + 0.5;\n\n  // Render the passes to get textures.\n  app.renderer.render(gridQuad, { renderTexture: gridTexture });\n  app.renderer.render(rippleQuad, { renderTexture: rippleTexture });\n  app.renderer.render(noiseQuad, { renderTexture: noiseTexture });\n  app.renderer.render(waveQuad, { renderTexture: waveTexture });\n});\n"},dependencies:{"pixi.js":o.npm}})}function c(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},31531:function(e,n,t){t.d(n,{N:()=>s});var r=t(958),i=t(18146),a=t(85893);function s(e){return(0,i.J)("example",!0),(0,a.jsx)(r.M,{height:"calc(100vh - 325px)",fontSize:14,...e})}},99883:function(e){e.exports=JSON.parse('{"versionLabel":"v7.x","version":"7.4.2","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.4.2","build":"https://pixijs.download/v7.4.2/pixi.min.js","docs":"https://pixijs.download/v7.4.2/docs/index.html","npm":"7.4.2","prerelease":false,"latest":false}')}}]);