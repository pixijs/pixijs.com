"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["8708"],{36109:function(n,e,t){t.r(e),t.d(e,{default:()=>h,frontMatter:()=>a,metadata:()=>o,assets:()=>p,toc:()=>c,contentTitle:()=>l});var o=JSON.parse('{"id":"examples/advanced/slots","title":"Slots","description":"","source":"@site/docs/examples/advanced/slots.mdx","sourceDirName":"examples/advanced","slug":"/examples/advanced/slots","permalink":"/8.x/examples/advanced/slots","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":0,"custom_edit_url":null,"title":"Slots"},"sidebar":"examplesSidebar","previous":{"title":"Cache As Texture","permalink":"/8.x/examples/basic/cache-as-texture"},"next":{"title":"Scratch Card","permalink":"/8.x/examples/advanced/scratch-card"}}'),r=t("85893"),s=t("50065"),i=t("43076");let a={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:0,custom_edit_url:null,title:"Slots"},l=void 0,p={},c=[];function d(n){return(0,r.jsx)(i.N,{files:{"index.js":"import {\n    Application,\n    Assets,\n    BlurFilter,\n    Color,\n    Container,\n    FillGradient,\n    Graphics,\n    Sprite,\n    Text,\n    TextStyle,\n    Texture,\n} from 'pixi.js';\n\n(async () =>\n{\n    // Create a new application\n    const app = new Application();\n\n    // Initialize the application\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Append the application canvas to the document body\n    document.body.appendChild(app.canvas);\n\n    // Load the textures\n    await Assets.load([\n        'https://pixijs.com/assets/eggHead.png',\n        'https://pixijs.com/assets/flowerTop.png',\n        'https://pixijs.com/assets/helmlok.png',\n        'https://pixijs.com/assets/skully.png',\n    ]);\n\n    const REEL_WIDTH = 160;\n    const SYMBOL_SIZE = 150;\n\n    // Create different slot symbols\n    const slotTextures = [\n        Texture.from('https://pixijs.com/assets/eggHead.png'),\n        Texture.from('https://pixijs.com/assets/flowerTop.png'),\n        Texture.from('https://pixijs.com/assets/helmlok.png'),\n        Texture.from('https://pixijs.com/assets/skully.png'),\n    ];\n\n    // Build the reels\n    const reels = [];\n    const reelContainer = new Container();\n\n    for (let i = 0; i < 5; i++)\n    {\n        const rc = new Container();\n\n        rc.x = i * REEL_WIDTH;\n        reelContainer.addChild(rc);\n\n        const reel = {\n            container: rc,\n            symbols: [],\n            position: 0,\n            previousPosition: 0,\n            blur: new BlurFilter(),\n        };\n\n        reel.blur.blurX = 0;\n        reel.blur.blurY = 0;\n        rc.filters = [reel.blur];\n\n        // Build the symbols\n        for (let j = 0; j < 4; j++)\n        {\n            const symbol = new Sprite(slotTextures[Math.floor(Math.random() * slotTextures.length)]);\n            // Scale the symbol to fit symbol area.\n\n            symbol.y = j * SYMBOL_SIZE;\n            symbol.scale.x = symbol.scale.y = Math.min(SYMBOL_SIZE / symbol.width, SYMBOL_SIZE / symbol.height);\n            symbol.x = Math.round((SYMBOL_SIZE - symbol.width) / 2);\n            reel.symbols.push(symbol);\n            rc.addChild(symbol);\n        }\n        reels.push(reel);\n    }\n    app.stage.addChild(reelContainer);\n\n    // Build top & bottom covers and position reelContainer\n    const margin = (app.screen.height - SYMBOL_SIZE * 3) / 2;\n\n    reelContainer.y = margin;\n    reelContainer.x = Math.round(app.screen.width - REEL_WIDTH * 5);\n    const top = new Graphics().rect(0, 0, app.screen.width, margin).fill({ color: 0x0 });\n    const bottom = new Graphics().rect(0, SYMBOL_SIZE * 3 + margin, app.screen.width, margin).fill({ color: 0x0 });\n\n    // Create gradient fill\n    const fill = new FillGradient(0, 0, 0, 36 * 1.7);\n\n    const colors = [0xffffff, 0x00ff99].map((color) => Color.shared.setValue(color).toNumber());\n\n    colors.forEach((number, index) =>\n    {\n        const ratio = index / colors.length;\n\n        fill.addColorStop(ratio, number);\n    });\n\n    // Add play text\n    const style = new TextStyle({\n        fontFamily: 'Arial',\n        fontSize: 36,\n        fontStyle: 'italic',\n        fontWeight: 'bold',\n        fill: { fill },\n        stroke: { color: 0x4a1850, width: 5 },\n        dropShadow: {\n            color: 0x000000,\n            angle: Math.PI / 6,\n            blur: 4,\n            distance: 6,\n        },\n        wordWrap: true,\n        wordWrapWidth: 440,\n    });\n\n    const playText = new Text('Spin the wheels!', style);\n\n    playText.x = Math.round((bottom.width - playText.width) / 2);\n    playText.y = app.screen.height - margin + Math.round((margin - playText.height) / 2);\n    bottom.addChild(playText);\n\n    // Add header text\n    const headerText = new Text('PIXI MONSTER SLOTS!', style);\n\n    headerText.x = Math.round((top.width - headerText.width) / 2);\n    headerText.y = Math.round((margin - headerText.height) / 2);\n    top.addChild(headerText);\n\n    app.stage.addChild(top);\n    app.stage.addChild(bottom);\n\n    // Set the interactivity.\n    bottom.eventMode = 'static';\n    bottom.cursor = 'pointer';\n    bottom.addListener('pointerdown', () =>\n    {\n        startPlay();\n    });\n\n    let running = false;\n\n    // Function to start playing.\n    function startPlay()\n    {\n        if (running) return;\n        running = true;\n\n        for (let i = 0; i < reels.length; i++)\n        {\n            const r = reels[i];\n            const extra = Math.floor(Math.random() * 3);\n            const target = r.position + 10 + i * 5 + extra;\n            const time = 2500 + i * 600 + extra * 600;\n\n            tweenTo(r, 'position', target, time, backout(0.5), null, i === reels.length - 1 ? reelsComplete : null);\n        }\n    }\n\n    // Reels done handler.\n    function reelsComplete()\n    {\n        running = false;\n    }\n\n    // Listen for animate update.\n    app.ticker.add(() =>\n    {\n        // Update the slots.\n        for (let i = 0; i < reels.length; i++)\n        {\n            const r = reels[i];\n            // Update blur filter y amount based on speed.\n            // This would be better if calculated with time in mind also. Now blur depends on frame rate.\n\n            r.blur.blurY = (r.position - r.previousPosition) * 8;\n            r.previousPosition = r.position;\n\n            // Update symbol positions on reel.\n            for (let j = 0; j < r.symbols.length; j++)\n            {\n                const s = r.symbols[j];\n                const prevy = s.y;\n\n                s.y = ((r.position + j) % r.symbols.length) * SYMBOL_SIZE - SYMBOL_SIZE;\n                if (s.y < 0 && prevy > SYMBOL_SIZE)\n                {\n                    // Detect going over and swap a texture.\n                    // This should in proper product be determined from some logical reel.\n                    s.texture = slotTextures[Math.floor(Math.random() * slotTextures.length)];\n                    s.scale.x = s.scale.y = Math.min(SYMBOL_SIZE / s.texture.width, SYMBOL_SIZE / s.texture.height);\n                    s.x = Math.round((SYMBOL_SIZE - s.width) / 2);\n                }\n            }\n        }\n    });\n\n    // Very simple tweening utility function. This should be replaced with a proper tweening library in a real product.\n    const tweening = [];\n\n    function tweenTo(object, property, target, time, easing, onchange, oncomplete)\n    {\n        const tween = {\n            object,\n            property,\n            propertyBeginValue: object[property],\n            target,\n            easing,\n            time,\n            change: onchange,\n            complete: oncomplete,\n            start: Date.now(),\n        };\n\n        tweening.push(tween);\n\n        return tween;\n    }\n    // Listen for animate update.\n    app.ticker.add(() =>\n    {\n        const now = Date.now();\n        const remove = [];\n\n        for (let i = 0; i < tweening.length; i++)\n        {\n            const t = tweening[i];\n            const phase = Math.min(1, (now - t.start) / t.time);\n\n            t.object[t.property] = lerp(t.propertyBeginValue, t.target, t.easing(phase));\n            if (t.change) t.change(t);\n            if (phase === 1)\n            {\n                t.object[t.property] = t.target;\n                if (t.complete) t.complete(t);\n                remove.push(t);\n            }\n        }\n        for (let i = 0; i < remove.length; i++)\n        {\n            tweening.splice(tweening.indexOf(remove[i]), 1);\n        }\n    });\n\n    // Basic lerp funtion.\n    function lerp(a1, a2, t)\n    {\n        return a1 * (1 - t) + a2 * t;\n    }\n\n    // Backout function from tweenjs.\n    // https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js\n    function backout(amount)\n    {\n        return (t) => --t * t * ((amount + 1) * t + amount) + 1;\n    }\n})();\n"}})}function h(n={}){let{wrapper:e}={...(0,s.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);