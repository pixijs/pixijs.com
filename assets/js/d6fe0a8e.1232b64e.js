"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["2714"],{58783:function(n,t,e){e.r(t),e.d(t,{default:()=>d,frontMatter:()=>r,metadata:()=>i,assets:()=>l,toc:()=>c,contentTitle:()=>p});var i=JSON.parse('{"id":"examples/advanced/mouse-trail","title":"Mouse Trail","description":"","source":"@site/docs/examples/advanced/mouse-trail.mdx","sourceDirName":"examples/advanced","slug":"/examples/advanced/mouse-trail","permalink":"/8.x/examples/advanced/mouse-trail","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":3,"custom_edit_url":null,"title":"Mouse Trail"},"sidebar":"examplesSidebar","previous":{"title":"Star Warp","permalink":"/8.x/examples/advanced/star-warp"},"next":{"title":"Screen Shot","permalink":"/8.x/examples/advanced/screen-shot"}}'),o=e("85893"),a=e("50065"),s=e("43076");let r={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:3,custom_edit_url:null,title:"Mouse Trail"},p=void 0,l={},c=[];function u(n){return(0,o.jsx)(s.N,{files:{"index.js":"import { Application, Assets, MeshRope, Point } from 'pixi.js';\n\n(async () =>\n{\n    // Create a new application\n    const app = new Application();\n\n    // Initialize the application\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Append the application canvas to the document body\n    document.body.appendChild(app.canvas);\n\n    // Load the texture for rope.\n    const trailTexture = await Assets.load('https://pixijs.com/assets/trail.png');\n\n    const historyX = [];\n    const historyY = [];\n    // historySize determines how long the trail will be.\n    const historySize = 20;\n    // ropeSize determines how smooth the trail will be.\n    const ropeSize = 100;\n    const points = [];\n\n    // Create history array.\n    for (let i = 0; i < historySize; i++)\n    {\n        historyX.push(0);\n\n        historyY.push(0);\n    }\n    // Create rope points.\n    for (let i = 0; i < ropeSize; i++)\n    {\n        points.push(new Point(0, 0));\n    }\n\n    // Create the rope\n    const rope = new MeshRope({ texture: trailTexture, points });\n\n    // Set the blendmode\n    rope.blendmode = 'add';\n\n    app.stage.addChild(rope);\n\n    let mouseposition = null;\n\n    app.stage.eventMode = 'static';\n    app.stage.hitArea = app.screen;\n    app.stage.on('mousemove', (event) =>\n    {\n        mouseposition = mouseposition || { x: 0, y: 0 };\n        mouseposition.x = event.global.x;\n        mouseposition.y = event.global.y;\n    });\n\n    // Listen for animate update\n    app.ticker.add(() =>\n    {\n        if (!mouseposition) return;\n\n        // Update the mouse values to history\n        historyX.pop();\n        historyX.unshift(mouseposition.x);\n        historyY.pop();\n        historyY.unshift(mouseposition.y);\n        // Update the points to correspond with history.\n        for (let i = 0; i < ropeSize; i++)\n        {\n            const p = points[i];\n\n            // Smooth the curve with cubic interpolation to prevent sharp edges.\n            const ix = cubicInterpolation(historyX, (i / ropeSize) * historySize);\n            const iy = cubicInterpolation(historyY, (i / ropeSize) * historySize);\n\n            p.x = ix;\n            p.y = iy;\n        }\n    });\n\n    /**\n     * Cubic interpolation based on https://github.com/osuushi/Smooth.js\n     */\n    function clipInput(k, arr)\n    {\n        if (k < 0) k = 0;\n        if (k > arr.length - 1) k = arr.length - 1;\n\n        return arr[k];\n    }\n\n    function getTangent(k, factor, array)\n    {\n        return (factor * (clipInput(k + 1, array) - clipInput(k - 1, array))) / 2;\n    }\n\n    function cubicInterpolation(array, t, tangentFactor = 1)\n    {\n        const k = Math.floor(t);\n        const m = [getTangent(k, tangentFactor, array), getTangent(k + 1, tangentFactor, array)];\n        const p = [clipInput(k, array), clipInput(k + 1, array)];\n\n        t -= k;\n        const t2 = t * t;\n        const t3 = t * t2;\n\n        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];\n    }\n})();\n"}})}function d(n={}){let{wrapper:t}={...(0,a.a)(),...n.components};return t?(0,o.jsx)(t,{...n,children:(0,o.jsx)(u,{...n})}):u(n)}}}]);