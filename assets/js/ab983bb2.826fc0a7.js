"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["2186"],{41976:function(n,e,t){t.r(e),t.d(e,{default:()=>u,frontMatter:()=>l,metadata:()=>o,assets:()=>d,toc:()=>c,contentTitle:()=>p});var o=JSON.parse('{"id":"examples/advanced/slots","title":"Slots","description":"","source":"@site/versioned_docs/version-7.x/examples/advanced/slots.mdx","sourceDirName":"examples/advanced","slug":"/examples/advanced/slots","permalink":"/7.x/examples/advanced/slots","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"7.x","sidebarPosition":0,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":0,"custom_edit_url":null,"title":"Slots"},"sidebar":"examplesSidebar","previous":{"title":"Simple Plane","permalink":"/7.x/examples/basic/simple-plane"},"next":{"title":"Scratch Card","permalink":"/7.x/examples/advanced/scratch-card"}}'),s=t("85893"),i=t("50065"),r=t("43076"),a=t("99883");let l={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:0,custom_edit_url:null,title:"Slots"},p=void 0,d={},c=[];function h(n){return(0,s.jsx)(r.N,{files:{"index.js":"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load([\n    'https://pixijs.com/assets/eggHead.png',\n    'https://pixijs.com/assets/flowerTop.png',\n    'https://pixijs.com/assets/helmlok.png',\n    'https://pixijs.com/assets/skully.png',\n]).then(onAssetsLoaded);\n\nconst REEL_WIDTH = 160;\nconst SYMBOL_SIZE = 150;\n\n// onAssetsLoaded handler builds the example.\nfunction onAssetsLoaded()\n{\n    // Create different slot symbols.\n    const slotTextures = [\n        PIXI.Texture.from('https://pixijs.com/assets/eggHead.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/flowerTop.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/helmlok.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/skully.png'),\n    ];\n\n    // Build the reels\n    const reels = [];\n    const reelContainer = new PIXI.Container();\n\n    for (let i = 0; i < 5; i++)\n    {\n        const rc = new PIXI.Container();\n\n        rc.x = i * REEL_WIDTH;\n        reelContainer.addChild(rc);\n\n        const reel = {\n            container: rc,\n            symbols: [],\n            position: 0,\n            previousPosition: 0,\n            blur: new PIXI.filters.BlurFilter(),\n        };\n\n        reel.blur.blurX = 0;\n        reel.blur.blurY = 0;\n        rc.filters = [reel.blur];\n\n        // Build the symbols\n        for (let j = 0; j < 4; j++)\n        {\n            const symbol = new PIXI.Sprite(slotTextures[Math.floor(Math.random() * slotTextures.length)]);\n            // Scale the symbol to fit symbol area.\n\n            symbol.y = j * SYMBOL_SIZE;\n            symbol.scale.x = symbol.scale.y = Math.min(SYMBOL_SIZE / symbol.width, SYMBOL_SIZE / symbol.height);\n            symbol.x = Math.round((SYMBOL_SIZE - symbol.width) / 2);\n            reel.symbols.push(symbol);\n            rc.addChild(symbol);\n        }\n        reels.push(reel);\n    }\n    app.stage.addChild(reelContainer);\n\n    // Build top & bottom covers and position reelContainer\n    const margin = (app.screen.height - SYMBOL_SIZE * 3) / 2;\n\n    reelContainer.y = margin;\n    reelContainer.x = Math.round(app.screen.width - REEL_WIDTH * 5);\n    const top = new PIXI.Graphics();\n\n    top.beginFill(0, 1);\n    top.drawRect(0, 0, app.screen.width, margin);\n    const bottom = new PIXI.Graphics();\n\n    bottom.beginFill(0, 1);\n    bottom.drawRect(0, SYMBOL_SIZE * 3 + margin, app.screen.width, margin);\n\n    // Add play text\n    const style = new PIXI.TextStyle({\n        fontFamily: 'Arial',\n        fontSize: 36,\n        fontStyle: 'italic',\n        fontWeight: 'bold',\n        fill: ['#ffffff', '#00ff99'], // gradient\n        stroke: '#4a1850',\n        strokeThickness: 5,\n        dropShadow: true,\n        dropShadowColor: '#000000',\n        dropShadowBlur: 4,\n        dropShadowAngle: Math.PI / 6,\n        dropShadowDistance: 6,\n        wordWrap: true,\n        wordWrapWidth: 440,\n    });\n\n    const playText = new PIXI.Text('Spin the wheels!', style);\n\n    playText.x = Math.round((bottom.width - playText.width) / 2);\n    playText.y = app.screen.height - margin + Math.round((margin - playText.height) / 2);\n    bottom.addChild(playText);\n\n    // Add header text\n    const headerText = new PIXI.Text('PIXI MONSTER SLOTS!', style);\n\n    headerText.x = Math.round((top.width - headerText.width) / 2);\n    headerText.y = Math.round((margin - headerText.height) / 2);\n    top.addChild(headerText);\n\n    app.stage.addChild(top);\n    app.stage.addChild(bottom);\n\n    // Set the interactivity.\n    bottom.eventMode = 'static';\n    bottom.cursor = 'pointer';\n    bottom.addListener('pointerdown', () =>\n    {\n        startPlay();\n    });\n\n    let running = false;\n\n    // Function to start playing.\n    function startPlay()\n    {\n        if (running) return;\n        running = true;\n\n        for (let i = 0; i < reels.length; i++)\n        {\n            const r = reels[i];\n            const extra = Math.floor(Math.random() * 3);\n            const target = r.position + 10 + i * 5 + extra;\n            const time = 2500 + i * 600 + extra * 600;\n\n            tweenTo(r, 'position', target, time, backout(0.5), null, i === reels.length - 1 ? reelsComplete : null);\n        }\n    }\n\n    // Reels done handler.\n    function reelsComplete()\n    {\n        running = false;\n    }\n\n    // Listen for animate update.\n    app.ticker.add((delta) =>\n    {\n        // Update the slots.\n        for (let i = 0; i < reels.length; i++)\n        {\n            const r = reels[i];\n            // Update blur filter y amount based on speed.\n            // This would be better if calculated with time in mind also. Now blur depends on frame rate.\n\n            r.blur.blurY = (r.position - r.previousPosition) * 8;\n            r.previousPosition = r.position;\n\n            // Update symbol positions on reel.\n            for (let j = 0; j < r.symbols.length; j++)\n            {\n                const s = r.symbols[j];\n                const prevy = s.y;\n\n                s.y = ((r.position + j) % r.symbols.length) * SYMBOL_SIZE - SYMBOL_SIZE;\n                if (s.y < 0 && prevy > SYMBOL_SIZE)\n                {\n                    // Detect going over and swap a texture.\n                    // This should in proper product be determined from some logical reel.\n                    s.texture = slotTextures[Math.floor(Math.random() * slotTextures.length)];\n                    s.scale.x = s.scale.y = Math.min(SYMBOL_SIZE / s.texture.width, SYMBOL_SIZE / s.texture.height);\n                    s.x = Math.round((SYMBOL_SIZE - s.width) / 2);\n                }\n            }\n        }\n    });\n}\n\n// Very simple tweening utility function. This should be replaced with a proper tweening library in a real product.\nconst tweening = [];\n\nfunction tweenTo(object, property, target, time, easing, onchange, oncomplete)\n{\n    const tween = {\n        object,\n        property,\n        propertyBeginValue: object[property],\n        target,\n        easing,\n        time,\n        change: onchange,\n        complete: oncomplete,\n        start: Date.now(),\n    };\n\n    tweening.push(tween);\n\n    return tween;\n}\n// Listen for animate update.\napp.ticker.add((delta) =>\n{\n    const now = Date.now();\n    const remove = [];\n\n    for (let i = 0; i < tweening.length; i++)\n    {\n        const t = tweening[i];\n        const phase = Math.min(1, (now - t.start) / t.time);\n\n        t.object[t.property] = lerp(t.propertyBeginValue, t.target, t.easing(phase));\n        if (t.change) t.change(t);\n        if (phase === 1)\n        {\n            t.object[t.property] = t.target;\n            if (t.complete) t.complete(t);\n            remove.push(t);\n        }\n    }\n    for (let i = 0; i < remove.length; i++)\n    {\n        tweening.splice(tweening.indexOf(remove[i]), 1);\n    }\n});\n\n// Basic lerp funtion.\nfunction lerp(a1, a2, t)\n{\n    return a1 * (1 - t) + a2 * t;\n}\n\n// Backout function from tweenjs.\n// https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js\nfunction backout(amount)\n{\n    return (t) => --t * t * ((amount + 1) * t + amount) + 1;\n}\n"},dependencies:{"pixi.js":a.npm}})}function u(n={}){let{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}},99883:function(n){n.exports=JSON.parse('{"versionLabel":"v7.x","version":"7.4.2","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.4.2","build":"https://pixijs.download/v7.4.2/pixi.min.js","docs":"https://pixijs.download/v7.4.2/docs/index.html","npm":"7.4.2","prerelease":false,"latest":false}')}}]);