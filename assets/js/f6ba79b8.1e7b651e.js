"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["3566"],{78408:function(e,i,s){s.r(i),s.d(i,{default:()=>h,frontMatter:()=>l,metadata:()=>n,assets:()=>o,toc:()=>d,contentTitle:()=>a});var n=JSON.parse('{"id":"guides/production/performance-tips","title":"Performance Tips","description":"General","source":"@site/versioned_docs/version-7.x/guides/production/performance-tips.md","sourceDirName":"guides/production","slug":"/guides/production/performance-tips","permalink":"/7.x/guides/production/performance-tips","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/pixijs.com/tree/main/versioned_docs/version-7.x/guides/production/performance-tips.md","tags":[],"version":"7.x","frontMatter":{},"sidebar":"guidesSidebar","previous":{"title":"Textures","permalink":"/7.x/guides/components/textures"},"next":{"title":"Upgrading PixiJS","permalink":"/7.x/guides/migrations/upgrading"}}'),t=s("85893"),r=s("50065");let l={},a="Performance Tips",o={},d=[{value:"General",id:"general",level:3},{value:"Sprites",id:"sprites",level:3},{value:"Graphics",id:"graphics",level:3},{value:"Texture",id:"texture",level:3},{value:"Text",id:"text",level:3},{value:"Masks",id:"masks",level:3},{value:"Filters",id:"filters",level:3},{value:"BlendModes",id:"blendmodes",level:3},{value:"CacheAsBitmap",id:"cacheasbitmap",level:3},{value:"Events",id:"events",level:3}];function c(e){let i={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"performance-tips",children:"Performance Tips"})}),"\n",(0,t.jsx)(i.h3,{id:"general",children:"General"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Only optimize when you need to! PixiJS can handle a fair amount of content off the bat"}),"\n",(0,t.jsx)(i.li,{children:"Be mindful of the complexity of your scene. The more objects you add the slower things will end up"}),"\n",(0,t.jsx)(i.li,{children:"Order can help, for example sprite / graphic / sprite / graphic is slower than sprite / sprite / graphic / graphic"}),"\n",(0,t.jsxs)(i.li,{children:["Some older mobile devices run things a little slower. Passing in the option ",(0,t.jsx)(i.code,{children:"useContextAlpha: false"})," and ",(0,t.jsx)(i.code,{children:"antialias: false"})," to the Renderer or Application can help with performance"]}),"\n",(0,t.jsxs)(i.li,{children:["Culling is disabled by default as it's often better to do this at an application level or set objects to be ",(0,t.jsx)(i.code,{children:"cullable = true"}),". If you are GPU-bound it will improve performance; if you are CPU-bound it will degrade performance"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"sprites",children:"Sprites"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Use Spritesheets where possible to minimize total textures"}),"\n",(0,t.jsx)(i.li,{children:"Sprites can be batched with up to 16 different textures (dependent on hardware)"}),"\n",(0,t.jsx)(i.li,{children:"This is the fastest way to render content"}),"\n",(0,t.jsx)(i.li,{children:"On older devices use smaller low resolution textures"}),"\n",(0,t.jsxs)(i.li,{children:["Add the extention ",(0,t.jsx)(i.code,{children:"@0.5x.png"})," to the 50% scale-down spritesheet so PixiJS will visually-double them automatically"]}),"\n",(0,t.jsx)(i.li,{children:"Draw order can be important"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"graphics",children:"Graphics"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Graphics objects are fastest when they are not modified constantly (not including the transform, alpha or tint!)"}),"\n",(0,t.jsx)(i.li,{children:"Graphics objects are batched when under a certain size (100 points or smaller)"}),"\n",(0,t.jsx)(i.li,{children:"Small Graphics objects are as fast as Sprites (rectangles, triangles)"}),"\n",(0,t.jsx)(i.li,{children:"Using 100s of graphics complex objects can be slow, in this instance use sprites (you can create a texture)"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"texture",children:"Texture"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Textures are automatically managed by a Texture Garbage Collector"}),"\n",(0,t.jsxs)(i.li,{children:["You can also manage them yourself by using ",(0,t.jsx)(i.code,{children:"texture.destroy()"})]}),"\n",(0,t.jsx)(i.li,{children:"If you plan to destroy more than one at once add a random delay to their destruction to remove freezing"}),"\n",(0,t.jsx)(i.li,{children:"Delay texture destroy if you plan to delete a lot of textures yourself"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"text",children:"Text"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Avoid changing it on every frame as this can be expensive (each time it draws to a canvas and then uploads to GPU)"}),"\n",(0,t.jsx)(i.li,{children:"Bitmap Text gives much better performance for dynamically changing text"}),"\n",(0,t.jsxs)(i.li,{children:["Text resolution matches the renderer resolution, decrease resolution yourself by setting the ",(0,t.jsx)(i.code,{children:"resolution"})," property, which can consume less memory"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"masks",children:"Masks"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Masks can be expensive if too many are used: e.g., 100s of masks will really slow things down"}),"\n",(0,t.jsx)(i.li,{children:"Axis-aligned Rectangle masks are the fastest (as the use scissor rect)"}),"\n",(0,t.jsx)(i.li,{children:"Graphics masks are second fastest (as they use the stencil buffer)"}),"\n",(0,t.jsx)(i.li,{children:"Sprite masks are the third fastest (they uses filters). They are really expensive. Do not use too many in your scene!"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"filters",children:"Filters"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Release memory: ",(0,t.jsx)(i.code,{children:"displayObject.filters = null"})]}),"\n",(0,t.jsxs)(i.li,{children:["If you know the size of them: ",(0,t.jsx)(i.code,{children:"displayObject.filterArea = new PIXI.Rectangle(x,y,w,h)"}),". This can speed things up as it means the object does not need to be measured"]}),"\n",(0,t.jsx)(i.li,{children:"Filters are expensive, using too many will start to slow things down!"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"blendmodes",children:"BlendModes"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Different blend modes will cause batches to break (de-optimize)"}),"\n",(0,t.jsx)(i.li,{children:"SceenSprite / NormalSprite / SceenSprite / NormalSprite would be 4 draw calls"}),"\n",(0,t.jsx)(i.li,{children:"SceenSprite / SceenSprite / NormalSprite / NormalSprite would be 2 draw calls"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"cacheasbitmap",children:"CacheAsBitmap"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Setting to ",(0,t.jsx)(i.code,{children:"true"})," turns an object into a Sprite by caching it as a Texture"]}),"\n",(0,t.jsx)(i.li,{children:"It has a one time cost when it is activated as it draws the object to a Texture"}),"\n",(0,t.jsx)(i.li,{children:"Avoid changing this on elements frequently"}),"\n",(0,t.jsx)(i.li,{children:"If you have a complicated item that has lots of sprites / filters AND does not move then this will speed up rendering!"}),"\n",(0,t.jsx)(i.li,{children:"Do not need apply to sprites as they are already Textures"}),"\n",(0,t.jsx)(i.li,{children:"Do not use if the object where its children are constantly changing as this will slow things down"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"events",children:"Events"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["If an object has no interactive children use ",(0,t.jsx)(i.code,{children:"interactiveChildren = false"}),". The event system will then be able to avoid crawling through the object"]}),"\n",(0,t.jsxs)(i.li,{children:["Setting ",(0,t.jsx)(i.code,{children:"hitArea = new PIXI.Rectangle(x,y,w,h)"})," as above should stop the event system from crawling through the object"]}),"\n"]})]})}function h(e={}){let{wrapper:i}={...(0,r.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);