"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["1577"],{24480:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>r,default:()=>u,toc:()=>h,metadata:()=>s,assets:()=>d,contentTitle:()=>c});var s=JSON.parse('{"id":"examples/mesh-and-shaders/perspective-mesh","title":"Perspective Mesh","description":"","source":"@site/docs/examples/mesh-and-shaders/perspective-mesh.mdx","sourceDirName":"examples/mesh-and-shaders","slug":"/examples/mesh-and-shaders/perspective-mesh","permalink":"/8.x/examples/mesh-and-shaders/perspective-mesh","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":0,"custom_edit_url":null,"title":"Perspective Mesh"},"sidebar":"examplesSidebar","previous":{"title":"Custom","permalink":"/8.x/examples/filters-advanced/custom"},"next":{"title":"Textured Mesh Basic","permalink":"/8.x/examples/mesh-and-shaders/textured-mesh-basic"}}'),i=n(85893),a=n(50065),o=n(31531),p=n(98884);let r={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:0,custom_edit_url:null,title:"Perspective Mesh"},c=void 0,d={},h=[];function l(e){return(0,i.jsx)(o.N,{files:{"index.js":p.Z}})}function u(e={}){let{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},98884:function(e,t,n){n.d(t,{Z:()=>s});let s="import { Application, Assets, PerspectiveMesh } from 'pixi.js';\n\n(async () => {\n  // Create a new application\n  const app = new Application();\n\n  // Initialize the application\n  await app.init({ background: '#1099bb', resizeTo: window });\n\n  // Append the application canvas to the document body\n  document.body.appendChild(app.canvas);\n\n  const texture = await Assets.load({\n    src: 'https://pixijs.com/assets/eggHead.png',\n  });\n\n  const points = [\n    { x: 0, y: 0 },\n    { x: texture.width, y: 0 },\n    { x: texture.width, y: texture.height },\n    { x: 0, y: texture.height },\n  ];\n\n  const outPoints = points.map((p) => ({ ...p }));\n\n  const mesh = app.stage.addChild(\n    new PerspectiveMesh({\n      texture,\n      pivot: {\n        x: texture.width / 2,\n        y: texture.height / 2,\n      },\n      x: app.screen.width / 2,\n      y: app.screen.height / 2,\n      width: texture.width,\n      height: texture.height,\n    }),\n  );\n\n  mesh.scale = 2;\n\n  let angleX = 0;\n  let angleY = 0;\n\n  // Function to apply 3D rotation to the points\n  function rotate3D(points, outPoints, angleX, angleY, perspective) {\n    const radX = (angleX * Math.PI) / 180;\n    const radY = (angleY * Math.PI) / 180;\n    const cosX = Math.cos(radX);\n    const sinX = Math.sin(radX);\n    const cosY = Math.cos(radY);\n    const sinY = Math.sin(radY);\n\n    for (let i = 0; i < points.length; i++) {\n      const src = points[i];\n      const out = outPoints[i];\n      const x = src.x - texture.width / 2;\n      const y = src.y - texture.height / 2;\n      let z = 0; // Assume initial z is 0 for this 2D plane\n\n      // Rotate around Y axis\n      const xY = cosY * x - sinY * z;\n\n      z = sinY * x + cosY * z;\n\n      // Rotate around X axis\n      const yX = cosX * y - sinX * z;\n\n      z = sinX * y + cosX * z;\n\n      // Apply perspective projection\n      const scale = perspective / (perspective - z);\n\n      out.x = xY * scale + texture.width / 2;\n      out.y = yX * scale + texture.height / 2;\n    }\n  }\n\n  app.ticker.add(() => {\n    rotate3D(points, outPoints, angleX, angleY, 300);\n    mesh.setCorners(\n      outPoints[0].x,\n      outPoints[0].y,\n      outPoints[1].x,\n      outPoints[1].y,\n      outPoints[2].x,\n      outPoints[2].y,\n      outPoints[3].x,\n      outPoints[3].y,\n    );\n  });\n\n  app.stage.hitArea = app.screen;\n  app.stage.eventMode = 'static';\n  app.stage.on('pointermove', (e) => {\n    const { x, y } = e.global;\n\n    angleY = -(x - mesh.x) / 10;\n    angleX = -(y - mesh.y) / 10;\n  });\n})();\n"}}]);