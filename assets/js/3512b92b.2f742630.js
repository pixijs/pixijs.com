"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["9251"],{92917:function(e,i,n){n.r(i),n.d(i,{frontMatter:()=>l,default:()=>h,toc:()=>c,metadata:()=>s,assets:()=>o,contentTitle:()=>a});var s=JSON.parse('{"id":"guides/concepts/performance-tips","title":"Performance Tips","description":"Performance tips for optimizing PixiJS applications, covering general practices and specific techniques for maximizing rendering efficiency.","source":"@site/docs/guides/concepts/performance-tips.md","sourceDirName":"guides/concepts","slug":"/guides/concepts/performance-tips","permalink":"/8.x/guides/concepts/performance-tips","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/pixijs.com/tree/main/docs/guides/concepts/performance-tips.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"description":"Performance tips for optimizing PixiJS applications, covering general practices and specific techniques for maximizing rendering efficiency."},"sidebar":"guidesSidebar","previous":{"title":"Garbage Collection","permalink":"/8.x/guides/concepts/garbage-collection"},"next":{"title":"Assets","permalink":"/8.x/guides/components/assets/"}}'),r=n(85893),t=n(50065);let l={sidebar_position:6,description:"Performance tips for optimizing PixiJS applications, covering general practices and specific techniques for maximizing rendering efficiency."},a="Performance Tips",o={},c=[{value:"General",id:"general",level:3},{value:"Sprites",id:"sprites",level:3},{value:"Graphics",id:"graphics",level:3},{value:"Texture",id:"texture",level:3},{value:"Text",id:"text",level:3},{value:"Masks",id:"masks",level:3},{value:"Filters",id:"filters",level:3},{value:"BlendModes",id:"blendmodes",level:3},{value:"Events",id:"events",level:3}];function d(e){let i={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"performance-tips",children:"Performance Tips"})}),"\n",(0,r.jsx)(i.h3,{id:"general",children:"General"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Only optimize when you need to! PixiJS can handle a fair amount of content off the bat"}),"\n",(0,r.jsx)(i.li,{children:"Be mindful of the complexity of your scene. The more objects you add the slower things will end up"}),"\n",(0,r.jsx)(i.li,{children:"Order can help, for example sprite / graphic / sprite / graphic is slower than sprite / sprite / graphic / graphic"}),"\n",(0,r.jsxs)(i.li,{children:["Some older mobile devices run things a little slower. Passing in the option ",(0,r.jsx)(i.code,{children:"useContextAlpha: false"})," and ",(0,r.jsx)(i.code,{children:"antialias: false"})," to the Renderer or Application can help with performance"]}),"\n",(0,r.jsxs)(i.li,{children:["Culling is disabled by default as it's often better to do this at an application level or set objects to be ",(0,r.jsx)(i.code,{children:"cullable = true"}),". If you are GPU-bound it will improve performance; if you are CPU-bound it will degrade performance"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"sprites",children:"Sprites"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Use Spritesheets where possible to minimize total textures"}),"\n",(0,r.jsx)(i.li,{children:"Sprites can be batched with up to 16 different textures (dependent on hardware)"}),"\n",(0,r.jsx)(i.li,{children:"This is the fastest way to render content"}),"\n",(0,r.jsx)(i.li,{children:"On older devices use smaller low resolution textures"}),"\n",(0,r.jsxs)(i.li,{children:["Add the extention ",(0,r.jsx)(i.code,{children:"@0.5x.png"})," to the 50% scale-down spritesheet so PixiJS will visually-double them automatically"]}),"\n",(0,r.jsx)(i.li,{children:"Draw order can be important"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"graphics",children:"Graphics"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Graphics objects are fastest when they are not modified constantly (not including the transform, alpha or tint!)"}),"\n",(0,r.jsx)(i.li,{children:"Graphics objects are batched when under a certain size (100 points or smaller)"}),"\n",(0,r.jsx)(i.li,{children:"Small Graphics objects are as fast as Sprites (rectangles, triangles)"}),"\n",(0,r.jsx)(i.li,{children:"Using 100s of graphics complex objects can be slow, in this instance use sprites (you can create a texture)"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"texture",children:"Texture"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Textures are automatically managed by a Texture Garbage Collector"}),"\n",(0,r.jsxs)(i.li,{children:["You can also manage them yourself by using ",(0,r.jsx)(i.code,{children:"texture.destroy()"})]}),"\n",(0,r.jsx)(i.li,{children:"If you plan to destroy more than one at once add a random delay to their destruction to remove freezing"}),"\n",(0,r.jsx)(i.li,{children:"Delay texture destroy if you plan to delete a lot of textures yourself"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"text",children:"Text"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Avoid changing it on every frame as this can be expensive (each time it draws to a canvas and then uploads to GPU)"}),"\n",(0,r.jsx)(i.li,{children:"Bitmap Text gives much better performance for dynamically changing text"}),"\n",(0,r.jsxs)(i.li,{children:["Text resolution matches the renderer resolution, decrease resolution yourself by setting the ",(0,r.jsx)(i.code,{children:"resolution"})," property, which can consume less memory"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"masks",children:"Masks"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Masks can be expensive if too many are used: e.g., 100s of masks will really slow things down"}),"\n",(0,r.jsx)(i.li,{children:"Axis-aligned Rectangle masks are the fastest (as they use scissor rect)"}),"\n",(0,r.jsx)(i.li,{children:"Graphics masks are second fastest (as they use the stencil buffer)"}),"\n",(0,r.jsx)(i.li,{children:"Sprite masks are the third fastest (they use filters). They are really expensive. Do not use too many in your scene!"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"filters",children:"Filters"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Release memory: ",(0,r.jsx)(i.code,{children:"container.filters = null"})]}),"\n",(0,r.jsxs)(i.li,{children:["If you know the size of them: ",(0,r.jsx)(i.code,{children:"container.filterArea = new Rectangle(x,y,w,h)"}),". This can speed things up as it means the object does not need to be measured"]}),"\n",(0,r.jsx)(i.li,{children:"Filters are expensive, using too many will start to slow things down!"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"blendmodes",children:"BlendModes"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Different blend modes will cause batches to break (de-optimize)"}),"\n",(0,r.jsx)(i.li,{children:"ScreenSprite / NormalSprite / ScreenSprite / NormalSprite would be 4 draw calls"}),"\n",(0,r.jsx)(i.li,{children:"ScreenSprite / ScreenSprite / NormalSprite / NormalSprite would be 2 draw calls"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"events",children:"Events"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["If an object has no interactive children use ",(0,r.jsx)(i.code,{children:"interactiveChildren = false"}),". The event system will then be able to avoid crawling through the object"]}),"\n",(0,r.jsxs)(i.li,{children:["Setting ",(0,r.jsx)(i.code,{children:"hitArea = new Rectangle(x,y,w,h)"})," as above should stop the event system from crawling through the object"]}),"\n"]})]})}function h(e={}){let{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);