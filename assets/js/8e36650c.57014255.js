"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[3990],{5103:(e,n,t)=>{t.d(n,{Z:()=>h});var a=t(7294);const i={wrapper:"wrapper_IMn0",content:"content_gcvh",card:"card_FbVX",navigator:"navigator_LnKI",interactionArea:"interactionArea_WAqO",dropdown:"dropdown_jD6X",selected:"selected_dCXs",footer:"footer_HOIY",next:"next_dXvJ",editorToggle:"editorToggle_OOG5",showEditor:"showEditor_d5qi",loader:"loader_bTGi"};var o=t(9960),s=t(1262),r=t(5166),p=t(2956),l=t(3874),d=t(5893);function c(e){let{data:n,pixiVersion:t,extraPackages:s}=e,p=Number(window.location.hash.replace("#",""));(!p||p<=0||p>n.length)&&(p=1),(0,a.useEffect)((()=>{window.location.hash=p.toString()}),[p]);const{Content:c,code:h,completedCode:u}=n[p-1],[m,g]=(0,a.useState)(!1),f=()=>{g(!1)},{indexCode:k,extraFiles:y}=(0,l.K7)(h),{indexCode:w,extraFiles:b}=(0,l.K7)(u??h);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)("div",{className:i.content,children:(0,d.jsxs)("div",{className:i.card,children:[(0,d.jsxs)("div",{className:i.navigator,children:[(0,d.jsx)("div",{className:i.interactionArea}),(0,d.jsx)("span",{children:`${p} / ${n.length}`}),(0,d.jsx)("ul",{className:i.dropdown,children:n.map(((e,n)=>(0,d.jsx)(o.Z,{onClick:f,to:`#${n+1}`,children:(0,d.jsx)("div",{className:`${n===p-1?i.selected:""}`,children:`${n+1}.  ${e.header}`})},n)))})]}),(0,d.jsx)(c,{}),u&&(0,d.jsx)("button",{onClick:()=>{g(!m)},children:m?"Reset":"Solution"}),(0,d.jsxs)("div",{className:i.footer,children:[p>1&&(0,d.jsx)(o.Z,{onClick:f,className:i.prev,to:"#"+(p-1),children:"<  Prev"}),p<n.length&&(0,d.jsx)(o.Z,{onClick:f,className:i.next,to:`#${p+1}`,children:"Next  >"})]})]})}),(0,d.jsx)(r.Z,{code:u&&m?w:k,extraFiles:u&&m?b:y,extraPackages:s,pixiVersion:t.version,isPixiDevVersion:t.dev,mode:"tutorial"})]})}function h(e){let{id:n,pixiVersion:t}=e;const o=t.version,[r,l]=(0,a.useState)(!1),h=(0,p.S)(o,n);return(0,d.jsxs)("div",{className:`${i.wrapper} ${r?i.showEditor:""}`,children:[(0,d.jsx)("button",{onClick:()=>{l(!r)},className:i.editorToggle,children:r?"<  To Instructions":"To Editor >"}),(0,d.jsx)(s.Z,{fallback:(0,d.jsx)("h1",{className:i.loader,children:"LOADING..."}),children:()=>(0,d.jsx)(c,{data:h.steps,pixiVersion:t,extraPackages:h.extraPackages})})]})}},2956:(e,n,t)=>{t.d(n,{M:()=>Ve,S:()=>qe});var a=t(1249);var i=t(7462),o=(t(7294),t(3905));const s={toc:[]};function r(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"getting-started"},"Getting Started"),(0,o.kt)("p",null,"Welcome to the PixiJS tutorial!"),(0,o.kt)("p",null,"Please go through the tutorial steps at your own pace and challenge yourself using the editor on the right hand side. Here PixiJS has already been included as guided under the ",(0,o.kt)("a",{parentName:"p",href:"/guides/basics/getting-started#loading-pixijs"},"Getting Started")," section. Let's start with the creation of a PixiJS canvas application and add its view to the DOM."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// Create a PixiJS application of type canvas with specify background color and make it resize to the iframe window\nconst app = new PIXI.Application() < HTMLCanvasElement > { background: '#1099bb', resizeTo: window };\n\n// Adding the application's view to the DOM\ndocument.body.appendChild(app.view);\n")),(0,o.kt)("p",null,"When you are ready, proceed to the next exercise using the ",(0,o.kt)("em",{parentName:"p"},"Next >")," button below, or feel free to skip to any exercise using the drop-down menu on the top right hand corner of the card."))}r.isMDXComponent=!0;const p={toc:[]};function l(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"creating-a-sprite"},"Creating a Sprite"),(0,o.kt)("p",null,"So far all we've been doing is prep work. We haven't actually told PixiJS to draw anything. Let's fix that by adding an image to be displayed."),(0,o.kt)("p",null,"There are a number of ways to draw images in PixiJS, but the simplest is by using a ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.Sprite.html"},"Sprite"),". We'll get into the details of how the scene graph works in a later guide, but for now all you need to know is that PixiJS renders a hierarchy of ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.DisplayObject.html"},"DisplayObjects"),". A Sprite is a type of DisplayObject that wraps a loaded image resource to allow drawing it, scaling it, rotating it, and so forth."),(0,o.kt)("p",null,"Before PixiJS can render an image, it needs to be loaded. Just like in any web page, image loading happens asynchronously. We'll talk a lot more about resource loading in later guides. For now, we can use a helper method on the PIXI.Sprite class to handle the image loading for us:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// Magically load the PNG asynchronously\nconst bunny = PIXI.Sprite.from('https://pixijs.com/assets/bunny.png')\n")),(0,o.kt)("p",null,"Then we need to add our new sprite to the stage. The stage is simply a ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.Container.html"},"Container")," that is the root of the scene graph. Every child of the stage container will be rendered every frame. By adding our sprite to the stage, we tell PixiJS's renderer we want to draw it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"app.stage.addChild(bunny)\n")),(0,o.kt)("p",null,"Now let's set the Sprite's anchor and position it so that it's bang on at the center."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// center the sprite's anchor point\nbunny.anchor.set(0.5)\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2\nbunny.y = app.screen.height / 2\n")))}l.isMDXComponent=!0;const d={toc:[]};function c(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"writing-an-update-loop"},"Writing an Update Loop"),(0,o.kt)("p",null,"While you ",(0,o.kt)("em",{parentName:"p"},"can")," use PixiJS for static content, for most projects you'll want to add animation. Our sample app is actually cranking away, rendering the same sprite in the same place multiple times a second. All we have to do to make the image move is to update its attributes once per frame. To do this, we want to hook into the application's ",(0,o.kt)("em",{parentName:"p"},"ticker"),". A ticker is a PixiJS object that runs one or more callbacks each frame. Doing so is surprisingly easy. Add the following to the end of your script block:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// Listen for animate update\napp.ticker.add((delta) => {\n    // just for fun, let's rotate mr rabbit a little\n    // delta is 1 if running at 100% performance\n    // creates frame-independent transformation\n    bunny.rotation += 0.1 * delta;\n});\n")),(0,o.kt)("p",null,"All you need to do is to call ",(0,o.kt)("inlineCode",{parentName:"p"},"app.ticker.add(...)"),", pass it a callback function, and then update your scene in that function. It will get called every frame, and you can move, rotate etc. whatever you'd like to drive your project's animations."))}c.isMDXComponent=!0;const h={toc:[]};function u(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"you-did-it"},"You did it!"),(0,o.kt)("p",null,"Congratulations! Now you are ready for the real world ~"))}u.isMDXComponent=!0;const m={gettingStarted:{description:"Learn the basics of how to use PixiJS.",thumbnail:"thumb_getting_started.png",steps:[{header:"Getting Started",Content:r,code:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({\n    background: '#1099bb',\n    resizeTo: window,\n});\n\ndocument.body.appendChild(app.view);\n"},{header:"Set up something",Content:l,code:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({\n    background: '#1099bb',\n    resizeTo: window,\n});\n\ndocument.body.appendChild(app.view);\n",completedCode:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({\n    background: '#1099bb',\n    resizeTo: window,\n});\n\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path\nconst bunny = PIXI.Sprite.from('https://pixijs.com/assets/bunny.png');\n\n// add to stage\napp.stage.addChild(bunny);\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n"},{header:"Do something",Content:c,code:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({\n    background: '#1099bb',\n    resizeTo: window,\n});\n\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path\nconst bunny = PIXI.Sprite.from('https://pixijs.com/assets/bunny.png');\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n\napp.stage.addChild(bunny);\n",completedCode:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({\n    background: '#1099bb',\n    resizeTo: window,\n});\n\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path\nconst bunny = PIXI.Sprite.from('https://pixijs.com/assets/bunny.png');\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n\napp.stage.addChild(bunny);\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // just for fun, let's rotate mr rabbit a little\n    // delta is 1 if running at 100% performance\n    // creates frame-independent transformation\n    bunny.rotation += 0.1 * delta;\n});\n"},{header:"You did it!",Content:u,code:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({\n    background: '#1099bb',\n    resizeTo: window,\n});\n\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path\nconst bunny = PIXI.Sprite.from('https://pixijs.com/assets/bunny.png');\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n\napp.stage.addChild(bunny);\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // just for fun, let's rotate mr rabbit a little\n    // delta is 1 if running at 100% performance\n    // creates frame-independent transformation\n    bunny.rotation += 0.1 * delta;\n});\n"}]}},g={toc:[{value:"Application Setup",id:"application-setup",level:2}]};function f(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"onboard-the-choo-choo-train"},"Onboard the Choo Choo Train!"),(0,o.kt)("p",null,"Welcome to the Choo Choo Train workshop!"),(0,o.kt)("p",null,"We are going to handcraft a cute little scene of a train moving through a landscape at night. We will solely be using the ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.com/guides/components/graphics"},"Graphics")," API to draw out the whole scene. In this tutorial, we will be exploring a handful of methods it provides to draw a variety of shapes. For the full list of methods, please check out the Graphics ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.Graphics.html"},"documentation"),"."),(0,o.kt)("p",null,"Please go through the tutorial steps at your own pace and challenge yourself using the editor on the right hand side. Here PixiJS has already been included as guided under the ",(0,o.kt)("a",{parentName:"p",href:"/guides/basics/getting-started#loading-pixijs"},"Getting Started")," section. Let's start off by creation a PixiJS application, initialize it, add its canvas to the DOM, and preload the required assets ahead of the subsequent steps."),(0,o.kt)("p",null,"We will be using an asynchronous immediately invoked function expression (",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Glossary/IIFE"},"IIFE"),"), but you are free to switch to use promises instead."),(0,o.kt)("h2",{id:"application-setup"},"Application Setup"),(0,o.kt)("p",null,"Let's create the application outside of the IIFE just so that it can be referenced across other functions declared outside. We can then initialize the application and appending its canvas to the DOM inside the IIFE."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"await app.init({ background: '#021f4b', resizeTo: window });\ndocument.body.appendChild(app.canvas);\n")),(0,o.kt)("p",null,"At this point, you should see the preview filled with an empty light blue background."),(0,o.kt)("p",null,"When you are ready, proceed to the next exercise using the ",(0,o.kt)("em",{parentName:"p"},"Next >")," button below, or feel free to skip to any exercise using the drop-down menu on the top right hand corner of the card."))}f.isMDXComponent=!0;const k={toc:[]};function y(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-stars"},"Adding Stars"),(0,o.kt)("p",null,"Let's start with the sky! It's a little plain and boring right now, so how about adding some stars to it?"),(0,o.kt)("p",null,"Because we will be drawing many different elements on the remaining steps, let's separate the building of each element into its own function to be called from within the main IIFE. Here, the ",(0,o.kt)("inlineCode",{parentName:"p"},"addStars")," function has been set up for you to fill out."),(0,o.kt)("p",null,"Graphics API has a built-in ",(0,o.kt)("inlineCode",{parentName:"p"},"star(x, y, points, radius, innerRadius?, rotation?)")," method for this with the ability to specify number of star points, its rotation, radius and even inner radius if you prefer it with a hollow."),(0,o.kt)("p",null,"Here, we will use a for-loop to create a number of 5-point stars with randomized radius, rotation and deterministically randomized positions across the whole scene. Let create 20 scattered stars with a radius size between 2 - 5 units to start under a single Graphics instance. After drawing out the individual invisible shape, we can then use the ",(0,o.kt)("inlineCode",{parentName:"p"},"fill(style)")," method to color it in, specifying the color and the opacity calculated from the percentage of random radius to the max radius."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"TIPS:")," The Graphics API methods (with a few exceptions) return back the Graphics instance so it can be used for chained as you will see in the future steps"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const starCount = 20;\nconst graphics = new Graphics();\n\nfor (let index = 0; index < starCount; index++)\n{\n    const x = (index * 0.78695 * app.screen.width) % app.screen.width;\n    const y = (index * 0.9382 * app.screen.height) % app.screen.height;\n    const radius = 2 + Math.random() * 3;\n    const rotation = Math.random() * Math.PI * 2;\n\n    graphics.star(x, y, 5, radius, 0, rotation).fill({ color: 0xffdf00, alpha: radius / 5 });\n}\n\napp.stage.addChild(graphics);\n")),(0,o.kt)("p",null,"Now we have a starry sky! But let's take it a little further to lighten up our sky even more on the next step."))}y.isMDXComponent=!0;const w={toc:[]};function b(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-moon"},"Adding Moon"),(0,o.kt)("p",null,"For the moon crescent, we will cheat a little bit with the included moon SVG file."),(0,o.kt)("p",null,"Graphics API also has a built-in ",(0,o.kt)("inlineCode",{parentName:"p"},"svg(svgString)")," method for drawing vector graphics using SVG data. Have a go at it on the set up ",(0,o.kt)("inlineCode",{parentName:"p"},"addMoon")," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const graphics = new Graphics().svg(parsedSvg);\n\ngraphics.x = app.screen.width / 2 + 100;\ngraphics.y = app.screen.height / 8;\napp.stage.addChild(graphics);\n")),(0,o.kt)("p",null,"Think the sky is enough, let's us now proceed to add some landscape elements!"))}b.isMDXComponent=!0;const x={toc:[{value:"Create Mountain Groups",id:"create-mountain-groups",level:2},{value:"Set Up Mountain Groups",id:"set-up-mountain-groups",level:2},{value:"Animate Mountains",id:"animate-mountains",level:2}]};function v(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},x,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-mountains"},"Adding Mountains"),(0,o.kt)("p",null,"For the background let's put up some mountains, shall we? We will also animate them to the left to give an impression that the scene is moving rightwards."),(0,o.kt)("h2",{id:"create-mountain-groups"},"Create Mountain Groups"),(0,o.kt)("p",null,"Since we are moving the mountains to the left, they will eventually go off the screen and at the same time leaving empty spaces to the right. To fix this, we will be looping them back to the right of the scene once they go out of the scene view. In order to make the loop seamless, we will be making 2 mountain groups where each covers the whole scene. Then we will offset one group off the screen to the right. This is so that the second group and slowly filling in the screen from the right as the first group moving off the screen to the left before looping back to be offscreen to the right of the second group and repeating the process."),(0,o.kt)("p",null,"Let start by filling in the logic for creating a mountain group in the ",(0,o.kt)("inlineCode",{parentName:"p"},"createMountainGroup()")," function which will return a Graphics instance of a mountain group. We will use this to create the 2 group instances later."),(0,o.kt)("p",null,"Here, we are using a single Graphics instance for a group of mountains. Taking into account the screen dimension we can draw out 3 mountains with different heights and colors. In this case, we will imagine the Graphics instance as a pen and for each of the mountain we move the pen to the starting position using Graphics API's ",(0,o.kt)("inlineCode",{parentName:"p"},"moveTo(x, y)")," method and then contour out the mountain arc using ",(0,o.kt)("inlineCode",{parentName:"p"},"bezierCurveTo(cx1, cy1, cx2, cy2, x, y)")," method, where ","[",(0,o.kt)("inlineCode",{parentName:"p"},"cx"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"cy"),"]"," positions are control point coordinates for the curve going from where it was to the ","[",(0,o.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),"]"," position. Again, we then need to fill the resulted shape with ",(0,o.kt)("inlineCode",{parentName:"p"},"fill(style)"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"TIPS:")," In this case, we do not have to connect the end point to the starting point as the Graphics' context will automatically infer a closed shape by doing so for the fill."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const graphics = new Graphics();\nconst width = app.screen.width / 2;\nconst startY = app.screen.height;\nconst startXLeft = 0;\nconst startXMiddle = Number(app.screen.width) / 4;\nconst startXRight = app.screen.width / 2;\nconst heightLeft = app.screen.height / 2;\nconst heightMiddle = (app.screen.height * 4) / 5;\nconst heightRight = (app.screen.height * 2) / 3;\nconst colorLeft = 0xc1c0c2;\nconst colorMiddle = 0x7e818f;\nconst colorRight = 0x8c919f;\n\ngraphics\n    // Draw the middle mountain\n    .moveTo(startXMiddle, startY)\n    .bezierCurveTo(\n        startXMiddle + width / 2,\n        startY - heightMiddle,\n        startXMiddle + width / 2,\n        startY - heightMiddle,\n        startXMiddle + width,\n        startY,\n    )\n    .fill({ color: colorMiddle })\n\n    // Draw the left mountain\n    .moveTo(startXLeft, startY)\n    .bezierCurveTo(\n        startXLeft + width / 2,\n        startY - heightLeft,\n        startXLeft + width / 2,\n        startY - heightLeft,\n        startXLeft + width,\n        startY,\n    )\n    .fill({ color: colorLeft })\n\n    // Draw the right mountain\n    .moveTo(startXRight, startY)\n    .bezierCurveTo(\n        startXRight + width / 2,\n        startY - heightRight,\n        startXRight + width / 2,\n        startY - heightRight,\n        startXRight + width,\n        startY,\n    )\n    .fill({ color: colorRight });\n\nreturn graphics;\n")),(0,o.kt)("h2",{id:"set-up-mountain-groups"},"Set Up Mountain Groups"),(0,o.kt)("p",null,"With the ",(0,o.kt)("inlineCode",{parentName:"p"},"createMountainGroup()")," helper function, we can then create 2 instances of the mountain group and offset one of them off the screen to the right."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const group1 = createMountainGroup();\nconst group2 = createMountainGroup();\n\ngroup2.x = app.screen.width;\napp.stage.addChild(group1, group2);\n")),(0,o.kt)("p",null,"You should now see a single group of mountains covering the whole scene."),(0,o.kt)("h2",{id:"animate-mountains"},"Animate Mountains"),(0,o.kt)("p",null,"Using the application's ticker, we can add a callback function which will reposition the mountain groups every ticker update, creating a continuous animation. The callback function will be supplied with the Ticker object in which time-related data can be inferred like the ",(0,o.kt)("inlineCode",{parentName:"p"},"deltaTime")," that we will be using to calculate the distance for the mountain to move consistently. Remember to reposition the groups when they moved completely off the screen. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"app.ticker.add((time) =>\n{\n    const dx = time.deltaTime * 0.5;\n\n    group1.x -= dx;\n    group2.x -= dx;\n\n    if (group1.x <= -app.screen.width)\n    {\n        group1.x += app.screen.width * 2;\n    }\n    if (group2.x <= -app.screen.width)\n    {\n        group2.x += app.screen.width * 2;\n    }\n});\n")))}v.isMDXComponent=!0;const C={toc:[{value:"Create Tree",id:"create-tree",level:2},{value:"Set Up Trees",id:"set-up-trees",level:2},{value:"Animate Trees",id:"animate-trees",level:2}]};function T(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},C,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-trees"},"Adding Trees"),(0,o.kt)("p",null,"Let's apply the same principles we used on the mountains step and do the same thing for the trees layer."),(0,o.kt)("h2",{id:"create-tree"},"Create Tree"),(0,o.kt)("p",null,"Starting off with the helper function to create a tree, ",(0,o.kt)("inlineCode",{parentName:"p"},"createTree(width, height)")," which will instantiate a Graphics element with a tree of specified width and height drawn on. We begin with drawing the trunk using Graphics API's ",(0,o.kt)("inlineCode",{parentName:"p"},"rect(x, y, width, height)")," method and fill it out with ",(0,o.kt)("inlineCode",{parentName:"p"},"fill(style)")," method as usual."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const trunkWidth = 30;\nconst trunkHeight = height / 4;\nconst trunkColor = 0x563929;\nconst graphics = new Graphics()\n        .rect(-trunkWidth / 2, -trunkHeight, trunkWidth, trunkHeight)\n        .fill({ color: trunkColor });\n")),(0,o.kt)("p",null,"Then for the crown, we will draw 4 stacking triangles with each triangle being thinner as we move upwards and the top triangles slightly overlapping the lower ones. Here's an example of how we can achieve that iteratively:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const crownHeight = height - trunkHeight;\nconst crownLevels = 4;\nconst crownLevelHeight = crownHeight / crownLevels;\nconst crownWidthIncrement = width / crownLevels;\nconst crownColor = 0x264d3d;\n\nfor (let index = 0; index < crownLevels; index++)\n{\n    const y = -trunkHeight - crownLevelHeight * index;\n    const levelWidth = width - crownWidthIncrement * index;\n    const offset = index < crownLevels - 1 ? crownLevelHeight / 2 : 0;\n\n    graphics\n        .moveTo(-levelWidth / 2, y)\n        .lineTo(0, y - crownLevelHeight - offset)\n        .lineTo(levelWidth / 2, y)\n        .fill({ color: crownColor });\n}\n\nreturn graphics;\n")),(0,o.kt)("h2",{id:"set-up-trees"},"Set Up Trees"),(0,o.kt)("p",null,"Now in the ",(0,o.kt)("inlineCode",{parentName:"p"},"addTree()")," function we can instantiate as many trees as we need to cover the screen horizontally, with a few additions as offscreen buffers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const treeWidth = 200;\nconst y = app.screen.height - 20;\nconst spacing = 15;\nconst count = app.screen.width / (treeWidth + spacing) + 1;\nconst trees = [];\n\nfor (let index = 0; index < count; index++)\n{\n    const treeHeight = 225 + Math.random() * 50;\n    const tree = createTree(treeWidth, treeHeight);\n\n    tree.x = index * (treeWidth + spacing);\n    tree.y = y;\n\n    app.stage.addChild(tree);\n    trees.push(tree);\n}\n")),(0,o.kt)("h2",{id:"animate-trees"},"Animate Trees"),(0,o.kt)("p",null,"Then do the same animation animation setup as we did for the mountains using the application's ticker. However, we will make the rate of change (",(0,o.kt)("inlineCode",{parentName:"p"},"dx"),") faster than that of the mountains to simulate the trees being closer to the camera, which should make them go by faster due to the parallax effect."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"app.ticker.add((time) =>\n{\n    const dx = time.deltaTime * 3;\n\n    trees.forEach((tree) =>\n    {\n        tree.x -= dx;\n\n        if (tree.x <= -(treeWidth / 2 + spacing))\n        {\n            tree.x += count * (treeWidth + spacing) + spacing * 3;\n        }\n    });\n});\n")))}T.isMDXComponent=!0;const S={toc:[{value:"Snow Layer",id:"snow-layer",level:2},{value:"Track&#39;s Planks",id:"tracks-planks",level:2},{value:"Track&#39;s Rail",id:"tracks-rail",level:2}]};function j(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},S,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-ground"},"Adding Ground"),(0,o.kt)("p",null,"The trees are floating in space right at this point, but that's because we left some space for the ground layer. Let's fill that up together now!"),(0,o.kt)("p",null,"We will be making 3 layers of the ground with the bottom-most being the snow and the top two being the train track parts."),(0,o.kt)("h2",{id:"snow-layer"},"Snow Layer"),(0,o.kt)("p",null,"For this, we can simply draw a long rectangle strip across the screen and fill in the color of the snow."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const width = app.screen.width;\nconst groundHeight = 20;\nconst groundY = app.screen.height;\nconst ground = new Graphics()\n    .rect(0, groundY - groundHeight, width, groundHeight)\n    .fill({ color: 0xdddddd });\n\napp.stage.addChild(ground);\n")),(0,o.kt)("h2",{id:"tracks-planks"},"Track's Planks"),(0,o.kt)("p",null,"For the planks, we will be doing the same thing as we did for the trees. First by defining the dimensions of each plank and determining the amount needed to cover the width of the scene with a few additional offscreen buffers as we will be animating them as well. We will position them on top of the snow layer."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const trackHeight = 15;\nconst plankWidth = 50;\nconst plankHeight = trackHeight / 2;\nconst plankGap = 20;\nconst plankCount = width / (plankWidth + plankGap) + 1;\nconst plankY = groundY - groundHeight;\nconst planks = [];\n\nfor (let index = 0; index < plankCount; index++)\n{\n    const plank = new Graphics()\n        .rect(0, plankY - plankHeight, plankWidth, plankHeight)\n        .fill({ color: 0x241811 });\n\n    plank.x = index * (plankWidth + plankGap);\n    app.stage.addChild(plank);\n    planks.push(plank);\n}\n")),(0,o.kt)("p",null,"Then add the animation to the planks in the similar manner to the trees animation. Again, making the rate of change (",(0,o.kt)("inlineCode",{parentName:"p"},"dx"),") even faster than the trees to simulate the track being closer to the camera, and hence travel faster across the screen (Parallax Effect)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"app.ticker.add((time) =>\n{\n    const dx = time.deltaTime * 6;\n\n    planks.forEach((plank) =>\n    {\n        plank.x -= dx;\n\n        if (plank.x <= -(plankWidth + plankGap))\n        {\n            plank.x += plankCount * (plankWidth + plankGap) + plankGap * 1.5;\n        }\n    });\n});\n")),(0,o.kt)("h2",{id:"tracks-rail"},"Track's Rail"),(0,o.kt)("p",null,"For the metal rail for the train's wheels to go onto, it will be another simple rectangle strip just like the ground and we will place them above the planks layer."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const railHeight = trackHeight / 2;\nconst railY = plankY - plankHeight;\nconst rail = new Graphics()\n    .rect(0, railY - railHeight, width, railHeight)\n    .fill({ color: 0x5c5c5c });\n\napp.stage.addChild(rail);\n")),(0,o.kt)("hr",null),(0,o.kt)("p",null,"With the layers coming together, it should sell an effect of the track being passed by. Next, we can finally move on to work on the main star of the workshop - the train!"))}j.isMDXComponent=!0;const A={toc:[{value:"Body",id:"body",level:2},{value:"Wheels",id:"wheels",level:2},{value:"Combine and Animate",id:"combine-and-animate",level:2}]};function W(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},A,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-train-head"},"Adding Train Head"),(0,o.kt)("p",null,"We will start by making the head of the train first, and to do so we will be separating them into parts:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Cabin"),(0,o.kt)("li",{parentName:"ul"},"Door"),(0,o.kt)("li",{parentName:"ul"},"Window"),(0,o.kt)("li",{parentName:"ul"},"Roof"),(0,o.kt)("li",{parentName:"ul"},"Front"),(0,o.kt)("li",{parentName:"ul"},"Chimney"),(0,o.kt)("li",{parentName:"ul"},"Wheels")),(0,o.kt)("p",null,"Apart from the wheels, the parts will be drawn using a single Graphics instance. Let wrap all of the logic for this inside the already set-up ",(0,o.kt)("inlineCode",{parentName:"p"},"createTrainHead()")," function that will return a Container element holding all the parts together."),(0,o.kt)("h2",{id:"body"},"Body"),(0,o.kt)("p",null,"The body parts includes the cabin with its overlaying door and window topped with a roof, and the protruding front with the chimney on top."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const frontHeight = 100;\nconst frontWidth = 140;\nconst frontRadius = frontHeight / 2;\n\nconst cabinHeight = 200;\nconst cabinWidth = 150;\nconst cabinRadius = 15;\n\nconst chimneyBaseWidth = 30;\nconst chimneyTopWidth = 50;\nconst chimneyHeight = 70;\nconst chimneyDomeHeight = 25;\nconst chimneyTopOffset = (chimneyTopWidth - chimneyBaseWidth) / 2;\nconst chimneyStartX = cabinWidth + frontWidth - frontRadius - chimneyBaseWidth;\nconst chimneyStartY = -frontHeight;\n\nconst roofHeight = 25;\nconst roofExcess = 20;\n\nconst doorWidth = cabinWidth * 0.7;\nconst doorHeight = cabinHeight * 0.7;\nconst doorStartX = (cabinWidth - doorWidth) * 0.5;\nconst doorStartY = -(cabinHeight - doorHeight) * 0.5 - doorHeight;\n\nconst windowWidth = doorWidth * 0.8;\nconst windowHeight = doorHeight * 0.4;\nconst offset = (doorWidth - windowWidth) / 2;\n\nconst graphics = new Graphics()\n    // Draw the chimney\n    .moveTo(chimneyStartX, chimneyStartY)\n    .lineTo(chimneyStartX - chimneyTopOffset, chimneyStartY - chimneyHeight + chimneyDomeHeight)\n    .quadraticCurveTo(\n        chimneyStartX + chimneyBaseWidth / 2,\n        chimneyStartY - chimneyHeight - chimneyDomeHeight,\n        chimneyStartX + chimneyBaseWidth + chimneyTopOffset,\n        chimneyStartY - chimneyHeight + chimneyDomeHeight,\n    )\n    .lineTo(chimneyStartX + chimneyBaseWidth, chimneyStartY)\n    .fill({ color: 0x121212 })\n\n    // Draw the head front\n    .roundRect(\n        cabinWidth - frontRadius - cabinRadius,\n        -frontHeight,\n        frontWidth + frontRadius + cabinRadius,\n        frontHeight,\n        frontRadius,\n    )\n    .fill({ color: 0x7f3333 })\n\n    // Draw the cabin\n    .roundRect(0, -cabinHeight, cabinWidth, cabinHeight, cabinRadius)\n    .fill({ color: 0x725f19 })\n\n    // Draw the roof\n    .rect(-roofExcess / 2, cabinRadius - cabinHeight - roofHeight, cabinWidth + roofExcess, roofHeight)\n    .fill({ color: 0x52431c })\n\n    // Draw the door\n    .roundRect(doorStartX, doorStartY, doorWidth, doorHeight, cabinRadius)\n    .stroke({ color: 0x52431c, width: 3 })\n\n    // Draw the window\n    .roundRect(doorStartX + offset, doorStartY + offset, windowWidth, windowHeight, 10)\n    .fill({ color: 0x848484 });\n")),(0,o.kt)("h2",{id:"wheels"},"Wheels"),(0,o.kt)("p",null,"For the wheels, lets make a helper function that will instantiate individual wheel given a radius. This has been set up for you as the ",(0,o.kt)("inlineCode",{parentName:"p"},"createTrainWheel(radius)")," function."),(0,o.kt)("p",null,"Inside a wheel, we can split it further into parts as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Wheel base"),(0,o.kt)("li",{parentName:"ul"},"Tyre surrounding the base"),(0,o.kt)("li",{parentName:"ul"},"Spokes on the base")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const strokeThickness = radius / 3;\nconst innerRadius = radius - strokeThickness;\n\nreturn (\n    new Graphics()\n        .circle(0, 0, radius)\n        // Draw the wheel\n        .fill({ color: 0x848484 })\n        // Draw the tyre\n        .stroke({ color: 0x121212, width: strokeThickness, alignment: 1 })\n        // Draw the spokes\n        .rect(-strokeThickness / 2, -innerRadius, strokeThickness, innerRadius * 2)\n        .rect(-innerRadius, -strokeThickness / 2, innerRadius * 2, strokeThickness)\n        .fill({ color: 0x4f4f4f })\n);\n")),(0,o.kt)("p",null,"Then we can this helper function inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"createTrainHead()")," function to create the 3 wheels for the train head which include one larger wheel at the back and two standard sized ones in front."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const bigWheelRadius = 55;\nconst smallWheelRadius = 35;\nconst wheelGap = 5;\nconst wheelOffsetY = 5;\n\nconst backWheel = createTrainWheel(bigWheelRadius);\nconst midWheel = createTrainWheel(smallWheelRadius);\nconst frontWheel = createTrainWheel(smallWheelRadius);\n\nbackWheel.x = bigWheelRadius;\nbackWheel.y = wheelOffsetY;\nmidWheel.x = backWheel.x + bigWheelRadius + smallWheelRadius + wheelGap;\nmidWheel.y = backWheel.y + bigWheelRadius - smallWheelRadius;\nfrontWheel.x = midWheel.x + smallWheelRadius * 2 + wheelGap;\nfrontWheel.y = midWheel.y;\n")),(0,o.kt)("h2",{id:"combine-and-animate"},"Combine and Animate"),(0,o.kt)("p",null,"Now that we have the Graphics instance of the train head's body and its wheels, let add them all onto a wrapping container and then animate the spinning of the wheels before returning the container as the result. Notice here that we make the back wheel rotate proportionally slower like it logically should as it's bigger with more circumference to cover in a revolution."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const container = new Container();\n\ncontainer.addChild(graphics, backWheel, midWheel, frontWheel);\n\napp.ticker.add((time) =>\n{\n    const dr = time.deltaTime * 0.15;\n\n    backWheel.rotation += dr * (smallWheelRadius / bigWheelRadius);\n    midWheel.rotation += dr;\n    frontWheel.rotation += dr;\n});\n\nreturn container;\n")))}W.isMDXComponent=!0;const N={toc:[{value:"Assemble Train",id:"assemble-train",level:2}]};function H(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},N,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-train-carriage"},"Adding Train Carriage"),(0,o.kt)("p",null,"Accompanying the head, let's add a trailing carriage to complete a running train. Here we will be doing the same procedures as when we were building the head inside the new ",(0,o.kt)("inlineCode",{parentName:"p"},"createTrainCarriage()")," function. The carriage consists of 4 parts:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Container"),(0,o.kt)("li",{parentName:"ul"},"Top Edge"),(0,o.kt)("li",{parentName:"ul"},"Connectors"),(0,o.kt)("li",{parentName:"ul"},"Wheels")),(0,o.kt)("p",null,"We can re-use the ",(0,o.kt)("inlineCode",{parentName:"p"},"createTrainWheel(radius)")," function to create the two standard sized wheels which will be animated in the same manner as before."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const container = new Container();\n\nconst containerHeight = 125;\nconst containerWidth = 200;\nconst containerRadius = 15;\nconst edgeHeight = 25;\nconst edgeExcess = 20;\nconst connectorWidth = 30;\nconst connectorHeight = 10;\nconst connectorGap = 10;\nconst connectorOffsetY = 20;\n\nconst graphics = new Graphics()\n    // Draw the body\n    .roundRect(edgeExcess / 2, -containerHeight, containerWidth, containerHeight, containerRadius)\n    .fill({ color: 0x725f19 })\n\n    // Draw the top edge\n    .rect(0, containerRadius - containerHeight - edgeHeight, containerWidth + edgeExcess, edgeHeight)\n    .fill({ color: 0x52431c })\n\n    // Draw the connectors\n    .rect(containerWidth + edgeExcess / 2, -connectorOffsetY - connectorHeight, connectorWidth, connectorHeight)\n    .rect(\n        containerWidth + edgeExcess / 2,\n        -connectorOffsetY - connectorHeight * 2 - connectorGap,\n        connectorWidth,\n        connectorHeight,\n    )\n    .fill({ color: 0x121212 });\n\nconst wheelRadius = 35;\nconst wheelGap = 40;\nconst centerX = (containerWidth + edgeExcess) / 2;\nconst offsetX = wheelRadius + wheelGap / 2;\n\nconst backWheel = createTrainWheel(wheelRadius);\nconst frontWheel = createTrainWheel(wheelRadius);\n\nbackWheel.x = centerX - offsetX;\nfrontWheel.x = centerX + offsetX;\nfrontWheel.y = backWheel.y = 25;\n\ncontainer.addChild(graphics, backWheel, frontWheel);\n\napp.ticker.add((time) =>\n{\n    const dr = time.deltaTime * 0.15;\n\n    backWheel.rotation += dr;\n    frontWheel.rotation += dr;\n});\n\nreturn container;\n")),(0,o.kt)("h2",{id:"assemble-train"},"Assemble Train"),(0,o.kt)("p",null,"With the ",(0,o.kt)("inlineCode",{parentName:"p"},"createTrainHead()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"createTrainCarriage()")," functions completed, let's use them to create the sections, adding them to a wrapping container, offsetting the trailing carriage to be behind the train head. We can then top it up with a little bobble up and down to simulate shaking due to the travel along the track."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const head = createTrainHead();\nconst carriage = createTrainCarriage();\n\ncarriage.x = -carriage.width;\n\ntrainContainer.addChild(head, carriage);\napp.stage.addChild(trainContainer);\n\nconst scale = 0.75;\n\ntrainContainer.scale.set(scale);\ntrainContainer.x = app.screen.width / 2 - head.width / 2;\n\nlet elapsed = 0;\nconst shakeDistance = 3;\nconst baseY = app.screen.height - 35 - 55 * scale;\nconst speed = 0.5;\n\ntrainContainer.y = baseY;\n\napp.ticker.add((time) =>\n{\n    elapsed += time.deltaTime;\n    const offset = (Math.sin(elapsed * 0.5 * speed) * 0.5 + 0.5) * shakeDistance;\n\n    trainContainer.y = baseY + offset;\n});\n")),(0,o.kt)("p",null,"We have now successfully crafted a evening scene of a training moving through the landscape with just the Graphics API. But what's the point of having a chimney without any smoke!"))}H.isMDXComponent=!0;const M={toc:[{value:"Create Smoke Groups",id:"create-smoke-groups",level:2},{value:"Animate Smokes",id:"animate-smokes",level:2}]};function D(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},M,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-smokes"},"Adding Smokes"),(0,o.kt)("p",null,"For the final touch, let's create groups of smoke particles animating in from the train chimney and out off the screen."),(0,o.kt)("h2",{id:"create-smoke-groups"},"Create Smoke Groups"),(0,o.kt)("p",null,"First we need to create the individual groups of circular particles of varying size and position within the cluster, each group under a single Graphics instance. For the purpose of animation, we then assign a custom ",(0,o.kt)("inlineCode",{parentName:"p"},"tick")," property to each group which will be used to reference the percentage of the animation from the chimney to the disappearing point."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const groupCount = 5;\nconst particleCount = 7;\nconst groups = [];\nconst baseX = trainContainer.x + 170;\nconst baseY = trainContainer.y - 120;\n\nfor (let index = 0; index < groupCount; index++)\n{\n    const smokeGroup = new Graphics();\n\n    for (let i = 0; i < particleCount; i++)\n    {\n        const radius = 20 + Math.random() * 20;\n        const x = (Math.random() * 2 - 1) * 40;\n        const y = (Math.random() * 2 - 1) * 40;\n\n        smokeGroup.circle(x, y, radius);\n    }\n\n    smokeGroup.fill({ color: 0xc9c9c9, alpha: 0.5 });\n\n    smokeGroup.x = baseX;\n    smokeGroup.y = baseY;\n    smokeGroup.tick = index * (1 / groupCount);\n\n    groups.push(smokeGroup);\n}\n")),(0,o.kt)("h2",{id:"animate-smokes"},"Animate Smokes"),(0,o.kt)("p",null,"As you can see, we previously offset the ",(0,o.kt)("inlineCode",{parentName:"p"},"tick")," value on each group initially to distribute them out so that it illustrates the constant line of smokes coming out from the chimney. We then use the same technique of using the application's ticker for the animation, incrementing the ",(0,o.kt)("inlineCode",{parentName:"p"},"tick")," value on all groups which is then used to calculate the position and scale of each. The value is modulated so that it goes back to the starting point when it finishes at the disappearing point, ie. the value will loop infinitely from 0 -> 1."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"app.ticker.add((time) =>\n{\n    const dt = time.deltaTime * 0.01;\n\n    groups.forEach((group) =>\n    {\n        group.tick = (group.tick + dt) % 1;\n        group.x = baseX - Math.pow(group.tick, 2) * 400;\n        group.y = baseY - group.tick * 200;\n        group.scale.set(Math.pow(group.tick, 0.75));\n    });\n});\n")),(0,o.kt)("p",null,"And that is a wrap!"))}D.isMDXComponent=!0;const I={toc:[]};function B(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},I,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"you-did-it"},"You did it!"),(0,o.kt)("p",null,"Congratulations, hope you enjoyed the journey! Now you are an expert on the Graphics API. Make sure to explore other features that the API has to offer on the official ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.Graphics.html"},"documentation"),", like the ability to cut shapes out from existing ones, advance lines and curves, using gradients or textures for fill and stroke - just to list a few."),(0,o.kt)("p",null,"Feel free to head back to the gallery and explore other tutorials."))}B.isMDXComponent=!0;const R="import { Application } from 'pixi.js';\nimport { addStars } from './addStars';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n})();\n",E="import { Application } from 'pixi.js';\nimport { addStars } from './addStars';\nimport { addMoon } from './addMoon';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n    addMoon(app);\n})();\n",P="import { Application } from 'pixi.js';\nimport { addStars } from './addStars';\nimport { addMoon } from './addMoon';\nimport { addMountains } from './addMountains';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n    addMoon(app);\n    addMountains(app);\n})();\n",X="import { Application } from 'pixi.js';\nimport { addStars } from './addStars';\nimport { addMoon } from './addMoon';\nimport { addMountains } from './addMountains';\nimport { addTrees } from './addTrees';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n    addMoon(app);\n    addMountains(app);\n    addTrees(app);\n})();\n",G="import { Application } from 'pixi.js';\nimport { addStars } from './addStars';\nimport { addMoon } from './addMoon';\nimport { addMountains } from './addMountains';\nimport { addTrees } from './addTrees';\nimport { addGround } from './addGround';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n    addMoon(app);\n    addMountains(app);\n    addTrees(app);\n    addGround(app);\n})();\n",O="import { Application, Container } from 'pixi.js';\nimport { addStars } from './addStars';\nimport { addMoon } from './addMoon';\nimport { addMountains } from './addMountains';\nimport { addTrees } from './addTrees';\nimport { addGround } from './addGround';\nimport { addTrain } from './addTrain';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Create a container to hold all the train parts.\nconst trainContainer = new Container();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n    addMoon(app);\n    addMountains(app);\n    addTrees(app);\n    addGround(app);\n    addTrain(app, trainContainer);\n})();\n",L="import { Application, Container } from 'pixi.js';\nimport { addStars } from './addStars';\nimport { addMoon } from './addMoon';\nimport { addMountains } from './addMountains';\nimport { addTrees } from './addTrees';\nimport { addGround } from './addGround';\nimport { addTrain } from './addTrain';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Create a container to hold all the train parts.\nconst trainContainer = new Container();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n    addMoon(app);\n    addMountains(app);\n    addTrees(app);\n    addGround(app);\n    addTrain(app, trainContainer);\n})();\n",F="import { Application, Container } from 'pixi.js';\nimport { addStars } from './addStars';\nimport { addMoon } from './addMoon';\nimport { addMountains } from './addMountains';\nimport { addTrees } from './addTrees';\nimport { addGround } from './addGround';\nimport { addTrain } from './addTrain';\nimport { addSmokes } from './addSmokes';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Create a container to hold all the train parts.\nconst trainContainer = new Container();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n    addMoon(app);\n    addMountains(app);\n    addTrees(app);\n    addGround(app);\n    addTrain(app, trainContainer);\n    addSmokes(app, trainContainer);\n})();\n",z="import { Graphics } from 'pixi.js';\n\nexport function addStars(app)\n{\n    const starCount = 20;\n\n    // Create a graphics object to hold all the stars.\n    const graphics = new Graphics();\n\n    for (let index = 0; index < starCount; index++)\n    {\n        // Randomize the position, radius, and rotation of each star.\n        const x = (index * 0.78695 * app.screen.width) % app.screen.width;\n        const y = (index * 0.9382 * app.screen.height) % app.screen.height;\n        const radius = 2 + Math.random() * 3;\n        const rotation = Math.random() * Math.PI * 2;\n\n        // Draw the star onto the graphics object.\n        graphics.star(x, y, 5, radius, 0, rotation).fill({ color: 0xffdf00, alpha: radius / 5 });\n    }\n\n    // Add the stars to the stage.\n    app.stage.addChild(graphics);\n}\n",Y='<svg width="111" height="126" viewBox="0 0 111 126" fill="none" xmlns="http://www.w3.org/2000/svg">\n    <path fill-rule="evenodd" clip-rule="evenodd"\n        d="M9.99794 104.751C44.7207 104.751 72.869 76.6028 72.869 41.8801C72.869 25.9516 66.9455\n        11.4065 57.1812 0.327637C87.3034 4.98731 110.363 31.0291 110.363 62.4566C110.363 97.1793\n        82.2144 125.328 47.4917 125.328C28.6975 125.328 11.8294 117.081 0.308472 104.009C3.46679\n        104.498 6.70276 104.751 9.99794 104.751Z" fill="#FFDF00"/>\n    <path fill-rule="evenodd" clip-rule="evenodd"\n        d="M57.4922 0.682129C75.7709 10.9731 88 29.7256 88 51.1529C88 83.6533 59.8656 110 25.16\n        110C16.9934 110 9.19067 108.541 2.03273 105.887C1.44552 105.272 0.870627 104.646 0.308472\n        104.008C3.46679 104.497 6.70276 104.75 9.99794 104.75C44.7207 104.75 72.869 76.6018 72.869\n        41.8791C72.869 26.1203 67.0711 11.7158 57.4922 0.682129Z" fill="#DEC61A"/>\n</svg>',J="import { Graphics } from 'pixi.js';\nimport moonSvg from './moon.svg';\n\nexport function addMoon(app)\n{\n    // Create a moon graphics object from an SVG code.\n    const graphics = new Graphics().svg(moonSvg);\n\n    // Position the moon.\n    graphics.x = app.screen.width / 2 + 100;\n    graphics.y = app.screen.height / 8;\n\n    // Add the moon to the stage.\n    app.stage.addChild(graphics);\n}\n",_="import { Graphics } from 'pixi.js';\n\nexport function addMountains(app)\n{\n    // Create two mountain groups where one will be on the screen and the other will be off screen.\n    // When the first group moves off screen, it will be moved to the right of the second group.\n    const group1 = createMountainGroup(app);\n    const group2 = createMountainGroup(app);\n\n    // Position the 2nd group off the screen to the right.\n    group2.x = app.screen.width;\n\n    // Add the mountain groups to the stage.\n    app.stage.addChild(group1, group2);\n\n    // Animate the mountain groups\n    app.ticker.add((time) =>\n    {\n        // Calculate the amount of distance to move the mountain groups per tick.\n        const dx = time.deltaTime * 0.5;\n\n        // Move the mountain groups leftwards.\n        group1.x -= dx;\n        group2.x -= dx;\n\n        // Reposition the mountain groups when they move off screen.\n        if (group1.x <= -app.screen.width)\n        {\n            group1.x += app.screen.width * 2;\n        }\n        if (group2.x <= -app.screen.width)\n        {\n            group2.x += app.screen.width * 2;\n        }\n    });\n}\n\nfunction createMountainGroup(app)\n{\n    // Create a graphics object to hold all the mountains in a group.\n    const graphics = new Graphics();\n\n    // Width of all the mountains.\n    const width = app.screen.width / 2;\n\n    // Starting point on the y-axis of all the mountains.\n    // This is the bottom of the screen.\n    const startY = app.screen.height;\n\n    // Start point on the x-axis of the individual mountain.\n    const startXLeft = 0;\n    const startXMiddle = Number(app.screen.width) / 4;\n    const startXRight = app.screen.width / 2;\n\n    // Height of the individual mountain.\n    const heightLeft = app.screen.height / 2;\n    const heightMiddle = (app.screen.height * 4) / 5;\n    const heightRight = (app.screen.height * 2) / 3;\n\n    // Color of the individual mountain.\n    const colorLeft = 0xc1c0c2;\n    const colorMiddle = 0x7e818f;\n    const colorRight = 0x8c919f;\n\n    graphics\n        // Draw the middle mountain\n        .moveTo(startXMiddle, startY)\n        .bezierCurveTo(\n            startXMiddle + width / 2,\n            startY - heightMiddle,\n            startXMiddle + width / 2,\n            startY - heightMiddle,\n            startXMiddle + width,\n            startY,\n        )\n        .fill({ color: colorMiddle })\n\n        // Draw the left mountain\n        .moveTo(startXLeft, startY)\n        .bezierCurveTo(\n            startXLeft + width / 2,\n            startY - heightLeft,\n            startXLeft + width / 2,\n            startY - heightLeft,\n            startXLeft + width,\n            startY,\n        )\n        .fill({ color: colorLeft })\n\n        // Draw the right mountain\n        .moveTo(startXRight, startY)\n        .bezierCurveTo(\n            startXRight + width / 2,\n            startY - heightRight,\n            startXRight + width / 2,\n            startY - heightRight,\n            startXRight + width,\n            startY,\n        )\n        .fill({ color: colorRight });\n\n    return graphics;\n}\n",U="import { Graphics } from 'pixi.js';\n\nexport function addTrees(app)\n{\n    // Width of each tree.\n    const treeWidth = 200;\n\n    // Position of the base of the trees on the y-axis.\n    const y = app.screen.height - 20;\n\n    // Spacing between each tree.\n    const spacing = 15;\n\n    // Calculate the number of trees needed to fill the screen horizontally.\n    const count = app.screen.width / (treeWidth + spacing) + 1;\n\n    // Create an array to store all the trees.\n    const trees = [];\n\n    for (let index = 0; index < count; index++)\n    {\n        // Randomize the height of each tree within a constrained range.\n        const treeHeight = 225 + Math.random() * 50;\n\n        // Create a tree instance.\n        const tree = createTree(treeWidth, treeHeight);\n\n        // Initially position the tree.\n        tree.x = index * (treeWidth + spacing);\n        tree.y = y;\n\n        // Add the tree to the stage and the reference array.\n        app.stage.addChild(tree);\n        trees.push(tree);\n    }\n\n    // Animate the trees.\n    app.ticker.add((time) =>\n    {\n        // Calculate the amount of distance to move the trees per tick.\n        const dx = time.deltaTime * 3;\n\n        trees.forEach((tree) =>\n        {\n            // Move the trees leftwards.\n            tree.x -= dx;\n\n            // Reposition the trees when they move off screen.\n            if (tree.x <= -(treeWidth / 2 + spacing))\n            {\n                tree.x += count * (treeWidth + spacing) + spacing * 3;\n            }\n        });\n    });\n}\n\nfunction createTree(width, height)\n{\n    // Define the dimensions of the tree trunk.\n    const trunkWidth = 30;\n    const trunkHeight = height / 4;\n\n    // Define the dimensions and parameters for the tree crown layers.\n    const crownHeight = height - trunkHeight;\n    const crownLevels = 4;\n    const crownLevelHeight = crownHeight / crownLevels;\n    const crownWidthIncrement = width / crownLevels;\n\n    // Define the colors of the parts.\n    const crownColor = 0x264d3d;\n    const trunkColor = 0x563929;\n\n    const graphics = new Graphics()\n        // Draw the trunk.\n        .rect(-trunkWidth / 2, -trunkHeight, trunkWidth, trunkHeight)\n        .fill({ color: trunkColor });\n\n    for (let index = 0; index < crownLevels; index++)\n    {\n        const y = -trunkHeight - crownLevelHeight * index;\n        const levelWidth = width - crownWidthIncrement * index;\n        const offset = index < crownLevels - 1 ? crownLevelHeight / 2 : 0;\n\n        // Draw a crown layer.\n        graphics\n            .moveTo(-levelWidth / 2, y)\n            .lineTo(0, y - crownLevelHeight - offset)\n            .lineTo(levelWidth / 2, y)\n            .fill({ color: crownColor });\n    }\n\n    return graphics;\n}\n",Z="import { Graphics } from 'pixi.js';\n\nexport function addGround(app)\n{\n    const width = app.screen.width;\n\n    // Create and draw the bottom ground graphic.\n    const groundHeight = 20;\n    const groundY = app.screen.height;\n    const ground = new Graphics().rect(0, groundY - groundHeight, width, groundHeight).fill({ color: 0xdddddd });\n\n    // Add the ground to the stage.\n    app.stage.addChild(ground);\n\n    // Define the total height of the track. Both the planks and the rail layers.\n    const trackHeight = 15;\n\n    // Define the dimensions and parameters for the planks.\n    const plankWidth = 50;\n    const plankHeight = trackHeight / 2;\n    const plankGap = 20;\n    const plankCount = width / (plankWidth + plankGap) + 1;\n    const plankY = groundY - groundHeight;\n\n    // Create an array to store all the planks.\n    const planks = [];\n\n    for (let index = 0; index < plankCount; index++)\n    {\n        // Create and draw a plank graphic.\n        const plank = new Graphics().rect(0, plankY - plankHeight, plankWidth, plankHeight).fill({ color: 0x241811 });\n\n        // Position the plank to distribute it across the screen.\n        plank.x = index * (plankWidth + plankGap);\n\n        // Add the plank to the stage and the reference array.\n        app.stage.addChild(plank);\n        planks.push(plank);\n    }\n\n    // Create and draw the rail strip graphic.\n    const railHeight = trackHeight / 2;\n    const railY = plankY - plankHeight;\n    const rail = new Graphics().rect(0, railY - railHeight, width, railHeight).fill({ color: 0x5c5c5c });\n\n    // Add the rail to the stage.\n    app.stage.addChild(rail);\n\n    // Animate just the planks to simulate the passing of the ground.\n    // Since the rail and the ground are uniform strips, they do not need to be animated.\n    app.ticker.add((time) =>\n    {\n        // Calculate the amount of distance to move the planks per tick.\n        const dx = time.deltaTime * 6;\n\n        planks.forEach((plank) =>\n        {\n            // Move the planks leftwards.\n            plank.x -= dx;\n\n            // Reposition the planks when they move off screen.\n            if (plank.x <= -(plankWidth + plankGap))\n            {\n                plank.x += plankCount * (plankWidth + plankGap) + plankGap * 1.5;\n            }\n        });\n    });\n}\n",q="import { Container, Graphics } from 'pixi.js';\n\nexport function addTrain(app, container)\n{\n    const head = createTrainHead(app);\n    const carriage = createTrainCarriage(app);\n\n    // Position the carriage behind the head.\n    carriage.x = -carriage.width;\n\n    // Add the head and the carriage to the train container.\n    container.addChild(head, carriage);\n\n    // Add the train container to the stage.\n    app.stage.addChild(container);\n\n    const scale = 0.75;\n\n    // Adjust the scaling of the train.\n    container.scale.set(scale);\n\n    // Position the train on the x-axis, taking into account the variety of screen width.\n    // To keep the train as the main focus, the train is offset slightly to the left of the screen center.\n    container.x = app.screen.width / 2 - head.width / 2;\n\n    // Define animation parameters.\n    let elapsed = 0;\n    const shakeDistance = 3;\n    const baseY = app.screen.height - 35 - 55 * scale;\n    const speed = 0.5;\n\n    // Initially position the train on the y-axis.\n    container.y = baseY;\n\n    // Animate the train - bobbing it up and down a tiny bit on the track.\n    app.ticker.add((time) =>\n    {\n        elapsed += time.deltaTime;\n        const offset = (Math.sin(elapsed * 0.5 * speed) * 0.5 + 0.5) * shakeDistance;\n\n        container.y = baseY + offset;\n    });\n}\n\nfunction createTrainHead(app)\n{\n    // Create a container to hold all the train head parts.\n    const container = new Container();\n\n    // Define the dimensions of the head front.\n    const frontHeight = 100;\n    const frontWidth = 140;\n    const frontRadius = frontHeight / 2;\n\n    // Define the dimensions of the cabin.\n    const cabinHeight = 200;\n    const cabinWidth = 150;\n    const cabinRadius = 15;\n\n    // Define the dimensions of the chimney.\n    const chimneyBaseWidth = 30;\n    const chimneyTopWidth = 50;\n    const chimneyHeight = 70;\n    const chimneyDomeHeight = 25;\n    const chimneyTopOffset = (chimneyTopWidth - chimneyBaseWidth) / 2;\n    const chimneyStartX = cabinWidth + frontWidth - frontRadius - chimneyBaseWidth;\n    const chimneyStartY = -frontHeight;\n\n    // Define the dimensions of the roof.\n    const roofHeight = 25;\n    const roofExcess = 20;\n\n    // Define the dimensions of the door.\n    const doorWidth = cabinWidth * 0.7;\n    const doorHeight = cabinHeight * 0.7;\n    const doorStartX = (cabinWidth - doorWidth) * 0.5;\n    const doorStartY = -(cabinHeight - doorHeight) * 0.5 - doorHeight;\n\n    // Define the dimensions of the window.\n    const windowWidth = doorWidth * 0.8;\n    const windowHeight = doorHeight * 0.4;\n    const offset = (doorWidth - windowWidth) / 2;\n\n    const graphics = new Graphics()\n        // Draw the chimney\n        .moveTo(chimneyStartX, chimneyStartY)\n        .lineTo(chimneyStartX - chimneyTopOffset, chimneyStartY - chimneyHeight + chimneyDomeHeight)\n        .quadraticCurveTo(\n            chimneyStartX + chimneyBaseWidth / 2,\n            chimneyStartY - chimneyHeight - chimneyDomeHeight,\n            chimneyStartX + chimneyBaseWidth + chimneyTopOffset,\n            chimneyStartY - chimneyHeight + chimneyDomeHeight,\n        )\n        .lineTo(chimneyStartX + chimneyBaseWidth, chimneyStartY)\n        .fill({ color: 0x121212 })\n\n        // Draw the head front\n        .roundRect(\n            cabinWidth - frontRadius - cabinRadius,\n            -frontHeight,\n            frontWidth + frontRadius + cabinRadius,\n            frontHeight,\n            frontRadius,\n        )\n        .fill({ color: 0x7f3333 })\n\n        // Draw the cabin\n        .roundRect(0, -cabinHeight, cabinWidth, cabinHeight, cabinRadius)\n        .fill({ color: 0x725f19 })\n\n        // Draw the roof\n        .rect(-roofExcess / 2, cabinRadius - cabinHeight - roofHeight, cabinWidth + roofExcess, roofHeight)\n        .fill({ color: 0x52431c })\n\n        // Draw the door\n        .roundRect(doorStartX, doorStartY, doorWidth, doorHeight, cabinRadius)\n        .stroke({ color: 0x52431c, width: 3 })\n\n        // Draw the window\n        .roundRect(doorStartX + offset, doorStartY + offset, windowWidth, windowHeight, 10)\n        .fill({ color: 0x848484 });\n\n    // Define the dimensions of the wheels.\n    const bigWheelRadius = 55;\n    const smallWheelRadius = 35;\n    const wheelGap = 5;\n    const wheelOffsetY = 5;\n\n    // Create all the wheels.\n    const backWheel = createTrainWheel(bigWheelRadius);\n    const midWheel = createTrainWheel(smallWheelRadius);\n    const frontWheel = createTrainWheel(smallWheelRadius);\n\n    // Position the wheels.\n    backWheel.x = bigWheelRadius;\n    backWheel.y = wheelOffsetY;\n    midWheel.x = backWheel.x + bigWheelRadius + smallWheelRadius + wheelGap;\n    midWheel.y = backWheel.y + bigWheelRadius - smallWheelRadius;\n    frontWheel.x = midWheel.x + smallWheelRadius * 2 + wheelGap;\n    frontWheel.y = midWheel.y;\n\n    // Add all the parts to the container.\n    container.addChild(graphics, backWheel, midWheel, frontWheel);\n\n    // Animate the wheels - making the big wheel rotate proportionally slower than the small wheels.\n    app.ticker.add((time) =>\n    {\n        const dr = time.deltaTime * 0.15;\n\n        backWheel.rotation += dr * (smallWheelRadius / bigWheelRadius);\n        midWheel.rotation += dr;\n        frontWheel.rotation += dr;\n    });\n\n    return container;\n}\n\nfunction createTrainCarriage(app)\n{\n    // Create a container to hold all the train carriage parts.\n    const container = new Container();\n\n    // Define the dimensions of the carriage parts.\n    const containerHeight = 125;\n    const containerWidth = 200;\n    const containerRadius = 15;\n    const edgeHeight = 25;\n    const edgeExcess = 20;\n    const connectorWidth = 30;\n    const connectorHeight = 10;\n    const connectorGap = 10;\n    const connectorOffsetY = 20;\n\n    const graphics = new Graphics()\n        // Draw the body\n        .roundRect(edgeExcess / 2, -containerHeight, containerWidth, containerHeight, containerRadius)\n        .fill({ color: 0x725f19 })\n\n        // Draw the top edge\n        .rect(0, containerRadius - containerHeight - edgeHeight, containerWidth + edgeExcess, edgeHeight)\n        .fill({ color: 0x52431c })\n\n        // Draw the connectors\n        .rect(containerWidth + edgeExcess / 2, -connectorOffsetY - connectorHeight, connectorWidth, connectorHeight)\n        .rect(\n            containerWidth + edgeExcess / 2,\n            -connectorOffsetY - connectorHeight * 2 - connectorGap,\n            connectorWidth,\n            connectorHeight,\n        )\n        .fill({ color: 0x121212 });\n\n    // Define the dimensions of the wheels.\n    const wheelRadius = 35;\n    const wheelGap = 40;\n    const centerX = (containerWidth + edgeExcess) / 2;\n    const offsetX = wheelRadius + wheelGap / 2;\n\n    // Create the wheels.\n    const backWheel = createTrainWheel(wheelRadius);\n    const frontWheel = createTrainWheel(wheelRadius);\n\n    // Position the wheels.\n    backWheel.x = centerX - offsetX;\n    frontWheel.x = centerX + offsetX;\n    frontWheel.y = backWheel.y = 25;\n\n    // Add all the parts to the container.\n    container.addChild(graphics, backWheel, frontWheel);\n\n    // Animate the wheels.\n    app.ticker.add((time) =>\n    {\n        const dr = time.deltaTime * 0.15;\n\n        backWheel.rotation += dr;\n        frontWheel.rotation += dr;\n    });\n\n    return container;\n}\n\nfunction createTrainWheel(radius)\n{\n    // Define the dimensions of the wheel.\n    const strokeThickness = radius / 3;\n    const innerRadius = radius - strokeThickness;\n\n    return (\n        new Graphics()\n            .circle(0, 0, radius)\n            // Draw the wheel\n            .fill({ color: 0x848484 })\n            // Draw the tyre\n            .stroke({ color: 0x121212, width: strokeThickness, alignment: 1 })\n            // Draw the spokes\n            .rect(-strokeThickness / 2, -innerRadius, strokeThickness, innerRadius * 2)\n            .rect(-innerRadius, -strokeThickness / 2, innerRadius * 2, strokeThickness)\n            .fill({ color: 0x4f4f4f })\n    );\n}\n",V="import { Graphics } from 'pixi.js';\n\nexport function addSmokes(app, train)\n{\n    const groupCount = 5;\n    const particleCount = 7;\n\n    // Create an array to store all the smoke groups.\n    const groups = [];\n\n    // Define the emitter position based on the train's position.\n    const baseX = train.x + 170;\n    const baseY = train.y - 120;\n\n    for (let index = 0; index < groupCount; index++)\n    {\n        const smokeGroup = new Graphics();\n\n        for (let i = 0; i < particleCount; i++)\n        {\n            // Randomize the position and radius of each particle.\n            const radius = 20 + Math.random() * 20;\n            const x = (Math.random() * 2 - 1) * 40;\n            const y = (Math.random() * 2 - 1) * 40;\n\n            // Draw a smoke particle.\n            smokeGroup.circle(x, y, radius);\n        }\n\n        // Fill the smoke group with gray color.\n        smokeGroup.fill({ color: 0xc9c9c9 });\n\n        // Position the smoke group.\n        smokeGroup.x = baseX;\n        smokeGroup.y = baseY;\n\n        // Add a tick custom property to the smoke group for storing the animation progress ratio.\n        smokeGroup.tick = index * (1 / groupCount);\n\n        // Add the smoke group to the stage and the reference array.\n        app.stage.addChild(smokeGroup);\n        groups.push(smokeGroup);\n    }\n\n    // Animate the smoke groups.\n    app.ticker.add((time) =>\n    {\n        // Calculate the change in amount of animation progress ratio per tick.\n        const dt = time.deltaTime * 0.01;\n\n        groups.forEach((group) =>\n        {\n            // Update the animation progress ratio.\n            group.tick = (group.tick + dt) % 1;\n\n            // Update the position and scale of the smoke group based on the animation progress ratio.\n            group.x = baseX - Math.pow(group.tick, 2) * 400;\n            group.y = baseY - group.tick * 200;\n            group.scale.set(Math.pow(group.tick, 0.75));\n            group.alpha = 1 - Math.pow(group.tick, 0.5);\n        });\n    });\n}\n",K=[{header:"Introduction",Content:f,code:"import { Application } from 'pixi.js';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n})();\n"},{header:"Adding Stars",Content:y,code:{index:R,"src/addStars.js*":"import { Graphics } from 'pixi.js';\n\nexport function addStars(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:R,"src/addStars.js*":z}},{header:"Adding Moon",Content:b,code:{index:E,"src/addStars.js!":z,"src/addMoon.js*":"import { Graphics } from 'pixi.js';\n\nexport function addMoon(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n","src/moon.svg":Y},completedCode:{index:E,"src/addStars.js!":z,"src/addMoon.js*":J,"src/moon.svg":Y}},{header:"Adding Mountains",Content:v,code:{index:P,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js*":"import { Graphics } from 'pixi.js';\n\nexport function addMountains(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n\nfunction createMountainGroup(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:P,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js*":_}},{header:"Adding Trees",Content:T,code:{index:X,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js*":"import { Graphics } from 'pixi.js';\n\nexport function addTrees(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n\nfunction createTree(width, height)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:X,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js*":U}},{header:"Adding Ground",Content:j,code:{index:G,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js!":U,"src/addGround.js*":"import { Graphics } from 'pixi.js';\n\nexport function addGround(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:G,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js!":U,"src/addGround.js*":Z}},{header:"Adding Train Head",Content:W,code:{index:O,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js!":U,"src/addGround.js!":Z,"src/addTrain.js*":"import { Container, Graphics } from 'pixi.js';\n\nexport function addTrain(app, container)\n{\n    const head = createTrainHead();\n\n    /** -- INSERT CODE HERE -- */\n}\n\nfunction createTrainHead(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n\nfunction createTrainWheel(radius)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:O,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js!":U,"src/addGround.js!":Z,"src/addTrain.js*":"import { Container, Graphics } from 'pixi.js';\n\nexport function addTrain(app, container)\n{\n    const head = createTrainHead(app);\n\n    // Add the head to the train container.\n    container.addChild(head);\n\n    // Add the train container to the stage.\n    app.stage.addChild(container);\n\n    const scale = 0.75;\n\n    // Adjust the scaling of the train.\n    container.scale.set(scale);\n\n    // Position the train, taking into account the variety of screen width.\n    // To keep the train as the main focus, the train is offset slightly to the left of the screen center.\n    container.x = app.screen.width / 2 - head.width / 2;\n    container.y = app.screen.height - 35 - 55 * scale;\n}\n\nfunction createTrainHead(app)\n{\n    // Create a container to hold all the train head parts.\n    const container = new Container();\n\n    // Define the dimensions of the head front.\n    const frontHeight = 100;\n    const frontWidth = 140;\n    const frontRadius = frontHeight / 2;\n\n    // Define the dimensions of the cabin.\n    const cabinHeight = 200;\n    const cabinWidth = 150;\n    const cabinRadius = 15;\n\n    // Define the dimensions of the chimney.\n    const chimneyBaseWidth = 30;\n    const chimneyTopWidth = 50;\n    const chimneyHeight = 70;\n    const chimneyDomeHeight = 25;\n    const chimneyTopOffset = (chimneyTopWidth - chimneyBaseWidth) / 2;\n    const chimneyStartX = cabinWidth + frontWidth - frontRadius - chimneyBaseWidth;\n    const chimneyStartY = -frontHeight;\n\n    // Define the dimensions of the roof.\n    const roofHeight = 25;\n    const roofExcess = 20;\n\n    // Define the dimensions of the door.\n    const doorWidth = cabinWidth * 0.7;\n    const doorHeight = cabinHeight * 0.7;\n    const doorStartX = (cabinWidth - doorWidth) * 0.5;\n    const doorStartY = -(cabinHeight - doorHeight) * 0.5 - doorHeight;\n\n    // Define the dimensions of the window.\n    const windowWidth = doorWidth * 0.8;\n    const windowHeight = doorHeight * 0.4;\n    const offset = (doorWidth - windowWidth) / 2;\n\n    const graphics = new Graphics()\n        // Draw the chimney\n        .moveTo(chimneyStartX, chimneyStartY)\n        .lineTo(chimneyStartX - chimneyTopOffset, chimneyStartY - chimneyHeight + chimneyDomeHeight)\n        .quadraticCurveTo(\n            chimneyStartX + chimneyBaseWidth / 2,\n            chimneyStartY - chimneyHeight - chimneyDomeHeight,\n            chimneyStartX + chimneyBaseWidth + chimneyTopOffset,\n            chimneyStartY - chimneyHeight + chimneyDomeHeight,\n        )\n        .lineTo(chimneyStartX + chimneyBaseWidth, chimneyStartY)\n        .fill({ color: 0x121212 })\n\n        // Draw the head front\n        .roundRect(\n            cabinWidth - frontRadius - cabinRadius,\n            -frontHeight,\n            frontWidth + frontRadius + cabinRadius,\n            frontHeight,\n            frontRadius,\n        )\n        .fill({ color: 0x7f3333 })\n\n        // Draw the cabin\n        .roundRect(0, -cabinHeight, cabinWidth, cabinHeight, cabinRadius)\n        .fill({ color: 0x725f19 })\n\n        // Draw the roof\n        .rect(-roofExcess / 2, cabinRadius - cabinHeight - roofHeight, cabinWidth + roofExcess, roofHeight)\n        .fill({ color: 0x52431c })\n\n        // Draw the door\n        .roundRect(doorStartX, doorStartY, doorWidth, doorHeight, cabinRadius)\n        .stroke({ color: 0x52431c, width: 3 })\n\n        // Draw the window\n        .roundRect(doorStartX + offset, doorStartY + offset, windowWidth, windowHeight, 10)\n        .fill({ color: 0x848484 });\n\n    // Define the dimensions of the wheels.\n    const bigWheelRadius = 55;\n    const smallWheelRadius = 35;\n    const wheelGap = 5;\n    const wheelOffsetY = 5;\n\n    // Create all the wheels.\n    const backWheel = createTrainWheel(bigWheelRadius);\n    const midWheel = createTrainWheel(smallWheelRadius);\n    const frontWheel = createTrainWheel(smallWheelRadius);\n\n    // Position the wheels.\n    backWheel.x = bigWheelRadius;\n    backWheel.y = wheelOffsetY;\n    midWheel.x = backWheel.x + bigWheelRadius + smallWheelRadius + wheelGap;\n    midWheel.y = backWheel.y + bigWheelRadius - smallWheelRadius;\n    frontWheel.x = midWheel.x + smallWheelRadius * 2 + wheelGap;\n    frontWheel.y = midWheel.y;\n\n    // Add all the parts to the container.\n    container.addChild(graphics, backWheel, midWheel, frontWheel);\n\n    // Animate the wheels - making the big wheel rotate proportionally slower than the small wheels.\n    app.ticker.add((time) =>\n    {\n        const dr = time.deltaTime * 0.15;\n\n        backWheel.rotation += dr * (smallWheelRadius / bigWheelRadius);\n        midWheel.rotation += dr;\n        frontWheel.rotation += dr;\n    });\n\n    return container;\n}\n\nfunction createTrainWheel(radius)\n{\n    // Define the dimensions of the wheel.\n    const strokeThickness = radius / 3;\n    const innerRadius = radius - strokeThickness;\n\n    return (\n        new Graphics()\n            .circle(0, 0, radius)\n            // Draw the wheel\n            .fill({ color: 0x848484 })\n            // Draw the tyre\n            .stroke({ color: 0x121212, width: strokeThickness, alignment: 1 })\n            // Draw the spokes\n            .rect(-strokeThickness / 2, -innerRadius, strokeThickness, innerRadius * 2)\n            .rect(-innerRadius, -strokeThickness / 2, innerRadius * 2, strokeThickness)\n            .fill({ color: 0x4f4f4f })\n    );\n}\n"}},{header:"Adding Train Carriage",Content:H,code:{index:L,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js!":U,"src/addGround.js!":Z,"src/addTrain.js*":"import { Container, Graphics } from 'pixi.js';\n\nexport function addTrain(app, container)\n{\n    const head = createTrainHead(app);\n    const carriage = createTrainCarriage(app);\n\n    /** -- ADJUST CODE HERE -- */\n\n    // Add the head to the train container.\n    container.addChild(head);\n\n    // Add the train container to the stage.\n    app.stage.addChild(container);\n\n    const scale = 0.75;\n\n    // Adjust the scaling of the train.\n    container.scale.set(scale);\n\n    // Position the train, taking into account the variety of screen width.\n    // To keep the train as the main focus, the train is offset slightly to the left of the screen center.\n    container.x = app.screen.width / 2 - head.width / 2;\n    container.y = app.screen.height - 35 - 55 * scale;\n}\n\nfunction createTrainHead(app)\n{\n    // Create a container to hold all the train head parts.\n    const container = new Container();\n\n    // Define the dimensions of the head front.\n    const frontHeight = 100;\n    const frontWidth = 140;\n    const frontRadius = frontHeight / 2;\n\n    // Define the dimensions of the cabin.\n    const cabinHeight = 200;\n    const cabinWidth = 150;\n    const cabinRadius = 15;\n\n    // Define the dimensions of the chimney.\n    const chimneyBaseWidth = 30;\n    const chimneyTopWidth = 50;\n    const chimneyHeight = 70;\n    const chimneyDomeHeight = 25;\n    const chimneyTopOffset = (chimneyTopWidth - chimneyBaseWidth) / 2;\n    const chimneyStartX = cabinWidth + frontWidth - frontRadius - chimneyBaseWidth;\n    const chimneyStartY = -frontHeight;\n\n    // Define the dimensions of the roof.\n    const roofHeight = 25;\n    const roofExcess = 20;\n\n    // Define the dimensions of the door.\n    const doorWidth = cabinWidth * 0.7;\n    const doorHeight = cabinHeight * 0.7;\n    const doorStartX = (cabinWidth - doorWidth) * 0.5;\n    const doorStartY = -(cabinHeight - doorHeight) * 0.5 - doorHeight;\n\n    // Define the dimensions of the window.\n    const windowWidth = doorWidth * 0.8;\n    const windowHeight = doorHeight * 0.4;\n    const offset = (doorWidth - windowWidth) / 2;\n\n    const graphics = new Graphics()\n        // Draw the chimney\n        .moveTo(chimneyStartX, chimneyStartY)\n        .lineTo(chimneyStartX - chimneyTopOffset, chimneyStartY - chimneyHeight + chimneyDomeHeight)\n        .quadraticCurveTo(\n            chimneyStartX + chimneyBaseWidth / 2,\n            chimneyStartY - chimneyHeight - chimneyDomeHeight,\n            chimneyStartX + chimneyBaseWidth + chimneyTopOffset,\n            chimneyStartY - chimneyHeight + chimneyDomeHeight,\n        )\n        .lineTo(chimneyStartX + chimneyBaseWidth, chimneyStartY)\n        .fill({ color: 0x121212 })\n\n        // Draw the head front\n        .roundRect(\n            cabinWidth - frontRadius - cabinRadius,\n            -frontHeight,\n            frontWidth + frontRadius + cabinRadius,\n            frontHeight,\n            frontRadius,\n        )\n        .fill({ color: 0x7f3333 })\n\n        // Draw the cabin\n        .roundRect(0, -cabinHeight, cabinWidth, cabinHeight, cabinRadius)\n        .fill({ color: 0x725f19 })\n\n        // Draw the roof\n        .rect(-roofExcess / 2, cabinRadius - cabinHeight - roofHeight, cabinWidth + roofExcess, roofHeight)\n        .fill({ color: 0x52431c })\n\n        // Draw the door\n        .roundRect(doorStartX, doorStartY, doorWidth, doorHeight, cabinRadius)\n        .stroke({ color: 0x52431c, width: 3 })\n\n        // Draw the window\n        .roundRect(doorStartX + offset, doorStartY + offset, windowWidth, windowHeight, 10)\n        .fill({ color: 0x848484 });\n\n    // Define the dimensions of the wheels.\n    const bigWheelRadius = 55;\n    const smallWheelRadius = 35;\n    const wheelGap = 5;\n    const wheelOffsetY = 5;\n\n    // Create all the wheels.\n    const backWheel = createTrainWheel(bigWheelRadius);\n    const midWheel = createTrainWheel(smallWheelRadius);\n    const frontWheel = createTrainWheel(smallWheelRadius);\n\n    // Position the wheels.\n    backWheel.x = bigWheelRadius;\n    backWheel.y = wheelOffsetY;\n    midWheel.x = backWheel.x + bigWheelRadius + smallWheelRadius + wheelGap;\n    midWheel.y = backWheel.y + bigWheelRadius - smallWheelRadius;\n    frontWheel.x = midWheel.x + smallWheelRadius * 2 + wheelGap;\n    frontWheel.y = midWheel.y;\n\n    // Add all the parts to the container.\n    container.addChild(graphics, backWheel, midWheel, frontWheel);\n\n    // Animate the wheels - making the big wheel rotate proportionally slower than the small wheels.\n    app.ticker.add((time) =>\n    {\n        const dr = time.deltaTime * 0.15;\n\n        backWheel.rotation += dr * (smallWheelRadius / bigWheelRadius);\n        midWheel.rotation += dr;\n        frontWheel.rotation += dr;\n    });\n\n    return container;\n}\n\nfunction createTrainCarriage(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n\nfunction createTrainWheel(radius)\n{\n    // Define the dimensions of the wheel.\n    const strokeThickness = radius / 3;\n    const innerRadius = radius - strokeThickness;\n\n    return (\n        new Graphics()\n            .circle(0, 0, radius)\n            // Draw the wheel\n            .fill({ color: 0x848484 })\n            // Draw the tyre\n            .stroke({ color: 0x121212, width: strokeThickness, alignment: 1 })\n            // Draw the spokes\n            .rect(-strokeThickness / 2, -innerRadius, strokeThickness, innerRadius * 2)\n            .rect(-innerRadius, -strokeThickness / 2, innerRadius * 2, strokeThickness)\n            .fill({ color: 0x4f4f4f })\n    );\n}\n"},completedCode:{index:L,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js!":U,"src/addGround.js!":Z,"src/addTrain.js*":q}},{header:"Adding Smokes",Content:D,code:{index:F,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js!":U,"src/addGround.js!":Z,"src/addTrain.js!":q,"src/addSmokes.js*":"import { Graphics } from 'pixi.js';\n\nexport function addSmokes(app, train)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:F,"src/addStars.js!":z,"src/addMoon.js!":J,"src/moon.svg!":Y,"src/addMountains.js!":_,"src/addTrees.js!":U,"src/addGround.js!":Z,"src/addTrain.js!":q,"src/addSmokes.js*":V}},{header:"You did it!",Content:B,code:{index:"import { Application, Container } from 'pixi.js';\nimport { addStars } from './addStars';\nimport { addMoon } from './addMoon';\nimport { addMountains } from './addMountains';\nimport { addTrees } from './addTrees';\nimport { addGround } from './addGround';\nimport { addTrain } from './addTrain';\nimport { addSmokes } from './addSmokes';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Create a container to hold all the train parts.\nconst trainContainer = new Container();\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Intialize the application.\n    await app.init({ background: '#021f4b', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    addStars(app);\n    addMoon(app);\n    addMountains(app);\n    addTrees(app);\n    addGround(app);\n    addTrain(app, trainContainer);\n    addSmokes(app, trainContainer);\n})();\n","src/addStars.js":z,"src/addMoon.js":J,"src/moon.svg!":Y,"src/addMountains.js":_,"src/addTrees.js":U,"src/addGround.js":Z,"src/addTrain.js":q,"src/addSmokes.js":V}}],$={toc:[{value:"Application Setup",id:"application-setup",level:2},{value:"Preloading Assets",id:"preloading-assets",level:2}]};function Q(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},$,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"lets-make-a-pond"},"Let's make a pond!"),(0,o.kt)("p",null,"Welcome to the Fish Pond workshop!"),(0,o.kt)("p",null,"We are going to build a virtual pond and fill them with a number of colorful fishes. In the process, we will be learning about basic manipulation of ",(0,o.kt)("a",{parentName:"p",href:"/guides/components/sprites"},"Sprites"),", ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.TilingSprite.html"},"TilingSprite")," and Filter, specifically the ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.DisplacementFilter.html"},"Displacement Filter"),"."),(0,o.kt)("p",null,"Please go through the tutorial steps at your own pace and challenge yourself using the editor on the right hand side. Here PixiJS has already been included as guided under the ",(0,o.kt)("a",{parentName:"p",href:"/guides/basics/getting-started#loading-pixijs"},"Getting Started")," section. Let's start off by creation a PixiJS application, initialize it, add its canvas to the DOM, and preload the required assets ahead of the subsequent steps."),(0,o.kt)("p",null,"We will be using an asynchronous immediately invoked function expression (",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Glossary/IIFE"},"IIFE"),"), but you are free to switch to use promises instead."),(0,o.kt)("h2",{id:"application-setup"},"Application Setup"),(0,o.kt)("p",null,"Let's create the application outside of the IIFE just so that it can be referenced across other functions declared outside. The initialization and appending the application's canvas will be done from within the ",(0,o.kt)("inlineCode",{parentName:"p"},"setup")," function which is called inside the IIFE."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"async function setup()\n{\n    await app.init({ background: '#1099bb', resizeTo: window });\n    document.body.appendChild(app.canvas);\n}\n")),(0,o.kt)("h2",{id:"preloading-assets"},"Preloading Assets"),(0,o.kt)("p",null,"After the application setup, we will then preload all the textures required for the rest of the tutorial. Here we also provide aliases so that they can be intuitively referred to later on. This will be done inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"preload")," function which is also called inside the IIFE after the setup."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"async function preload()\n{\n    const assets = [\n        { alias: 'background', src: 'https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg' },\n        { alias: 'fish1', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish1.png' },\n        { alias: 'fish2', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish2.png' },\n        { alias: 'fish3', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish3.png' },\n        { alias: 'fish4', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish4.png' },\n        { alias: 'fish5', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish5.png' },\n        { alias: 'overlay', src: 'https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png' },\n        { alias: 'displacement', src: 'https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png' },\n    ];\n    await Assets.load(assets);\n}\n")),(0,o.kt)("p",null,"At this point, you should see the preview filled with an empty light blue background."),(0,o.kt)("p",null,"When you are ready, proceed to the next exercise using the ",(0,o.kt)("em",{parentName:"p"},"Next >")," button below, or feel free to skip to any exercise using the drop-down menu on the top right hand corner of the card."))}Q.isMDXComponent=!0;const ee={toc:[{value:"Create and Setup Background Sprite",id:"create-and-setup-background-sprite",level:2},{value:"Fit and Position Sprite",id:"fit-and-position-sprite",level:2}]};function ne(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},ee,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-a-background"},"Adding a Background"),(0,o.kt)("p",null,"Now lets fill the pond with some rocks and pebbles, shall we? Let's work inside the already prepared ",(0,o.kt)("inlineCode",{parentName:"p"},"addBackground")," function."),(0,o.kt)("h2",{id:"create-and-setup-background-sprite"},"Create and Setup Background Sprite"),(0,o.kt)("p",null,"We already preloaded the pond background asset as the alias 'background' so we can just simply create a sprite"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const background = Sprite.from('background');\n\nbackground.anchor.set(0.5);\n")),(0,o.kt)("h2",{id:"fit-and-position-sprite"},"Fit and Position Sprite"),(0,o.kt)("p",null,"Now we want the background sprite to fill the whole screen without any distortion so we will compare and fill the longer axis and then apply the same scale on the smaller axis for a uniform scaling."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"(Note: x1.2 scaling to the dimension is to overflow the screen slightly to compensate for the last's step distortion from post-processing)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"if (app.screen.width > app.screen.height)\n{\n    background.width = app.screen.width * 1.2;\n    background.scale.y = background.scale.x;\n}\nelse\n{\n    background.height = app.screen.height  * 1.2;\n    background.scale.x = background.scale.y;\n}\n")),(0,o.kt)("p",null,"When we manually set the width or height on a sprite, it will apply a scale on the corresponding axis depending on the width or height of the original texture. Hence, we can simply equalize the scale on both axes this way."),(0,o.kt)("p",null,"Then we simply position it at the center of the preview."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"background.x = app.screen.width / 2;\nbackground.y = app.screen.height / 2;\n")),(0,o.kt)("p",null,"We got a beautiful pond! Now let's proceed to add some fishes!"))}ne.isMDXComponent=!0;const te={toc:[{value:"Create and Setup Fish Sprites",id:"create-and-setup-fish-sprites",level:2},{value:"Animate Fishes",id:"animate-fishes",level:2}]};function ae(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},te,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-fishes"},"Adding Fishes"),(0,o.kt)("p",null,"What's a pond without the fishes, right? Let's use what we learn from the previous step to add some fish sprites to the scene as well. We will also animate them afterwards to give them life."),(0,o.kt)("h2",{id:"create-and-setup-fish-sprites"},"Create and Setup Fish Sprites"),(0,o.kt)("p",null,"Let's encapsulate all the following setup within the ",(0,o.kt)("inlineCode",{parentName:"p"},"addFishes")," function that has already been prepared for you. We begin by creating a container to hold all the fish sprites together and add it to the stage. This is a great practice for better separation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const fishContainer = new Container();\n\napp.stage.addChild(fishContainer);\n")),(0,o.kt)("p",null,"Then we declare some reference variables like how many fishes should there be in the pond and what are the fish types available. For the types, we refer to the 5 different fish assets we have preloaded earlier and made them into an array of aliases."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const fishCount = 20;\nconst fishAssets = ['fish1', 'fish2', 'fish3', 'fish4', 'fish5'];\n")),(0,o.kt)("p",null,"Instead of creating each of the fish individually, which will be super tedious, we will use a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"for")," loop to create each of the fish until it reaches our desire count, also cycling through the fish asset aliases array. In addition to the basic setup and applying initial transforms, we also assign them with custom properties like ",(0,o.kt)("inlineCode",{parentName:"p"},"direction"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"speed")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"turnSpeed")," which will be used during the animation. We will store the fishes in a reference array defined outside of the IIFE."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"for (let i = 0; i < fishCount; i++)\n{\n    const fishAsset = fishAssets[i % fishAssets.length];\n    const fish = Sprite.from(fishAsset);\n\n    fish.anchor.set(0.5);\n\n    fish.direction = Math.random() * Math.PI * 2;\n    fish.speed = 2 + Math.random() * 2;\n    fish.turnSpeed = Math.random() - 0.8;\n\n    fish.x = Math.random() * app.screen.width;\n    fish.y = Math.random() * app.screen.height;\n    fish.scale.set(0.5 + Math.random() * 0.2);\n\n    fishContainer.addChild(fish);\n    fishes.push(fish);\n}\n")),(0,o.kt)("h2",{id:"animate-fishes"},"Animate Fishes"),(0,o.kt)("p",null,"It's time to give the fishes some movements! Another function ",(0,o.kt)("inlineCode",{parentName:"p"},"animateFishes")," has been prepared and connected to the application's ticker which will be continuously called. It is supplied with a Ticker object which we can use to infer the amount of time passed between the calls."),(0,o.kt)("p",null,"We will declare a few variables to help us with the animation. We extract ",(0,o.kt)("inlineCode",{parentName:"p"},"deltaTime")," from the Ticker object which tells us the amount of time passed since last call, in seconds. We also define an imaginary bound that is larger than the stage itself to wrap the position of the fishes when they go off the screen. We use this bound instead of the actual screen size to avoid having the fishes disappear before they actually go off the edges, since the fish sprites' anchor is in the center so, eg. when a ",(0,o.kt)("inlineCode",{parentName:"p"},"fish.x = 0"),", half of the fish's width is still apparent on the screen."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const delta = time.deltaTime;\n\nconst stagePadding = 100;\nconst boundWidth = app.screen.width + stagePadding * 2;\nconst boundHeight = app.screen.height + stagePadding * 2;\n")),(0,o.kt)("p",null,"We can then simply loop through individual fishes array and update them one by one. First by updating the fish's pseudo direction which dictates the changes in its sprite position and rotation. To keep the fish within the screen bound, we use the padded bound defined earlier to check and wrap the fish as soon as it goes off the bound."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"fishes.forEach((fish) =>\n{\n    fish.direction += fish.turnSpeed * 0.01;\n    fish.x += Math.sin(fish.direction) * fish.speed;\n    fish.y += Math.cos(fish.direction) * fish.speed;\n    fish.rotation = -fish.direction - Math.PI / 2;\n\n    if (fish.x < -stagePadding)\n    {\n        fish.x += boundWidth;\n    }\n    if (fish.x > app.screen.width + stagePadding)\n    {\n        fish.x -= boundWidth;\n    }\n    if (fish.y < -stagePadding)\n    {\n        fish.y += boundHeight;\n    }\n    if (fish.y > app.screen.height + stagePadding)\n    {\n        fish.y -= boundHeight;\n    }\n});\n")),(0,o.kt)("p",null,"They are beautiful aren't they! Next, let's add a water surface effect to make the pond feels more dynamic."))}ae.isMDXComponent=!0;const ie={toc:[{value:"Create and Setup Tiling Sprite",id:"create-and-setup-tiling-sprite",level:2},{value:"Animate Overlay",id:"animate-overlay",level:2}]};function oe(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},ie,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-water-overlay"},"Adding Water Overlay"),(0,o.kt)("p",null,"At the point, the fishes look like they are floating on the rocks and pebbles. We will overlay what we have so far with a tiling sprite of a tiled water texture. Tiling sprite is essentially a sprite with the capabilities of transforming and rending an infinitely repeating grid of a single texture, preferably a tiled one where the edges seamlessly connect with each other when put together. We will use this to give an illusion of a forever moving water surface."),(0,o.kt)("h2",{id:"create-and-setup-tiling-sprite"},"Create and Setup Tiling Sprite"),(0,o.kt)("p",null,"Here we create a tiling sprite, supplying a texture and dimensions as an option object, and add it to the stage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const texture = Texture.from('overlay');\n\noverlay = new TilingSprite({\n    texture,\n    width: app.screen.width,\n    height: app.screen.height,\n});\napp.stage.addChild(overlay);\n")),(0,o.kt)("h2",{id:"animate-overlay"},"Animate Overlay"),(0,o.kt)("p",null,"Similar to the previous step, we will now animate the water overlay using the application's ticker. The code has been modify to call both animation functions for the fish and this overlay so we only need to add the animation logic inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"animateWaterOverlay")," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"elapsed += time.deltaTime;\noverlay.tilePosition.x = elapsed * -1;\noverlay.tilePosition.y = elapsed * -1;\n")),(0,o.kt)("p",null,"Congratulations, we have now completed a beautiful pond! But we can take it a step further. Let's proceed to the final touch!"))}oe.isMDXComponent=!0;const se={toc:[]};function re(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},se,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-displacement-effect"},"Adding Displacement Effect"),(0,o.kt)("p",null,"Let's be a bit extra and simulate distortion effect from the water."),(0,o.kt)("p",null,"PixiJS comes with a handful of filters built-in and many dozens of fancy ones on the (PixiJS Filters package)","[https://github.com/pixijs/filters]",". Here, we will be using the displacement filter for the distortion, which is built-in to the native PixiJS so we do not have to install any additional filter packages."),(0,o.kt)("p",null,"Displacement filter requires a sprite as a parameter for its options object. We will need to create a sprite from the displacement map asset and set its base texture's wrap mode to be 'repeat' so that the shader can tile and repeated it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const sprite = Sprite.from('displacement');\n\nsprite.texture.baseTexture.wrapMode = 'repeat';\n")),(0,o.kt)("p",null,"From here, we can simply create the displacement filter and add it to the stage container's filters list."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const filter = new DisplacementFilter({\n    sprite,\n    scale: 50,\n    width: app.screen.width,\n    height: app.screen.height,\n});\n\napp.stage.filters = [filter];\n")),(0,o.kt)("p",null,"Now you should see the post-processed pond in effect. Looks like we are looking down directly into a real pond, right?"))}re.isMDXComponent=!0;const pe={toc:[]};function le(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},pe,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"you-did-it"},"You did it!"),(0,o.kt)("p",null,"Congratulations once again! Well done for creating this master piece. Feel free to head back to the gallery and explore other tutorials."))}le.isMDXComponent=!0;const de="import { Application, Assets } from 'pixi.js';\nimport { addBackground } from './addBackground';\n\n// Create a PixiJS application.\nconst app = new Application();\n\nasync function setup()\n{\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n}\n\nasync function preload()\n{\n    // Create an array of asset data to load.\n    const assets = [\n        { alias: 'background', src: 'https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg' },\n        { alias: 'fish1', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish1.png' },\n        { alias: 'fish2', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish2.png' },\n        { alias: 'fish3', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish3.png' },\n        { alias: 'fish4', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish4.png' },\n        { alias: 'fish5', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish5.png' },\n        { alias: 'overlay', src: 'https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png' },\n        { alias: 'displacement', src: 'https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png' },\n    ];\n\n    // Load the assets defined above.\n    await Assets.load(assets);\n}\n\n// Asynchronous IIFE\n(async () =>\n{\n    await setup();\n    await preload();\n\n    addBackground(app);\n})();\n",ce="import { Application, Assets } from 'pixi.js';\nimport { addBackground } from './addBackground';\nimport { addFishes, animateFishes } from './addFishes';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Store an array of fish sprites for animation.\nconst fishes = [];\n\nasync function setup()\n{\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n}\n\nasync function preload()\n{\n    // Create an array of asset data to load.\n    const assets = [\n        { alias: 'background', src: 'https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg' },\n        { alias: 'fish1', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish1.png' },\n        { alias: 'fish2', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish2.png' },\n        { alias: 'fish3', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish3.png' },\n        { alias: 'fish4', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish4.png' },\n        { alias: 'fish5', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish5.png' },\n        { alias: 'overlay', src: 'https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png' },\n        { alias: 'displacement', src: 'https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png' },\n    ];\n\n    // Load the assets defined above.\n    await Assets.load(assets);\n}\n\n// Asynchronous IIFE\n(async () =>\n{\n    await setup();\n    await preload();\n\n    addBackground(app);\n    addFishes(app, fishes);\n\n    // Add the fish animation callback to the application's ticker.\n    app.ticker.add((time) => animateFishes(app, fishes, time));\n})();\n",he="import { Application, Assets } from 'pixi.js';\nimport { addBackground } from './addBackground';\nimport { addFishes, animateFishes } from './addFishes';\nimport { addWaterOverlay, animateWaterOverlay } from './addWaterOverlay';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Store an array of fish sprites for animation.\nconst fishes = [];\n\nasync function setup()\n{\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n}\n\nasync function preload()\n{\n    // Create an array of asset data to load.\n    const assets = [\n        { alias: 'background', src: 'https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg' },\n        { alias: 'fish1', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish1.png' },\n        { alias: 'fish2', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish2.png' },\n        { alias: 'fish3', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish3.png' },\n        { alias: 'fish4', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish4.png' },\n        { alias: 'fish5', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish5.png' },\n        { alias: 'overlay', src: 'https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png' },\n        { alias: 'displacement', src: 'https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png' },\n    ];\n\n    // Load the assets defined above.\n    await Assets.load(assets);\n}\n\n// Asynchronous IIFE\n(async () =>\n{\n    await setup();\n    await preload();\n\n    addBackground(app);\n    addFishes(app, fishes);\n    addWaterOverlay(app);\n\n    // Add the animation callbacks to the application's ticker.\n    app.ticker.add((time) =>\n    {\n        animateFishes(app, fishes, time);\n        animateWaterOverlay(app, time);\n    });\n})();\n",ue="import { Application, Assets } from 'pixi.js';\nimport { addBackground } from './addBackground';\nimport { addFishes, animateFishes } from './addFishes';\nimport { addWaterOverlay, animateWaterOverlay } from './addWaterOverlay';\nimport { addDisplacementEffect } from './addDisplacementEffect';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Store an array of fish sprites for animation.\nconst fishes = [];\n\nasync function setup()\n{\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n}\n\nasync function preload()\n{\n    // Create an array of asset data to load.\n    const assets = [\n        { alias: 'background', src: 'https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg' },\n        { alias: 'fish1', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish1.png' },\n        { alias: 'fish2', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish2.png' },\n        { alias: 'fish3', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish3.png' },\n        { alias: 'fish4', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish4.png' },\n        { alias: 'fish5', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish5.png' },\n        { alias: 'overlay', src: 'https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png' },\n        { alias: 'displacement', src: 'https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png' },\n    ];\n\n    // Load the assets defined above.\n    await Assets.load(assets);\n}\n\n// Asynchronous IIFE\n(async () =>\n{\n    await setup();\n    await preload();\n\n    addBackground(app);\n    addFishes(app, fishes);\n    addWaterOverlay(app);\n    addDisplacementEffect(app);\n\n    // Add the animation callbacks to the application's ticker.\n    app.ticker.add((time) =>\n    {\n        animateFishes(app, fishes, time);\n        animateWaterOverlay(app, time);\n    });\n})();\n",me="import { Sprite } from 'pixi.js';\n\nexport function addBackground(app)\n{\n    // Create a background sprite.\n    const background = Sprite.from('background');\n\n    // Center background sprite anchor.\n    background.anchor.set(0.5);\n\n    /**\n     * If the preview is landscape, fill the width of the screen\n     * and apply horizontal scale to the vertical scale for a uniform fit.\n     */\n    if (app.screen.width > app.screen.height)\n    {\n        background.width = app.screen.width * 1.2;\n        background.scale.y = background.scale.x;\n    }\n    else\n    {\n        /**\n         * If the preview is square or portrait, then fill the height of the screen instead\n         * and apply the scaling to the horizontal scale accordingly.\n         */\n        background.height = app.screen.height * 1.2;\n        background.scale.x = background.scale.y;\n    }\n\n    // Position the background sprite in the center of the stage.\n    background.x = app.screen.width / 2;\n    background.y = app.screen.height / 2;\n\n    // Add the background to the stage.\n    app.stage.addChild(background);\n}\n",ge="import { Container, Sprite } from 'pixi.js';\n\nexport function addFishes(app, fishes)\n{\n    // Create a container to hold all the fish sprites.\n    const fishContainer = new Container();\n\n    // Add the fish container to the stage.\n    app.stage.addChild(fishContainer);\n\n    const fishCount = 20;\n    const fishAssets = ['fish1', 'fish2', 'fish3', 'fish4', 'fish5'];\n\n    // Create a fish sprite for each fish.\n    for (let i = 0; i < fishCount; i++)\n    {\n        // Cycle through the fish assets for each sprite.\n        const fishAsset = fishAssets[i % fishAssets.length];\n\n        // Create a fish sprite.\n        const fish = Sprite.from(fishAsset);\n\n        // Center the sprite anchor.\n        fish.anchor.set(0.5);\n\n        // Assign additional properties for the animation.\n        fish.direction = Math.random() * Math.PI * 2;\n        fish.speed = 2 + Math.random() * 2;\n        fish.turnSpeed = Math.random() - 0.8;\n\n        // Randomly position the fish sprite around the stage.\n        fish.x = Math.random() * app.screen.width;\n        fish.y = Math.random() * app.screen.height;\n\n        // Randomly scale the fish sprite to create some variety.\n        fish.scale.set(0.5 + Math.random() * 0.2);\n\n        // Add the fish sprite to the fish container.\n        fishContainer.addChild(fish);\n\n        // Add the fish sprite to the fish array.\n        fishes.push(fish);\n    }\n}\n\nexport function animateFishes(app, fishes, time)\n{\n    // Extract the delta time from the Ticker object.\n    const delta = time.deltaTime;\n\n    // Define the padding around the stage where fishes are considered out of sight.\n    const stagePadding = 100;\n    const boundWidth = app.screen.width + stagePadding * 2;\n    const boundHeight = app.screen.height + stagePadding * 2;\n\n    // Iterate through each fish sprite.\n    fishes.forEach((fish) =>\n    {\n        // Animate the fish movement direction according to the turn speed.\n        fish.direction += fish.turnSpeed * 0.01;\n\n        // Animate the fish position according to the direction and speed.\n        fish.x += Math.sin(fish.direction) * fish.speed;\n        fish.y += Math.cos(fish.direction) * fish.speed;\n\n        // Apply the fish rotation according to the direction.\n        fish.rotation = -fish.direction - Math.PI / 2;\n\n        // Wrap the fish position when it goes out of bounds.\n        if (fish.x < -stagePadding)\n        {\n            fish.x += boundWidth;\n        }\n        if (fish.x > app.screen.width + stagePadding)\n        {\n            fish.x -= boundWidth;\n        }\n        if (fish.y < -stagePadding)\n        {\n            fish.y += boundHeight;\n        }\n        if (fish.y > app.screen.height + stagePadding)\n        {\n            fish.y -= boundHeight;\n        }\n    });\n}\n",fe="import { Texture, TilingSprite } from 'pixi.js';\n\n// Reference to the water overlay.\nlet overlay;\n\nexport function addWaterOverlay(app)\n{\n    // Create a water texture object.\n    const texture = Texture.from('overlay');\n\n    // Create a tiling sprite with the water texture and specify the dimensions.\n    overlay = new TilingSprite({\n        texture,\n        width: app.screen.width,\n        height: app.screen.height,\n    });\n\n    // Add the overlay to the stage.\n    app.stage.addChild(overlay);\n}\n\nexport function animateWaterOverlay(app, time)\n{\n    // Extract the delta time from the Ticker object.\n    const delta = time.deltaTime;\n\n    // Animate the overlay.\n    overlay.tilePosition.x -= delta;\n    overlay.tilePosition.y -= delta;\n}\n",ke="import { Sprite, DisplacementFilter } from 'pixi.js';\n\nexport function addDisplacementEffect(app)\n{\n    // Create a sprite from the preloaded displacement asset.\n    const sprite = Sprite.from('displacement');\n\n    // Set the base texture wrap mode to repeat to allow the texture UVs to be tiled and repeated.\n    sprite.texture.baseTexture.wrapMode = 'repeat';\n\n    // Create a displacement filter using the sprite texture.\n    const filter = new DisplacementFilter({\n        sprite,\n        scale: 50,\n        width: app.screen.width,\n        height: app.screen.height,\n    });\n\n    // Add the filter to the stage.\n    app.stage.filters = [filter];\n}\n",ye=[{header:"Introduction",Content:Q,code:"import { Application, Assets } from 'pixi.js';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Asynchronous IIFE\n(async () =>\n{\n    await setup();\n    await preload();\n})();\n\nasync function setup()\n{\n    /** -- INSERT CODE HERE -- */\n}\n\nasync function preload()\n{\n    /** -- INSERT CODE HERE -- */\n}\n",completedCode:"import { Application, Assets } from 'pixi.js';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Asynchronous IIFE\n(async () =>\n{\n    await setup();\n    await preload();\n})();\n\nasync function setup()\n{\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n}\n\nasync function preload()\n{\n    // Create an array of asset data to load.\n    const assets = [\n        { alias: 'background', src: 'https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg' },\n        { alias: 'fish1', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish1.png' },\n        { alias: 'fish2', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish2.png' },\n        { alias: 'fish3', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish3.png' },\n        { alias: 'fish4', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish4.png' },\n        { alias: 'fish5', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish5.png' },\n        { alias: 'overlay', src: 'https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png' },\n        { alias: 'displacement', src: 'https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png' },\n    ];\n\n    // Load the assets defined above.\n    await Assets.load(assets);\n}\n"},{header:"Adding Background",Content:ne,code:{index:de,"src/addBackground.js*":"import { Sprite } from 'pixi.js';\n\nexport function addBackground(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:de,"src/addBackground.js*":me}},{header:"Adding Fishes",Content:ae,code:{index:ce,"src/addBackground.js!":me,"src/addFishes.js*":"import { Container, Sprite } from 'pixi.js';\n\nexport function addFishes(app, fishes)\n{\n    /** -- INSERT CODE HERE -- */\n}\n\nexport function animateFishes(app, fishes, time)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:ce,"src/addBackground.js!":me,"src/addFishes.js*":ge}},{header:"Adding Water Overlay",Content:oe,code:{index:he,"src/addBackground.js!":me,"src/addFishes.js!":ge,"src/addWaterOverlay.js*":"import { Texture, TilingSprite } from 'pixi.js';\n\n// Reference to the water overlay.\nlet overlay;\n\nexport function addWaterOverlay(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n\nexport function animateWaterOverlay(app, time)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:he,"src/addBackground.js!":me,"src/addFishes.js!":ge,"src/addWaterOverlay.js*":fe}},{header:"Adding Displacement Effect",Content:re,code:{index:ue,"src/addBackground.js!":me,"src/addFishes.js!":ge,"src/addWaterOverlay.js!":fe,"src/addDisplacementEffect.js*":"import { Sprite, DisplacementFilter } from 'pixi.js';\n\nexport function addDisplacementEffect(app)\n{\n    /** -- INSERT CODE HERE -- */\n}\n"},completedCode:{index:ue,"src/addBackground.js!":me,"src/addFishes.js!":ge,"src/addWaterOverlay.js!":fe,"src/addDisplacementEffect.js*":ke}},{header:"You did it!",Content:le,code:{index:"import { Application, Assets } from 'pixi.js';\nimport { addBackground } from './addBackground';\nimport { addFishes, animateFishes } from './addFishes';\nimport { addWaterOverlay, animateWaterOverlay } from './addWaterOverlay';\nimport { addDisplacementEffect } from './addDisplacementEffect';\n\n// Create a PixiJS application.\nconst app = new Application();\n\n// Store an array of fish sprites for animation.\nconst fishes = [];\n\nasync function setup()\n{\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n}\n\nasync function preload()\n{\n    // Create an array of asset data to load.\n    const assets = [\n        { alias: 'background', src: 'https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg' },\n        { alias: 'fish1', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish1.png' },\n        { alias: 'fish2', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish2.png' },\n        { alias: 'fish3', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish3.png' },\n        { alias: 'fish4', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish4.png' },\n        { alias: 'fish5', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish5.png' },\n        { alias: 'overlay', src: 'https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png' },\n        { alias: 'displacement', src: 'https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png' },\n    ];\n\n    // Load the assets defined above.\n    await Assets.load(assets);\n}\n\n// Asynchronous IIFE\n(async () =>\n{\n    await setup();\n    await preload();\n\n    addBackground(app);\n    addFishes(app, fishes);\n    addWaterOverlay(app);\n    addDisplacementEffect(app);\n\n    // Add the animation callbacks to the application's ticker.\n    app.ticker.add((time) =>\n    {\n        animateFishes(app, fishes, time);\n        animateWaterOverlay(app, time);\n    });\n})();\n","src/addBackground.js":me,"src/addFishes.js":ge,"src/addWaterOverlay.js":fe,"src/addDisplacementEffect.js":ke}}],we={toc:[{value:"Application Setup",id:"application-setup",level:2}]};function be(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},we,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"getting-started"},"Getting Started"),(0,o.kt)("p",null,"Welcome to the PixiJS tutorial!"),(0,o.kt)("p",null,"Please go through the tutorial steps at your own pace and challenge yourself using the editor on the right hand side. Here PixiJS has already been included as guided under the ",(0,o.kt)("a",{parentName:"p",href:"/guides/basics/getting-started#loading-pixijs"},"Getting Started")," section. Let's start with the creation of a PixiJS canvas application and add its view to the DOM."),(0,o.kt)("p",null,"We will be using an asynchronous immediately invoked function expression (",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Glossary/IIFE"},"IIFE"),"), but you are free to switch to use promises instead."),(0,o.kt)("h2",{id:"application-setup"},"Application Setup"),(0,o.kt)("p",null,"Let's create the application and initialize it within the the IIFE before appending the its canvas to the DOM. If you came from PixiJS v7 or below, the key differences to pay attention to is that application options are now passed in as an object parameter to the ",(0,o.kt)("inlineCode",{parentName:"p"},"init")," call, and that it is asynchronous which should be awaited before proceeding to use the application."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const app = new Application();\n\nawait app.init({ background: '#1099bb', resizeTo: window });\ndocument.body.appendChild(app.canvas);\n")),(0,o.kt)("p",null,"When you are ready, proceed to the next exercise using the ",(0,o.kt)("em",{parentName:"p"},"Next >")," button below, or feel free to skip to any exercise using the drop-down menu on the top right hand corner of the card."))}be.isMDXComponent=!0;const xe={toc:[]};function ve(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},xe,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"creating-a-sprite"},"Creating a Sprite"),(0,o.kt)("p",null,"So far all we've been doing is prep work. We haven't actually told PixiJS to draw anything. Let's fix that by adding an image to be displayed."),(0,o.kt)("p",null,"There are a number of ways to draw images in PixiJS, but the simplest is by using a ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.Sprite.html"},"Sprite"),". We'll get into the details of how the scene graph works in a later guide, but for now all you need to know is that PixiJS renders a hierarchy of ",(0,o.kt)("a",{parentName:"p",href:"https://pixijs.download/release/docs/PIXI.Container.html"},"Containers"),". A Sprite is an extension of Container that wraps a loaded image resource to allow drawing it, scaling it, rotating it, and so forth."),(0,o.kt)("p",null,"Before PixiJS can render an image, it needs to be loaded. Just like in any web page, image loading happens asynchronously. For now, we will simply load a single texture up on the spot with the ",(0,o.kt)("inlineCode",{parentName:"p"},"Assets")," utility class."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const texture = await Assets.load('https://pixijs.com/assets/bunny.png');\n")),(0,o.kt)("p",null,"Then we need to create and add our new bunny sprite to the stage. The stage is also simply a Container that is the root of the scene graph. Every child of the stage container will be rendered every frame. By adding our sprite to the stage, we tell PixiJS's renderer we want to draw it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const bunny = new Sprite(texture);\n\napp.stage.addChild(bunny);\n")),(0,o.kt)("p",null,"Now let's set the Sprite's anchor and position it so that it's bang on at the center."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"bunny.anchor.set(0.5)\n\nbunny.x = app.screen.width / 2\nbunny.y = app.screen.height / 2\n")))}ve.isMDXComponent=!0;const Ce={toc:[]};function Te(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},Ce,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"writing-an-update-loop"},"Writing an Update Loop"),(0,o.kt)("p",null,"While you ",(0,o.kt)("em",{parentName:"p"},"can")," use PixiJS for static content, for most projects you'll want to add animation. Our sample app is actually cranking away, rendering the same sprite in the same place multiple times a second. All we have to do to make the image move is to update its attributes once per frame. To do this, we want to hook into the application's ",(0,o.kt)("em",{parentName:"p"},"ticker"),". A ticker is a PixiJS object that runs one or more callbacks each frame. Doing so is surprisingly easy. Add the following to the end of your script block:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"app.ticker.add((time) => {\n    bunny.rotation += 0.1 * time.deltaTime;\n});\n")),(0,o.kt)("p",null,"All you need to do is to call ",(0,o.kt)("inlineCode",{parentName:"p"},"app.ticker.add(...)"),", pass it a callback function, and then update your scene in that function. It will get called every frame, and you can move, rotate etc. whatever you'd like to drive your project's animations."))}Te.isMDXComponent=!0;const Se={toc:[]};function je(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},Se,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"you-did-it"},"You did it!"),(0,o.kt)("p",null,"Congratulations! Now you are ready for the real world ~"))}je.isMDXComponent=!0;const Ae=[{header:"Getting Started",Content:be,code:"import { Application } from 'pixi.js';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n})();\n"},{header:"Set up something",Content:ve,code:"import { Application } from 'pixi.js';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n})();\n",completedCode:"import { Application, Assets, Sprite } from 'pixi.js';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the bunny texture.\n    const texture = await Assets.load('https://pixijs.com/assets/bunny.png');\n\n    // Create a new Sprite from an image path\n    const bunny = new Sprite(texture);\n\n    // Add to stage\n    app.stage.addChild(bunny);\n\n    // Center the sprite's anchor point\n    bunny.anchor.set(0.5);\n\n    // Move the sprite to the center of the screen\n    bunny.x = app.screen.width / 2;\n    bunny.y = app.screen.height / 2;\n})();\n"},{header:"Do something",Content:Te,code:"import { Application, Assets, Sprite } from 'pixi.js';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the bunny texture.\n    const texture = await Assets.load('https://pixijs.com/assets/bunny.png');\n\n    // Create a new Sprite from an image path.\n    const bunny = new Sprite(texture);\n\n    // Add to stage.\n    app.stage.addChild(bunny);\n\n    // Center the sprite's anchor point.\n    bunny.anchor.set(0.5);\n\n    // Move the sprite to the center of the screen.\n    bunny.x = app.screen.width / 2;\n    bunny.y = app.screen.height / 2;\n})();\n",completedCode:"import { Application, Assets, Sprite } from 'pixi.js';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the bunny texture.\n    const texture = await Assets.load('https://pixijs.com/assets/bunny.png');\n\n    // Create a new Sprite from an image path.\n    const bunny = new Sprite(texture);\n\n    // Add to stage.\n    app.stage.addChild(bunny);\n\n    // Center the sprite's anchor point.\n    bunny.anchor.set(0.5);\n\n    // Move the sprite to the center of the screen.\n    bunny.x = app.screen.width / 2;\n    bunny.y = app.screen.height / 2;\n\n    // Add an animation loop callback to the application's ticker.\n    app.ticker.add((time) =>\n    {\n        /**\n         * Just for fun, let's rotate mr rabbit a little.\n         * Time is a Ticker object which holds time related data.\n         * Here we use deltaTime, which is the time elapsed between the frame callbacks\n         * to create frame-independent transformation. Keeping the speed consistent.\n         */\n        bunny.rotation += 0.1 * time.deltaTime;\n    });\n})();\n"},{header:"You did it!",Content:je,code:"import { Application, Assets, Sprite } from 'pixi.js';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the bunny texture.\n    const texture = await Assets.load('https://pixijs.com/assets/bunny.png');\n\n    // Create a new Sprite from an image path.\n    const bunny = new Sprite(texture);\n\n    // Add to stage.\n    app.stage.addChild(bunny);\n\n    // Center the sprite's anchor point.\n    bunny.anchor.set(0.5);\n\n    // Move the sprite to the center of the screen.\n    bunny.x = app.screen.width / 2;\n    bunny.y = app.screen.height / 2;\n\n    // Add an animation loop callback to the application's ticker.\n    app.ticker.add((time) =>\n    {\n        /**\n         * Just for fun, let's rotate mr rabbit a little.\n         * Time is a Ticker object which holds time related data.\n         * Here we use deltaTime, which is the time elapsed between the frame callbacks\n         * to create frame-independent transformation. Keeping the speed consistent.\n         */\n        bunny.rotation += 0.1 * time.deltaTime;\n    });\n})();\n"}],We="import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\nimport { Controller } from './Controller';\nimport { Scene } from './Scene';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create a controller that handles keyboard inputs.\n    const controller = new Controller();\n\n    // Create a scene that holds the environment.\n    const scene = new Scene(app.screen.width, app.screen.height);\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust views' transformation.\n    scene.view.y = app.screen.height;\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - scene.floorHeight;\n    spineBoy.spine.scale.set(scene.scale * 0.32);\n\n    // Add scene and character to the stage.\n    app.stage.addChild(scene.view, spineBoy.view);\n\n    // Trigger character's spawn animation.\n    spineBoy.spawn();\n\n    // Animate the character based on the controller's input.\n    app.ticker.add(() =>\n    {\n        // Ignore the update loops while the character is doing the spawn animation.\n        if (spineBoy.isSpawning()) return;\n\n        // Update character's state based on the controller's input.\n        spineBoy.state.walk = controller.keys.left.pressed || controller.keys.right.pressed;\n        if (spineBoy.state.run && spineBoy.state.walk) spineBoy.state.run = true;\n        else spineBoy.state.run = controller.keys.left.doubleTap || controller.keys.right.doubleTap;\n        spineBoy.state.hover = controller.keys.down.pressed;\n        if (controller.keys.left.pressed) spineBoy.direction = -1;\n        else if (controller.keys.right.pressed) spineBoy.direction = 1;\n        spineBoy.state.jump = controller.keys.space.pressed;\n\n        // Update character's animation based on the latest state.\n        spineBoy.update();\n    });\n})();\n",Ne="import { Spine } from '@pixi/spine-pixi';\nimport { Container } from 'pixi.js';\n\n// Class for handling the character Spine and its animations.\nexport class SpineBoy\n{\n    constructor()\n    {\n        // Create the main view.\n        this.view = new Container();\n\n        // Create the Spine instance using the preloaded Spine asset aliases.\n        this.spine = Spine.from({\n            skeleton: 'spineSkeleton',\n            atlas: 'spineAtlas',\n        });\n\n        // Add the spine to the main view.\n        this.view.addChild(this.spine);\n    }\n}\n",He="import { Spine } from '@pixi/spine-pixi';\nimport { Container } from 'pixi.js';\n\n// Define the Spine animation map for the character.\n// name: animation track key.\n// loop: do the animation once or infinitely.\nconst animationMap = {\n    idle: {\n        name: 'idle',\n        loop: true,\n    },\n    walk: {\n        name: 'walk',\n        loop: true,\n    },\n    run: {\n        name: 'run',\n        loop: true,\n    },\n    jump: {\n        name: 'jump',\n        timeScale: 1.5,\n    },\n    hover: {\n        name: 'hoverboard',\n        loop: true,\n    },\n    spawn: {\n        name: 'portal',\n    },\n};\n\n// Class for handling the character Spine and its animations.\nexport class SpineBoy\n{\n    constructor()\n    {\n        // The character's state.\n        this.state = {\n            walk: false,\n            run: false,\n            hover: false,\n            jump: false,\n        };\n\n        // Create the main view and a nested view for directional scaling.\n        this.view = new Container();\n        this.directionalView = new Container();\n\n        // Create the Spine instance using the preloaded Spine asset aliases.\n        this.spine = Spine.from({\n            skeleton: 'spineSkeleton',\n            atlas: 'spineAtlas',\n        });\n\n        // Add the Spine instance to the directional view.\n        this.directionalView.addChild(this.spine);\n\n        // Add the directional view to the main view.\n        this.view.addChild(this.directionalView);\n\n        // Set the default mix duration for all animations.\n        // This is the duration to blend from the previous animation to the next.\n        this.spine.state.data.defaultMix = 0.2;\n    }\n\n    // Play the portal-in spawn animation.\n    spawn()\n    {\n        this.spine.state.setAnimation(0, animationMap.spawn.name);\n    }\n\n    // Play the spine animation.\n    playAnimation({ name, loop = false, timeScale = 1 })\n    {\n        // Skip if the animation is already playing.\n        if (this.currentAnimationName === name) return;\n\n        // Play the animation on main track instantly.\n        const trackEntry = this.spine.state.setAnimation(0, name, loop);\n\n        // Apply the animation's time scale (speed).\n        trackEntry.timeScale = timeScale;\n    }\n\n    update()\n    {\n        // Play the jump animation if not already playing.\n        if (this.state.jump) this.playAnimation(animationMap.jump);\n\n        // Skip the rest of the animation updates during the jump animation.\n        if (this.isAnimationPlaying(animationMap.jump)) return;\n\n        // Handle the character animation based on the latest state and in the priority order.\n        if (this.state.hover) this.playAnimation(animationMap.hover);\n        else if (this.state.run) this.playAnimation(animationMap.run);\n        else if (this.state.walk) this.playAnimation(animationMap.walk);\n        else this.playAnimation(animationMap.idle);\n    }\n\n    isSpawning()\n    {\n        return this.isAnimationPlaying(animationMap.spawn);\n    }\n\n    isAnimationPlaying({ name })\n    {\n        // Check if the current animation on main track equals to the queried.\n        // Also check if the animation is still ongoing.\n        return this.currentAnimationName === name && !this.spine.state.getCurrent(0).isComplete();\n    }\n\n    // Return the name of the current animation on main track.\n    get currentAnimationName()\n    {\n        return this.spine.state.getCurrent(0)?.animation.name;\n    }\n\n    // Return character's facing direction.\n    get direction()\n    {\n        return this.directionalView.scale.x > 0 ? 1 : -1;\n    }\n\n    // Set character's facing direction.\n    set direction(value)\n    {\n        this.directionalView.scale.x = value;\n    }\n}\n",Me="// Map keyboard key codes to controller's state keys\nconst keyMap = {\n    Space: 'space',\n    KeyW: 'up',\n    ArrowUp: 'up',\n    KeyA: 'left',\n    ArrowLeft: 'left',\n    KeyS: 'down',\n    ArrowDown: 'down',\n    KeyD: 'right',\n    ArrowRight: 'right',\n};\n\n// Class for handling keyboard inputs.\nexport class Controller\n{\n    constructor()\n    {\n        // The controller's state.\n        this.keys = {\n            up: { pressed: false, doubleTap: false, timestamp: 0 },\n            left: { pressed: false, doubleTap: false, timestamp: 0 },\n            down: { pressed: false, doubleTap: false, timestamp: 0 },\n            right: { pressed: false, doubleTap: false, timestamp: 0 },\n            space: { pressed: false, doubleTap: false, timestamp: 0 },\n        };\n\n        // Register event listeners for keydown and keyup events.\n        window.addEventListener('keydown', (event) => this.keydownHandler(event));\n        window.addEventListener('keyup', (event) => this.keyupHandler(event));\n    }\n\n    keydownHandler(event)\n    {\n        const key = keyMap[event.code];\n\n        if (!key) return;\n\n        const now = Date.now();\n\n        // If not already in the double-tap state, toggle the double tap state if the key was pressed twice within 300ms.\n        this.keys[key].doubleTap = this.keys[key].doubleTap || now - this.keys[key].timestamp < 300;\n\n        // Toggle on the key pressed state.\n        this.keys[key].pressed = true;\n    }\n\n    keyupHandler(event)\n    {\n        const key = keyMap[event.code];\n\n        if (!key) return;\n\n        const now = Date.now();\n\n        // Reset the key pressed state.\n        this.keys[key].pressed = false;\n\n        // Reset double tap only if the key is in the double-tap state.\n        if (this.keys[key].doubleTap) this.keys[key].doubleTap = false;\n        // Otherwise, update the timestamp to track the time difference till the next potential key down.\n        else this.keys[key].timestamp = now;\n    }\n}\n",De="import { Container, Sprite, Texture, TilingSprite } from 'pixi.js';\n\n// Class for handling the environment.\nexport class Scene\n{\n    constructor(width, height)\n    {\n        // Create a main view that holds all layers.\n        this.view = new Container();\n\n        // Create the stationary sky that fills the entire screen.\n        this.sky = Sprite.from('sky');\n        this.sky.anchor.set(0, 1);\n        this.sky.width = width;\n        this.sky.height = height;\n\n        // Create textures for the background, mid-ground, and platform.\n        const backgroundTexture = Texture.from('background');\n        const midgroundTexture = Texture.from('midground');\n        const platformTexture = Texture.from('platform');\n\n        // Calculate the ideal platform height depending on the passed-in screen height.\n        const maxPlatformHeight = platformTexture.height;\n        const platformHeight = Math.min(maxPlatformHeight, height * 0.4);\n\n        // Calculate the scale to be apply to all tiling textures for consistency.\n        const scale = (this.scale = platformHeight / maxPlatformHeight);\n\n        const baseOptions = {\n            tileScale: { x: scale, y: scale },\n            anchor: { x: 0, y: 1 },\n            applyAnchorToTexture: true,\n        };\n\n        // Create the tiling sprite layers.\n        this.background = new TilingSprite({\n            texture: backgroundTexture,\n            width,\n            height: backgroundTexture.height * scale,\n            ...baseOptions,\n        });\n        this.midground = new TilingSprite({\n            texture: midgroundTexture,\n            width,\n            height: midgroundTexture.height * scale,\n            ...baseOptions,\n        });\n        this.platform = new TilingSprite({\n            texture: platformTexture,\n            width,\n            height: platformHeight,\n            ...baseOptions,\n        });\n\n        // Calculate the floor height for external referencing.\n        this.floorHeight = platformHeight * 0.43;\n\n        // Position the backdrop layers.\n        this.background.y = this.midground.y = -this.floorHeight;\n\n        // Add all layers to the main view.\n        this.view.addChild(this.sky, this.background, this.midground, this.platform);\n    }\n\n    // Use the platform's horizontal position as the key position for the scene.\n    get positionX()\n    {\n        return this.platform.tilePosition.x;\n    }\n\n    // Set the horizontal position of the platform layer while applying parallax scrolling to the backdrop layers.\n    set positionX(value)\n    {\n        this.background.tilePosition.x = value * 0.1;\n        this.midground.tilePosition.x = value * 0.25;\n        this.platform.tilePosition.x = value;\n    }\n}\n",Ie={toc:[{value:"What is Spine",id:"what-is-spine",level:2},{value:"Application Setup",id:"application-setup",level:2},{value:"Assets Preloading",id:"assets-preloading",level:2}]};function Be(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},Ie,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"spineboy-adventure"},"SpineBoy Adventure"),(0,o.kt)("p",null,"Welcome to the SpineBoy Adventure workshop!"),(0,o.kt)("p",null,"Let's venture into the world of the PixiJS ecosystem. We are going to explore one of the official plugins; ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/pixijs/spine-v8"},"Spine plugin (",(0,o.kt)("inlineCode",{parentName:"a"},"@pixi/spine-pixi"),")")," which allow us to render and manipulate Spine animations on our PixiJS."),(0,o.kt)("p",null,"We will be creating a mini interactive side-scroller experience using the famous SpineBoy which will be controlled by the keyboard. For the sake of simplicity, we will be focusing on just the movement around the scene."),(0,o.kt)("h2",{id:"what-is-spine"},"What is Spine"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://esotericsoftware.com/"},"Spine"),", developed by Esoteric Software, is a 2D animation software specifically designed for games. It streamlines 2D game animation with skeletal animation, robust tools, and exportable, lightweight animations."),(0,o.kt)("h2",{id:"application-setup"},"Application Setup"),(0,o.kt)("p",null,"As usual, let's begin by creating an application, initializing it, and appending its canvas to the DOM inside the IIFE."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"await app.init({ background: '#021f4b', resizeTo: window });\ndocument.body.appendChild(app.canvas);\n")),(0,o.kt)("h2",{id:"assets-preloading"},"Assets Preloading"),(0,o.kt)("p",null,"Let's then preload all of our required assets upfront which includes:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Spine Assets",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Skeleton data file."),(0,o.kt)("li",{parentName:"ul"},"Accompanying ATLAS."))),(0,o.kt)("li",{parentName:"ol"},"Scene Images",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Static sky gradient image."),(0,o.kt)("li",{parentName:"ul"},"Tiled image of the massive buildings in the distance."),(0,o.kt)("li",{parentName:"ul"},"Tiled image of the city skyline."),(0,o.kt)("li",{parentName:"ul"},"Tiled image of the platform that the character will be moving on.")))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"await Assets.load([\n    {\n        alias: 'spineSkeleton',\n        src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n    },\n    {\n        alias: 'spineAtlas',\n        src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n    },\n    {\n        alias: 'sky',\n        src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n    },\n    {\n        alias: 'background',\n        src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n    },\n    {\n        alias: 'midground',\n        src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n    },\n    {\n        alias: 'platform',\n        src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n    },\n]);\n")),(0,o.kt)("p",null,"Now you are ready to dive straight into the adventure! Proceed to the next exercise using the ",(0,o.kt)("em",{parentName:"p"},"Next >")," button below, or feel free to skip to any exercise using the drop-down menu on the top right hand corner of the card."))}Be.isMDXComponent=!0;const Re={toc:[]};function Ee(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},Re,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"setting-up-character"},"Setting Up Character"),(0,o.kt)("p",null,"We will now create a class for containing and handling our character Spine animations."),(0,o.kt)("p",null,"Here, a `SpineBoy`` class has been set up on a different file. Lets start off by doing the minimum to get the character Spine displayed. Inside the class, a view container has also been set up to hold any of the content from within the class."),(0,o.kt)("p",null,"We can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Spine.from(options)")," method to instantiate our SpineBoy using the preloaded Character's Spine skeleton file and ATLAS file. We then store it as the ",(0,o.kt)("inlineCode",{parentName:"p"},"spine")," member of the class for future references both internally and externally. And of course, remember to add it to the class' view container."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"this.spine = Spine.from({\n    skeleton: 'spineSkeleton',\n    atlas: 'spineAtlas',\n});\nthis.view.addChild(this.spine);\n")),(0,o.kt)("p",null,"Let's also create an instance of our SpineBoy class on our main ",(0,o.kt)("inlineCode",{parentName:"p"},"index.js")," file and add its view to our application's stage. To keep it simple, let just keep our character in the middle of the screen and 80 pixels from the bottom of the screen, and also scale it down a little to ensure the fit."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// Create our character\nconst spineBoy = new SpineBoy();\n\n// Adjust character transformation.\nspineBoy.view.x = app.screen.width / 2;\nspineBoy.view.y = app.screen.height - 80;\nspineBoy.spine.scale.set(0.5);\n\n// Add character to the stage.\napp.stage.addChild(spineBoy.view);\n")),(0,o.kt)("p",null,"Now we should have our static character on the screen!"))}Ee.isMDXComponent=!0;const Pe={toc:[{value:"Key-Down Handler",id:"key-down-handler",level:2},{value:"Key-Up Handler",id:"key-up-handler",level:2},{value:"Using Controller",id:"using-controller",level:2}]};function Xe(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},Pe,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-keyboard-controller"},"Adding Keyboard Controller"),(0,o.kt)("p",null,"Before we proceed to work on the character animations, we will need a handler for our keyboard input."),(0,o.kt)("p",null,"To speed things up, a ",(0,o.kt)("inlineCode",{parentName:"p"},"Controller")," class has been set up on another file with the key map and the controller state map define, as well as the key listeners hooked up."),(0,o.kt)("p",null,"As you can we, we have 3 tracked properties on each of the state keys:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"pressed")," simply tells whether the key is being pressed."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"doubleTap")," tracks if the key has been rapidly pressed after letting go."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"timestamp")," is an internal time tracker for determining whether the tap is considered as a double tap.")),(0,o.kt)("p",null,"Please note that we have also defined ",(0,o.kt)("strong",{parentName:"p"},"W"),", ",(0,o.kt)("strong",{parentName:"p"},"A"),", ",(0,o.kt)("strong",{parentName:"p"},"S")," and ",(0,o.kt)("strong",{parentName:"p"},"D")," keys as directional input on the key map so they will behave like the arrow keys."),(0,o.kt)("p",null,"Let's start by updating our key-down and key-up handlers so that the controller state is updated accordingly."),(0,o.kt)("h2",{id:"key-down-handler"},"Key-Down Handler"),(0,o.kt)("p",null,"For this, we simply need to set the ",(0,o.kt)("inlineCode",{parentName:"p"},"pressed")," state of the corresponded key state to ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". And so for the ",(0,o.kt)("inlineCode",{parentName:"p"},"doubleTap")," if the difference in time from the point of the timestamp recorded for that key is less than a threshold, 300ms in this case. Since the key-down handler will be called continuously while a key is held, the ",(0,o.kt)("inlineCode",{parentName:"p"},"doubleTap")," state should remain ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," on subsequent callback if it was already, despite the growing deference in time from the timestamp (As the timestamp only gets reset on the key-up handler)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const key = keyMap[event.code];\n\nif (!key) return;\n\nconst now = Date.now();\n\nthis.keys[key].pressed = true;\nthis.keys[key].doubleTap = this.keys[key].doubleTap || now - this.keys[key].timestamp < 300;\n")),(0,o.kt)("h2",{id:"key-up-handler"},"Key-Up Handler"),(0,o.kt)("p",null,"Similary, we reset the ",(0,o.kt)("inlineCode",{parentName:"p"},"pressed")," state of the corresponded key state to ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," on key-up, as well as the ",(0,o.kt)("inlineCode",{parentName:"p"},"doubleTap")," state if it was previously ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". Otherwise, we reset the timestamp to allow subsequent key presses to validate any rapid double-tap."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const key = keyMap[event.code];\n\nif (!key) return;\n\nconst now = Date.now();\n\nthis.keys[key].pressed = false;\n\nif (this.keys[key].doubleTap) this.keys[key].doubleTap = false;\nelse this.keys[key].timestamp = now;\n")),(0,o.kt)("h2",{id:"using-controller"},"Using Controller"),(0,o.kt)("p",null,"Just like for our character, we then create an instance of the controller on the main ",(0,o.kt)("inlineCode",{parentName:"p"},"index.js"),"' IIFE."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const controller = new Controller();\n")),(0,o.kt)("p",null,"Then we can try connecting the controller state to the character's walk animation. Let's do this for just the right key for now on an application's ticker update. Here, we temporarily store a reference to an active animation key on spot to only allow playing once per toggle since we are already specifying for them to be loops. The toggle will be between the animations with the key of ",(0,o.kt)("inlineCode",{parentName:"p"},"idle")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"walk"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"let currentAnimation;\n\napp.ticker.add((time) =>\n{\n    const rightPressed = controller.keys.right.pressed;\n    const animationName = rightPressed ? 'walk' : 'idle';\n    const loop = true;\n\n    if (currentAnimation !== animationName)\n    {\n        currentAnimation = animationName;\n        spineBoy.spine.state.setAnimation(0, animationName, loop);\n    }\n});\n")),(0,o.kt)("p",null,"Now tap on the preview screen to make sure the canvas is focused, then try tapping away the right button. We now having a functioning controller!"))}Xe.isMDXComponent=!0;const Ge={toc:[{value:"Preparation",id:"preparation",level:2},{value:"Animation Map",id:"animation-map",level:3},{value:"Helper Methods",id:"helper-methods",level:3},{value:"<code>playAnimation(animation)</code>",id:"playanimationanimation",level:4},{value:"<code>isAnimationPlaying(animation)</code>",id:"isanimationplayinganimation",level:4},{value:"<code>spawn()</code>",id:"spawn",level:4},{value:"<code>isSpawning()</code>",id:"isspawning",level:4},{value:"Handling Direction",id:"handling-direction",level:3},{value:"Spine State Animation Default Mix",id:"spine-state-animation-default-mix",level:3},{value:"Update Loop",id:"update-loop",level:2},{value:"Connecting to Controller",id:"connecting-to-controller",level:2}]};function Oe(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},Ge,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"animating-character"},"Animating Character"),(0,o.kt)("p",null,"Returning to the star of our workshop, let's upgrade our Character to handle various movement animations. For this example, we will simply store a state set where we can then use an update loop to trigger animations according to the combination of the state values. We can then externally update the character state depending on the controller input state."),(0,o.kt)("h2",{id:"preparation"},"Preparation"),(0,o.kt)("p",null,"For the upgrade, an animation map and assorted helper methods have been added to make handling Spine animation a little cleaner."),(0,o.kt)("h3",{id:"animation-map"},"Animation Map"),(0,o.kt)("p",null,"This lists out all the available animations to be included in our character, each with a ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," parameter that corresponds to an animation key existed on the character Spine data and an optional ",(0,o.kt)("inlineCode",{parentName:"p"},"loop")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"timeScale")," parameters to customize the animation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const animationMap = {\n    idle: {\n        name: 'idle',\n        loop: true,\n    },\n    walk: {\n        name: 'walk',\n        loop: true,\n    },\n    run: {\n        name: 'run',\n        loop: true,\n    },\n    jump: {\n        name: 'jump',\n        timeScale: 1.5,\n    },\n    hover: {\n        name: 'hoverboard',\n        loop: true,\n    },\n    spawn: {\n        name: 'portal',\n    },\n};\n")),(0,o.kt)("h3",{id:"helper-methods"},"Helper Methods"),(0,o.kt)("h4",{id:"playanimationanimation"},(0,o.kt)("inlineCode",{parentName:"h4"},"playAnimation(animation)")),(0,o.kt)("p",null,"Wraps Spine state's ",(0,o.kt)("inlineCode",{parentName:"p"},"setAnimation(track, name, loop)")," method that plays an animation using a passed in animation data defined on the animation map. It prevents the same animation from being played on top of each other."),(0,o.kt)("hr",null),(0,o.kt)("h4",{id:"isanimationplayinganimation"},(0,o.kt)("inlineCode",{parentName:"h4"},"isAnimationPlaying(animation)")),(0,o.kt)("p",null,"Check whether an animation is still active. That is when the Spine state's main track has a track entry of an animation with a key equals to that of the queried animation's name, and that the track entry is yet completed."),(0,o.kt)("hr",null),(0,o.kt)("h4",{id:"spawn"},(0,o.kt)("inlineCode",{parentName:"h4"},"spawn()")),(0,o.kt)("p",null,"Simply kick start the portal-in spawn animation. To be triggered externally."),(0,o.kt)("hr",null),(0,o.kt)("h4",{id:"isspawning"},(0,o.kt)("inlineCode",{parentName:"h4"},"isSpawning()")),(0,o.kt)("p",null,"Utilizing the ",(0,o.kt)("inlineCode",{parentName:"p"},"isAnimationPlaying(animation)")," to check if the spawn animation is still ongoing."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"handling-direction"},"Handling Direction"),(0,o.kt)("p",null,"You may have noticed that the spine instance is now wrapped in an extra ",(0,o.kt)("inlineCode",{parentName:"p"},"directionalView")," container before being added to the main view. This is just to distinctly separate the transform, especially the horizontal scaling in this case where we will externally set to be ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," for rightward or ",(0,o.kt)("inlineCode",{parentName:"p"},"-1")," for leftward depending on the controller input state. A getter and setter for ",(0,o.kt)("inlineCode",{parentName:"p"},"direction")," have been added for simplification."),(0,o.kt)("h3",{id:"spine-state-animation-default-mix"},"Spine State Animation Default Mix"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"this.spine.state.data.defaultMix = 0.2")," sets the default amount of time in second for the state to blend the animations when transitioning from one to another for all animations, like a cross-fade of the skeletal positions."),(0,o.kt)("h2",{id:"update-loop"},"Update Loop"),(0,o.kt)("p",null,"The only thing left to do is to handle the animation according to the character state in real-time on the ",(0,o.kt)("inlineCode",{parentName:"p"},"update()")," method. Let's utilize all the stuff that has been prepared for us. In a logical order of priority for this specific example:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"jump")," state should be handle immediately and the character should remain in the jump animation until it finishes even the jump state is no longer ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The rest of the state members should trigger a corresponding animation immediately, depending on the priority order: ",(0,o.kt)("inlineCode",{parentName:"p"},"hover")," > ",(0,o.kt)("inlineCode",{parentName:"p"},"run")," > ",(0,o.kt)("inlineCode",{parentName:"p"},"walk")," > ",(0,o.kt)("inlineCode",{parentName:"p"},"idle"),". Note that multiple state members can be ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," at the same time, ie. ",(0,o.kt)("inlineCode",{parentName:"p"},"walk")," will be ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," while ",(0,o.kt)("inlineCode",{parentName:"p"},"run")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," since the directional key is down in both scenarios."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"if (this.state.jump) this.playAnimation(animationMap.jump);\nif (this.isAnimationPlaying(animationMap.jump)) return;\nif (this.state.hover) this.playAnimation(animationMap.hover);\nelse if (this.state.run) this.playAnimation(animationMap.run);\nelse if (this.state.walk) this.playAnimation(animationMap.walk);\nelse this.playAnimation(animationMap.idle);\n")),(0,o.kt)("h2",{id:"connecting-to-controller"},"Connecting to Controller"),(0,o.kt)("p",null,"Back on ",(0,o.kt)("inlineCode",{parentName:"p"},"index.js"),", let's trigger the character's spawn animation at the start and update our application's ticker update callback."),(0,o.kt)("p",null,"On the callback, we should skip updating the character state and calling its local update loop while the spawn animation is happening. Otherwise, we can hook the controller input state to the character state as followed:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"left")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"right")," input ",(0,o.kt)("inlineCode",{parentName:"li"},"pressed")," state will toggle on character's ",(0,o.kt)("inlineCode",{parentName:"li"},"walk")," state and will update its direction value which should flip the character back and fourth horizontally to face the correct way. ",(0,o.kt)("inlineCode",{parentName:"li"},"doubleTap")," state will also toggle on character's ",(0,o.kt)("inlineCode",{parentName:"li"},"run")," state while still updating the direction accordingly."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"down")," input state is dedicated to character's ",(0,o.kt)("inlineCode",{parentName:"li"},"hover")," state."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"space")," input state is dedicated to character's ",(0,o.kt)("inlineCode",{parentName:"li"},"jump")," state.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"spineBoy.spawn();\n\napp.ticker.add(() =>\n{\n    if (spineBoy.isSpawning()) return;\n\n    spineBoy.state.walk = controller.keys.left.pressed || controller.keys.right.pressed;\n    if (spineBoy.state.run && spineBoy.state.walk) spineBoy.state.run = true;\n    else spineBoy.state.run = controller.keys.left.doubleTap || controller.keys.right.doubleTap;\n    spineBoy.state.hover = controller.keys.down.pressed;\n    if (controller.keys.left.pressed) spineBoy.direction = -1;\n    else if (controller.keys.right.pressed) spineBoy.direction = 1;\n    spineBoy.state.jump = controller.keys.space.pressed;\n\n    spineBoy.update();\n});\n")),(0,o.kt)("p",null,"That's a wrap for our character! Now we need an environment for him to be moving in."))}Oe.isMDXComponent=!0;const Le={toc:[{value:"Sky",id:"sky",level:2},{value:"Parallax Layers",id:"parallax-layers",level:2},{value:"Adding the Scene",id:"adding-the-scene",level:2}]};function Fe(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},Le,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"setting-up-scene"},"Setting Up Scene"),(0,o.kt)("p",null,"The scene is much less complicated and only involves a static ",(0,o.kt)("inlineCode",{parentName:"p"},"Sprite")," for the sky and 3 ",(0,o.kt)("inlineCode",{parentName:"p"},"TilingSprite"),"s for the parallax layers of the platform, the mid-ground and the background."),(0,o.kt)("p",null,"Again, a Scene class has been set up on another file with a view container added. And since we already preloaded all the required assets, we can go straight to the action."),(0,o.kt)("p",null,"We will establish the scene from bottom up so we are going to anchor all element at the bottom right corner."),(0,o.kt)("h2",{id:"sky"},"Sky"),(0,o.kt)("p",null,"Create the sky sprite, set the anchor as mentioned and use the passed in scene width and height as dimensions to fill up the whole scene."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"this.sky = Sprite.from('sky');\nthis.sky.anchor.set(0, 1);\nthis.sky.width = width;\nthis.sky.height = height;\n")),(0,o.kt)("h2",{id:"parallax-layers"},"Parallax Layers"),(0,o.kt)("p",null,"For the parallax layers, we begin by creating ",(0,o.kt)("inlineCode",{parentName:"p"},"Texture"),"s from the preloaded assets."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const backgroundTexture = Texture.from('background');\nconst midgroundTexture = Texture.from('midground');\nconst platformTexture = Texture.from('platform');\n")),(0,o.kt)("p",null,"We then calculate the ideal platform height which is 40% of the scene height but not exceeding the platform texture height. And then calculate a scale that we need to apply to the platform tiling texture to get it to the ideal height, which we also apply to other parallax layers for visual consistency."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const maxPlatformHeight = platformTexture.height;\nconst platformHeight = Math.min(maxPlatformHeight, height * 0.4);\nconst scale = this.scale = platformHeight / maxPlatformHeight;\n")),(0,o.kt)("p",null,"Now we can create the ",(0,o.kt)("inlineCode",{parentName:"p"},"TilingSprite")," objects from the defined textures and parameters."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const baseOptions = {\n    tileScale: { x: scale, y: scale },\n    anchor: { x: 0, y: 1 },\n    applyAnchorToTexture: true,\n};\n\nthis.background = new TilingSprite({\n    texture: backgroundTexture,\n    width,\n    height: backgroundTexture.height * scale,\n    ...baseOptions,\n});\nthis.midground = new TilingSprite({\n    texture: midgroundTexture,\n    width,\n    height: midgroundTexture.height * scale,\n    ...baseOptions,\n});\nthis.platform = new TilingSprite({\n    texture: platformTexture,\n    width,\n    height: platformHeight,\n    ...baseOptions,\n});\n")),(0,o.kt)("p",null,"After that, we need to horizontally offset the mid-ground and background layers to be just above the platform floor. Unfortunately, the platform tiling texture also includes the lamp element so we have to manually define the true height from the bottom of the platform to the floor surface. Let's store this as a member of the class, ",(0,o.kt)("inlineCode",{parentName:"p"},"floorHeight"),", for external uses as well."),(0,o.kt)("p",null,"Then to wrap up the scene class, we just need to offset the mentioned layers up a ",(0,o.kt)("inlineCode",{parentName:"p"},"floorHeight")," amount and add all layers to the main view."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"this.floorHeight = platformHeight * 0.43;\nthis.background.y = this.midground.y = -this.floorHeight;\nthis.view.addChild(this.sky, this.background, this.midground, this.platform);\n")),(0,o.kt)("h2",{id:"adding-the-scene"},"Adding the Scene"),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"index.js")," has already been updated to instantiate the scene and add it to the stage before the character."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const scene = new Scene(app.screen.width, app.screen.height);\n\napp.stage.addChild(scene.view, spineBoy.view);\n")),(0,o.kt)("p",null,"The scene is then placed at the bottom the screen and the character's transformation has been updated to take into account the platform floor height and the scene scaling."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"scene.view.y = app.screen.height;\nspineBoy.view.x = app.screen.width / 2;\nspineBoy.view.y = app.screen.height - scene.floorHeight;\nspineBoy.spine.scale.set(scene.scale * 0.32);\n")))}Fe.isMDXComponent=!0;const ze={toc:[{value:"Getter",id:"getter",level:3},{value:"Setter",id:"setter",level:3}]};function Ye(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},ze,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"animating-scene"},"Animating Scene"),(0,o.kt)("p",null,"Last but not least, we need to match the ",(0,o.kt)("inlineCode",{parentName:"p"},"Scene")," scroll according to the character movement state."),(0,o.kt)("p",null,"Lets begin by having an unified ",(0,o.kt)("inlineCode",{parentName:"p"},"positionX")," property for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Scene")," class. For the getter, this will simply return the ",(0,o.kt)("inlineCode",{parentName:"p"},"tilePosition.x")," of the platform ",(0,o.kt)("inlineCode",{parentName:"p"},"TilingSprite"),", and similarly for the setter we set its ",(0,o.kt)("inlineCode",{parentName:"p"},"tilePosition.x")," directly but also so set ",(0,o.kt)("inlineCode",{parentName:"p"},"tilePosition.x")," of the mid-ground and the background ",(0,o.kt)("inlineCode",{parentName:"p"},"TilingSprite"),"s at descending fractions of the value. This is to create a parallax scrolling effect for the backdrop layers as the platform horizontal position changes."),(0,o.kt)("h3",{id:"getter"},"Getter"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"return this.platform.tilePosition.x;\n")),(0,o.kt)("h3",{id:"setter"},"Setter"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"this.background.tilePosition.x = value * 0.1;\nthis.midground.tilePosition.x = value * 0.25;\nthis.platform.tilePosition.x = value;\n")),(0,o.kt)("p",null,"Then on the main ",(0,o.kt)("inlineCode",{parentName:"p"},"index.js"),", let's manipulate this ",(0,o.kt)("inlineCode",{parentName:"p"},"positionX")," property at the end of the application's ticker callback to animate the scrolling accordingly. Here, we will use 3 different scrolling speeds for character's ",(0,o.kt)("inlineCode",{parentName:"p"},"walk"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"run")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"hover")," state. We need to also add to or subtract from the property depending on the direction/"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"let speed = 1.25;\n\nif (spineBoy.state.hover) speed = 7.5;\nelse if (spineBoy.state.run) speed = 3.75;\n\nif (spineBoy.state.walk)\n{\n    scene.positionX -= speed * scene.scale * spineBoy.direction;\n}\n")),(0,o.kt)("p",null,"Et voil\xe0, we have a fully interactive side-scrolling experience! Have a play around with your own adventure creation."))}Ye.isMDXComponent=!0;const Je={toc:[]};function _e(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},Je,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"you-did-it"},"You did it!"),(0,o.kt)("p",null,"Congratulations, we hope the adventure was worthwhile! There is so much more Spine and the Pixi Spine plugin can do so please feel free to check out Esoteric's official ",(0,o.kt)("a",{parentName:"p",href:"https://esotericsoftware.com/spine-api-reference"},"Spine runtime API documentation")," and explore our ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/pixijs/spine-v8/tree/main/examples"},"Pixi Spine examples"),"."),(0,o.kt)("p",null,"Please also checkout our full list of plugins, libraries and tools in our ecosystem on the site navigation bar at the top."))}_e.isMDXComponent=!0;const Ue={"v7.0.0":m,"v8.0.0":{gettingStarted:{description:"Learn the basics of how to use PixiJS.",thumbnail:"thumb_getting_started.png",steps:Ae},fishPond:{description:"Let's create a lively fish pond!",thumbnail:"thumb_fish_pond.png",steps:ye},chooChooTrain:{description:"Onboard the graphical Choo Choo Train!",thumbnail:"thumb_choo_choo_train.png",steps:K},spineBoyAdventure:{description:"Behold the power of interactive Spine animation!",thumbnail:"thumb_spineboy_adventure.png",steps:[{header:"Introduction",Content:Be,code:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n})();\n"},{header:"Setting Up Character",Content:Ee,code:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    /** -- INSERT CODE HERE -- */\n})();\n","src/SpineBoy.js*":"import { Spine } from '@pixi/spine-pixi';\nimport { Container } from 'pixi.js';\n\n// Class for handling the character Spine and its animations.\nexport class SpineBoy\n{\n    constructor()\n    {\n        // Create the main view.\n        this.view = new Container();\n\n        /** -- INSERT CODE HERE -- */\n    }\n}\n"},completedCode:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust character transformation.\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - 80;\n    spineBoy.spine.scale.set(0.5);\n\n    // Add character to the stage.\n    app.stage.addChild(spineBoy.view);\n})();\n","src/SpineBoy.js*":Ne}},{header:"Adding Keyboard Controller",Content:Xe,code:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\nimport { Controller } from './Controller';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust views' transformation.\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - 80;\n    spineBoy.spine.scale.set(0.5);\n\n    // Add character to the stage.\n    app.stage.addChild(spineBoy.view);\n\n    /** -- INSERT CODE HERE -- */\n})();\n","src/SpineBoy.js":Ne,"src/Controller.js*":"// Map keyboard key codes to controller's state keys\nconst keyMap = {\n    Space: 'space',\n    KeyW: 'up',\n    ArrowUp: 'up',\n    KeyA: 'left',\n    ArrowLeft: 'left',\n    KeyS: 'down',\n    ArrowDown: 'down',\n    KeyD: 'right',\n    ArrowRight: 'right',\n};\n\n// Class for handling keyboard inputs.\nexport class Controller\n{\n    constructor()\n    {\n        // The controller's state.\n        this.keys = {\n            up: { pressed: false, doubleTap: false, timestamp: 0 },\n            left: { pressed: false, doubleTap: false, timestamp: 0 },\n            down: { pressed: false, doubleTap: false, timestamp: 0 },\n            right: { pressed: false, doubleTap: false, timestamp: 0 },\n            space: { pressed: false, doubleTap: false, timestamp: 0 },\n        };\n\n        // Register event listeners for keydown and keyup events.\n        window.addEventListener('keydown', (event) => this.keydownHandler(event));\n        window.addEventListener('keyup', (event) => this.keyupHandler(event));\n    }\n\n    keydownHandler(event)\n    {\n        /** -- INSERT CODE HERE -- */\n    }\n\n    keyupHandler(event)\n    {\n        /** -- INSERT CODE HERE -- */\n    }\n}\n"},completedCode:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\nimport { Controller } from './Controller';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create a controller that handles keyboard inputs.\n    const controller = new Controller();\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust views' transformation.\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - 80;\n    spineBoy.spine.scale.set(0.5);\n\n    // Add character to the stage.\n    app.stage.addChild(spineBoy.view);\n\n    let currentAnimation;\n\n    // Animate the character - just testing the controller at this point\n    app.ticker.add((time) =>\n    {\n        const rightPressed = controller.keys.right.pressed;\n        const animationName = rightPressed ? 'walk' : 'idle';\n        const loop = true;\n\n        // Apply the animation if it's different from the active one.\n        if (currentAnimation !== animationName)\n        {\n            // Store the current animation name.\n            currentAnimation = animationName;\n\n            // Animate the character spine based on the right key state,\n            spineBoy.spine.state.setAnimation(0, animationName, loop);\n        }\n    });\n})();\n","src/SpineBoy.js":Ne,"src/Controller.js*":Me}},{header:"Animating Character",Content:Oe,code:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\nimport { Controller } from './Controller';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create a controller that handles keyboard inputs.\n    const controller = new Controller();\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust views' transformation.\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - 80;\n    spineBoy.spine.scale.set(0.5);\n\n    // Add character to the stage.\n    app.stage.addChild(spineBoy.view);\n\n    // Trigger character's spawn animation.\n    spineBoy.spawn();\n\n    // Animate the character based on the controller's input.\n    app.ticker.add(() =>\n    {\n        /** -- INSERT CODE HERE -- */\n    });\n})();\n","src/SpineBoy.js*":"import { Spine } from '@pixi/spine-pixi';\nimport { Container } from 'pixi.js';\n\n// Define the Spine animation map for the character.\n// name: animation track key.\n// loop: do the animation once or infinitely.\nconst animationMap = {\n    idle: {\n        name: 'idle',\n        loop: true,\n    },\n    walk: {\n        name: 'walk',\n        loop: true,\n    },\n    run: {\n        name: 'run',\n        loop: true,\n    },\n    jump: {\n        name: 'jump',\n        timeScale: 1.5,\n    },\n    hover: {\n        name: 'hoverboard',\n        loop: true,\n    },\n    spawn: {\n        name: 'portal',\n    },\n};\n\n// Class for handling the character Spine and its animations.\nexport class SpineBoy\n{\n    constructor()\n    {\n        // The character's state.\n        this.state = {\n            walk: false,\n            run: false,\n            hover: false,\n            jump: false,\n        };\n\n        // Create the main view and a nested view for directional scaling.\n        this.view = new Container();\n        this.directionalView = new Container();\n\n        // Create the Spine instance using the preloaded Spine asset aliases.\n        this.spine = Spine.from({\n            skeleton: 'spineSkeleton',\n            atlas: 'spineAtlas',\n        });\n\n        // Add the Spine instance to the directional view.\n        this.directionalView.addChild(this.spine);\n\n        // Add the directional view to the main view.\n        this.view.addChild(this.directionalView);\n\n        // Set the default mix duration for all animations.\n        // This is the duration to blend from the previous animation to the next.\n        this.spine.state.data.defaultMix = 0.2;\n    }\n\n    // Play the portal-in spawn animation.\n    spawn()\n    {\n        this.spine.state.setAnimation(0, animationMap.spawn.name);\n    }\n\n    // Play the spine animation.\n    playAnimation({ name, loop = false, timeScale = 1 })\n    {\n        // Skip if the animation is already playing.\n        if (this.currentAnimationName === name) return;\n\n        // Play the animation on main track instantly.\n        const trackEntry = this.spine.state.setAnimation(0, name, loop);\n\n        // Apply the animation's time scale (speed).\n        trackEntry.timeScale = timeScale;\n    }\n\n    update()\n    {\n        /** -- INSERT CODE HERE -- */\n    }\n\n    isSpawning()\n    {\n        return this.isAnimationPlaying(animationMap.spawn);\n    }\n\n    isAnimationPlaying({ name })\n    {\n        // Check if the current animation on main track equals to the queried.\n        // Also check if the animation is still ongoing.\n        return this.currentAnimationName === name && !this.spine.state.getCurrent(0).isComplete();\n    }\n\n    // Return the name of the current animation on main track.\n    get currentAnimationName()\n    {\n        return this.spine.state.getCurrent(0)?.animation.name;\n    }\n\n    // Return character's facing direction.\n    get direction()\n    {\n        return this.directionalView.scale.x > 0 ? 1 : -1;\n    }\n\n    // Set character's facing direction.\n    set direction(value)\n    {\n        this.directionalView.scale.x = value;\n    }\n}\n","src/Controller.js":Me},completedCode:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\nimport { Controller } from './Controller';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create a controller that handles keyboard inputs.\n    const controller = new Controller();\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust views' transformation.\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - 80;\n    spineBoy.spine.scale.set(0.5);\n\n    // Add character to the stage.\n    app.stage.addChild(spineBoy.view);\n\n    // Trigger character's spawn animation.\n    spineBoy.spawn();\n\n    // Animate the character based on the controller's input.\n    app.ticker.add(() =>\n    {\n        // Ignore the update loops while the character is doing the spawn animation.\n        if (spineBoy.isSpawning()) return;\n\n        // Update character's state based on the controller's input.\n        spineBoy.state.walk = controller.keys.left.pressed || controller.keys.right.pressed;\n        if (spineBoy.state.run && spineBoy.state.walk) spineBoy.state.run = true;\n        else spineBoy.state.run = controller.keys.left.doubleTap || controller.keys.right.doubleTap;\n        spineBoy.state.hover = controller.keys.down.pressed;\n        if (controller.keys.left.pressed) spineBoy.direction = -1;\n        else if (controller.keys.right.pressed) spineBoy.direction = 1;\n        spineBoy.state.jump = controller.keys.space.pressed;\n\n        // Update character's animation based on the latest state.\n        spineBoy.update();\n    });\n})();\n","src/SpineBoy.js*":He,"src/Controller.js":Me}},{header:"Setting Up Scene",Content:Fe,code:{index:We,"src/SpineBoy.js":He,"src/Controller.js":Me,"src/Scene.js*":"import { Container, Sprite, Texture, TilingSprite } from 'pixi.js';\n\n// Class for handling the environment.\nexport class Scene\n{\n    constructor(width, height)\n    {\n        // Create a main view that holds all layers.\n        this.view = new Container();\n\n        /** -- INSERT CODE HERE -- */\n    }\n}\n"},completedCode:{index:We,"src/SpineBoy.js":He,"src/Controller.js":Me,"src/Scene.js*":"import { Container, Sprite, Texture, TilingSprite } from 'pixi.js';\n\n// Class for handling the environment.\nexport class Scene\n{\n    constructor(width, height)\n    {\n        // Create a main view that holds all layers.\n        this.view = new Container();\n\n        // Create the stationary sky that fills the entire screen.\n        this.sky = Sprite.from('sky');\n        this.sky.anchor.set(0, 1);\n        this.sky.width = width;\n        this.sky.height = height;\n\n        // Create textures for the background, mid-ground, and platform.\n        const backgroundTexture = Texture.from('background');\n        const midgroundTexture = Texture.from('midground');\n        const platformTexture = Texture.from('platform');\n\n        // Calculate the ideal platform height depending on the passed-in screen height.\n        const maxPlatformHeight = platformTexture.height;\n        const platformHeight = Math.min(maxPlatformHeight, height * 0.4);\n\n        // Calculate the scale to be apply to all tiling textures for consistency.\n        const scale = (this.scale = platformHeight / maxPlatformHeight);\n\n        const baseOptions = {\n            tileScale: { x: scale, y: scale },\n            anchor: { x: 0, y: 1 },\n            applyAnchorToTexture: true,\n        };\n\n        // Create the tiling sprite layers.\n        this.background = new TilingSprite({\n            texture: backgroundTexture,\n            width,\n            height: backgroundTexture.height * scale,\n            ...baseOptions,\n        });\n        this.midground = new TilingSprite({\n            texture: midgroundTexture,\n            width,\n            height: midgroundTexture.height * scale,\n            ...baseOptions,\n        });\n        this.platform = new TilingSprite({\n            texture: platformTexture,\n            width,\n            height: platformHeight,\n            ...baseOptions,\n        });\n\n        // Calculate the floor height for external referencing.\n        this.floorHeight = platformHeight * 0.43;\n\n        // Position the backdrop layers.\n        this.background.y = this.midground.y = -this.floorHeight;\n\n        // Add all layers to the main view.\n        this.view.addChild(this.sky, this.background, this.midground, this.platform);\n    }\n}\n"}},{header:"Animating Scene",Content:Ye,code:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\nimport { Controller } from './Controller';\nimport { Scene } from './Scene';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create a controller that handles keyboard inputs.\n    const controller = new Controller();\n\n    // Create a scene that holds the environment.\n    const scene = new Scene(app.screen.width, app.screen.height);\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust views' transformation.\n    scene.view.y = app.screen.height;\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - scene.floorHeight;\n    spineBoy.spine.scale.set(scene.scale * 0.32);\n\n    // Add scene and character to the stage.\n    app.stage.addChild(scene.view, spineBoy.view);\n\n    // Trigger character's spawn animation.\n    spineBoy.spawn();\n\n    // Animate the scene and the character based on the controller's input.\n    app.ticker.add(() =>\n    {\n        // Ignore the update loops while the character is doing the spawn animation.\n        if (spineBoy.isSpawning()) return;\n\n        // Update character's state based on the controller's input.\n        spineBoy.state.walk = controller.keys.left.pressed || controller.keys.right.pressed;\n        if (spineBoy.state.run && spineBoy.state.walk) spineBoy.state.run = true;\n        else spineBoy.state.run = controller.keys.left.doubleTap || controller.keys.right.doubleTap;\n        spineBoy.state.hover = controller.keys.down.pressed;\n        if (controller.keys.left.pressed) spineBoy.direction = -1;\n        else if (controller.keys.right.pressed) spineBoy.direction = 1;\n        spineBoy.state.jump = controller.keys.space.pressed;\n\n        // Update character's animation based on the latest state.\n        spineBoy.update();\n\n        /** -- INSERT CODE HERE -- */\n    });\n})();\n","src/SpineBoy.js":He,"src/Controller.js":Me,"src/Scene.js":"import { Container, Sprite, Texture, TilingSprite } from 'pixi.js';\n\n// Class for handling the environment.\nexport class Scene\n{\n    constructor(width, height)\n    {\n        // Create a main view that holds all layers.\n        this.view = new Container();\n\n        // Create the stationary sky that fills the entire screen.\n        this.sky = Sprite.from('sky');\n        this.sky.anchor.set(0, 1);\n        this.sky.width = width;\n        this.sky.height = height;\n\n        // Create textures for the background, mid-ground, and platform.\n        const backgroundTexture = Texture.from('background');\n        const midgroundTexture = Texture.from('midground');\n        const platformTexture = Texture.from('platform');\n\n        // Calculate the ideal platform height depending on the passed-in screen height.\n        const maxPlatformHeight = platformTexture.height;\n        const platformHeight = Math.min(maxPlatformHeight, height * 0.4);\n\n        // Calculate the scale to be apply to all tiling textures for consistency.\n        const scale = (this.scale = platformHeight / maxPlatformHeight);\n\n        const baseOptions = {\n            tileScale: { x: scale, y: scale },\n            anchor: { x: 0, y: 1 },\n            applyAnchorToTexture: true,\n        };\n\n        // Create the tiling sprite layers.\n        this.background = new TilingSprite({\n            texture: backgroundTexture,\n            width,\n            height: backgroundTexture.height * scale,\n            ...baseOptions,\n        });\n        this.midground = new TilingSprite({\n            texture: midgroundTexture,\n            width,\n            height: midgroundTexture.height * scale,\n            ...baseOptions,\n        });\n        this.platform = new TilingSprite({\n            texture: platformTexture,\n            width,\n            height: platformHeight,\n            ...baseOptions,\n        });\n\n        // Calculate the floor height for external referencing.\n        this.floorHeight = platformHeight * 0.43;\n\n        // Position the backdrop layers.\n        this.background.y = this.midground.y = -this.floorHeight;\n\n        // Add all layers to the main view.\n        this.view.addChild(this.sky, this.background, this.midground, this.platform);\n    }\n\n    // Use the platform's horizontal position as the key position for the scene.\n    get positionX()\n    {\n        /** -- INSERT CODE HERE -- */\n    }\n\n    // Set the horizontal position of the platform layer while applying parallax scrolling to the backdrop layers.\n    set positionX(value)\n    {\n        /** -- INSERT CODE HERE -- */\n    }\n}\n"},completedCode:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\nimport { Controller } from './Controller';\nimport { Scene } from './Scene';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create a controller that handles keyboard inputs.\n    const controller = new Controller();\n\n    // Create a scene that holds the environment.\n    const scene = new Scene(app.screen.width, app.screen.height);\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust views' transformation.\n    scene.view.y = app.screen.height;\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - scene.floorHeight;\n    spineBoy.spine.scale.set(scene.scale * 0.32);\n\n    // Add scene and character to the stage.\n    app.stage.addChild(scene.view, spineBoy.view);\n\n    // Trigger character's spawn animation.\n    spineBoy.spawn();\n\n    // Animate the scene and the character based on the controller's input.\n    app.ticker.add(() =>\n    {\n        // Ignore the update loops while the character is doing the spawn animation.\n        if (spineBoy.isSpawning()) return;\n\n        // Update character's state based on the controller's input.\n        spineBoy.state.walk = controller.keys.left.pressed || controller.keys.right.pressed;\n        if (spineBoy.state.run && spineBoy.state.walk) spineBoy.state.run = true;\n        else spineBoy.state.run = controller.keys.left.doubleTap || controller.keys.right.doubleTap;\n        spineBoy.state.hover = controller.keys.down.pressed;\n        if (controller.keys.left.pressed) spineBoy.direction = -1;\n        else if (controller.keys.right.pressed) spineBoy.direction = 1;\n        spineBoy.state.jump = controller.keys.space.pressed;\n\n        // Update character's animation based on the latest state.\n        spineBoy.update();\n\n        // Determine the scene's horizontal scrolling speed based on the character's state.\n        let speed = 1.25;\n\n        if (spineBoy.state.hover) speed = 7.5;\n        else if (spineBoy.state.run) speed = 3.75;\n\n        // Shift the scene's position based on the character's facing direction, if in a movement state.\n        if (spineBoy.state.walk) scene.positionX -= speed * scene.scale * spineBoy.direction;\n    });\n})();\n","src/SpineBoy.js":He,"src/Controller.js":Me,"src/Scene.js":De}},{header:"You did it!",Content:_e,code:{index:"import '@pixi/spine-pixi';\n\nimport { Application, Assets } from 'pixi.js';\nimport { SpineBoy } from './SpineBoy';\nimport { Controller } from './Controller';\nimport { Scene } from './Scene';\n\n// Asynchronous IIFE\n(async () =>\n{\n    // Create a PixiJS application.\n    const app = new Application();\n\n    // Intialize the application.\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n\n    // Load the assets.\n    await Assets.load([\n        {\n            alias: 'spineSkeleton',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel',\n        },\n        {\n            alias: 'spineAtlas',\n            src: 'https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas',\n        },\n        {\n            alias: 'sky',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png',\n        },\n        {\n            alias: 'background',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/background.png',\n        },\n        {\n            alias: 'midground',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png',\n        },\n        {\n            alias: 'platform',\n            src: 'https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png',\n        },\n    ]);\n\n    // Create a controller that handles keyboard inputs.\n    const controller = new Controller();\n\n    // Create a scene that holds the environment.\n    const scene = new Scene(app.screen.width, app.screen.height);\n\n    // Create our character\n    const spineBoy = new SpineBoy();\n\n    // Adjust views' transformation.\n    scene.view.y = app.screen.height;\n    spineBoy.view.x = app.screen.width / 2;\n    spineBoy.view.y = app.screen.height - scene.floorHeight;\n    spineBoy.spine.scale.set(scene.scale * 0.32);\n\n    // Add scene and character to the stage.\n    app.stage.addChild(scene.view, spineBoy.view);\n\n    // Trigger character's spawn animation.\n    spineBoy.spawn();\n\n    // Animate the scene and the character based on the controller's input.\n    app.ticker.add(() =>\n    {\n        // Ignore the update loops while the character is doing the spawn animation.\n        if (spineBoy.isSpawning()) return;\n\n        // Update character's state based on the controller's input.\n        spineBoy.state.walk = controller.keys.left.pressed || controller.keys.right.pressed;\n        if (spineBoy.state.run && spineBoy.state.walk) spineBoy.state.run = true;\n        else spineBoy.state.run = controller.keys.left.doubleTap || controller.keys.right.doubleTap;\n        spineBoy.state.hover = controller.keys.down.pressed;\n        if (controller.keys.left.pressed) spineBoy.direction = -1;\n        else if (controller.keys.right.pressed) spineBoy.direction = 1;\n        spineBoy.state.jump = controller.keys.space.pressed;\n\n        // Update character's animation based on the latest state.\n        spineBoy.update();\n\n        // Determine the scene's horizontal scrolling speed based on the character's state.\n        let speed = 1.25;\n\n        if (spineBoy.state.hover) speed = 7.5;\n        else if (spineBoy.state.run) speed = 3.75;\n\n        // Shift the scene's position based on the character's facing direction, if in a movement state.\n        if (spineBoy.state.walk) scene.positionX -= speed * scene.scale * spineBoy.direction;\n    });\n})();\n","src/SpineBoy.js":He,"src/Controller.js":Me,"src/Scene.js":De}}],extraPackages:{"@pixi/spine-pixi":"^1.0.4"}}}};function Ze(e){const n=(0,a.prerelease)(e)?`${(0,a.major)(e)}.${(0,a.minor)(e)}.${(0,a.patch)(e)}`:e,t=Object.keys(Ue).filter((e=>(0,a.valid)(e)&&(0,a.lte)(e,n))).sort(((e,n)=>(0,a.rcompare)(e,n)))[0];return Ue[t]}function qe(e,n){const t=Ze(e);return null==t?void 0:t[n]}function Ve(e){const n=Ze(e),t=[];for(const a in n){const e=n[a],{description:i,thumbnail:o}=e;t.push({title:a,description:i,thumbnail:o})}return t}},9567:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>p,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=t(7462),i=(t(7294),t(3905)),o=t(5103),s=t(7949);const r={hide_title:!0,pagination_next:null,pagination_prev:null,custom_edit_url:null},p=void 0,l={unversionedId:"tutorials/getting-started",id:"tutorials/getting-started",title:"getting-started",description:"",source:"@site/docs/tutorials/getting-started.md",sourceDirName:"tutorials",slug:"/tutorials/getting-started",permalink:"/8.x/tutorials/getting-started",draft:!1,editUrl:null,tags:[],version:"current",frontMatter:{hide_title:!0,pagination_next:null,pagination_prev:null,custom_edit_url:null}},d={},c=[],h={toc:c};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(o.Z,{id:"gettingStarted",pixiVersion:s,mdxType:"Tutorial"}))}u.isMDXComponent=!0},7949:e=>{e.exports=JSON.parse('{"versionLabel":"v8.x","version":"8.5.0","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v8.5.0","build":"https://pixijs.download/v8.5.0/pixi.min.js","docs":"https://pixijs.download/v8.5.0/docs/index.html","npm":"8.5.0","prerelease":false,"latest":true}')}}]);