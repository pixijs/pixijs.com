"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["3849"],{39867:function(e,n,r){r.r(n),r.d(n,{default:()=>u,frontMatter:()=>s,metadata:()=>t,assets:()=>l,toc:()=>m,contentTitle:()=>d});var t=JSON.parse('{"id":"examples/mesh-and-shaders/multipass-mesh","title":"Multipass Mesh","description":"<ExampleEditor files={{","source":"@site/docs/examples/mesh-and-shaders/multipass-mesh.mdx","sourceDirName":"examples/mesh-and-shaders","slug":"/examples/mesh-and-shaders/multipass-mesh","permalink":"/8.x/examples/mesh-and-shaders/multipass-mesh","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"sidebar_position":10,"custom_edit_url":null,"title":"Multipass Mesh"},"sidebar":"examplesSidebar","previous":{"title":"Shader Toy Mesh","permalink":"/8.x/examples/mesh-and-shaders/shader-toy-mesh"},"next":{"title":"Texture Rotate","permalink":"/8.x/examples/textures/texture-rotate"}}'),i=r("85893"),a=r("50065"),o=r("67963");let s={hide_table_of_contents:!0,hide_edit_this_page:!0,sidebar_position:10,custom_edit_url:null,title:"Multipass Mesh"},d=void 0,l={},m=[];function p(e){return(0,i.jsx)(o.N,{files:{"index.js":"import { Application, Assets, Container, Geometry, Mesh, RenderTexture, Shader } from 'pixi.js';\nimport combineFragment from './combine.frag';\nimport gridFragment from './grid.frag';\nimport vertex from './multipassMesh.vert';\nimport noiseFragment from './noise.frag';\nimport rippleFragment from './ripple.frag';\nimport waveFragment from './wave.frag';\n\n(async () =>\n{\n    const app = new Application();\n\n    await app.init({ height: 640, resizeTo: window, preference: 'webgl' });\n\n    document.body.appendChild(app.view);\n\n    // Build geometry.\n    const geometry = new Geometry({\n        attributes: {\n            aPosition: [\n                0,\n                0, // x, y\n                200,\n                0, // x, y\n                200,\n                200, // x, y,\n                0,\n                200, // x, y,\n            ],\n            aUV: [0, 0, 1, 0, 1, 1, 0, 1],\n        },\n        indexBuffer: [0, 1, 2, 0, 2, 3],\n    });\n\n    // Load a perlinnoise texture for one of the shaders.\n    const perlinTexture = await Assets.load('https://pixijs.com/assets/perlin.jpg');\n\n    const gridShader = Shader.from({\n        gl: {\n            // Vertex shader. Use same shader for all passes.\n            vertex,\n            // First pass, generates a grid.\n            fragment: gridFragment,\n        },\n        resources: {\n            gridUniforms: {\n                zoom: { type: 'f32', value: 10 },\n            },\n        },\n    });\n\n    // Sharing textures and meshes is possible.\n    // But for simplicity each pass has its own output texture and mesh in this example.\n    const gridTexture = RenderTexture.create({ width: 200, height: 200 });\n    const gridQuad = new Mesh({ geometry, shader: gridShader });\n    const gridContainer = new Container();\n\n    gridContainer.addChild(gridQuad);\n\n    const rippleShader = Shader.from({\n        gl: {\n            vertex,\n            // Second pass. Takes grid as input and makes it ripple.\n            fragment: rippleFragment,\n        },\n        resources: {\n            rippleUniforms: {\n                amount: { type: 'f32', value: 0.5 },\n                phase: { type: 'f32', value: 0 },\n            },\n            texIn: gridTexture.source,\n        },\n    });\n\n    const rippleTexture = RenderTexture.create({ width: 200, height: 200 });\n    const rippleQuad = new Mesh({ geometry, shader: rippleShader });\n    const rippleContainer = new Container();\n\n    rippleContainer.addChild(rippleQuad);\n\n    const noiseShader = Shader.from({\n        gl: {\n            vertex,\n            // Second effect. Generates a filtered noise.\n            fragment: noiseFragment,\n        },\n        resources: {\n            noiseUniforms: {\n                limit: { type: 'f32', value: 0.5 },\n            },\n            noise: perlinTexture.source,\n        },\n    });\n\n    const noiseTexture = RenderTexture.create({ width: 200, height: 200 });\n    const noiseQuad = new Mesh({ geometry, shader: noiseShader });\n    const noiseContainer = new Container();\n\n    noiseContainer.addChild(noiseQuad);\n\n    const waveShader = Shader.from({\n        gl: {\n            vertex,\n            // Third effect\n            fragment: waveFragment,\n        },\n        resources: {\n            waveUniforms: {\n                amplitude: { type: 'f32', value: 0.75 },\n                time: { type: 'f32', value: 0 },\n            },\n        },\n    });\n\n    const waveTexture = RenderTexture.create({ width: 200, height: 200 });\n    const waveQuad = new Mesh(geometry, waveShader);\n    const waveContainer = new Container();\n\n    waveContainer.addChild(waveQuad);\n\n    const combineShader = Shader.from({\n        gl: {\n            vertex,\n            // Final combination pass\n            fragment: combineFragment,\n        },\n        resources: {\n            texRipple: rippleTexture.source,\n            texNoise: noiseTexture.source,\n            texWave: waveTexture.source,\n        },\n    });\n\n    const combineQuad = new Mesh(geometry, combineShader);\n\n    gridContainer.position.set(10, 10);\n    rippleContainer.position.set(220, 10);\n    noiseContainer.position.set(10, 220);\n    waveContainer.position.set(10, 430);\n    combineQuad.position.set(430, 220);\n\n    // Add all phases to stage so all the phases can be seen separately.\n    app.stage.addChild(gridContainer);\n    app.stage.addChild(rippleContainer);\n    app.stage.addChild(noiseContainer);\n    app.stage.addChild(waveContainer);\n    app.stage.addChild(combineQuad);\n\n    // start the animation..\n    let time = 0;\n\n    app.ticker.add(() =>\n    {\n        time += 1 / 60;\n        gridQuad.shader.resources.gridUniforms.uniforms.zoom = Math.sin(time) * 5 + 10;\n        rippleQuad.shader.resources.rippleUniforms.phase = -time;\n        waveQuad.shader.resources.waveUniforms.uniforms.time = time;\n        noiseQuad.shader.resources.noiseUniforms.uniforms.limit = Math.sin(time * 0.5) * 0.35 + 0.5;\n\n        // Render the passes to get textures.\n        app.renderer.render({\n            container: gridQuad,\n            target: gridTexture,\n        });\n\n        app.renderer.render({\n            container: rippleQuad,\n            target: rippleTexture,\n        });\n\n        app.renderer.render({\n            container: noiseQuad,\n            target: noiseTexture,\n        });\n\n        app.renderer.render({\n            container: waveQuad,\n            target: waveTexture,\n        });\n    });\n})();\n","multipassMesh.vert":"precision mediump float;\n\nattribute vec2 aPosition;\nattribute vec2 aUV;\n\nuniform mat3 uProjectionMatrix;\nuniform mat3 uWorldTransformMatrix;\nuniform mat3 uTransformMatrix;\n\nvarying vec2 vUvs;\n\nvoid main() {\n    vUvs = aUV;\n    mat3 mvp = uProjectionMatrix * uWorldTransformMatrix * uTransformMatrix;\n    gl_Position = vec4((mvp * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n}","grid.frag":"precision mediump float;\nvarying vec2 vUvs;\nuniform float zoom;\n\nvoid main()\n{\n    //Generate a simple grid.\n    //Offset uv so that center is 0,0 and edges are -1,1\n    vec2 uv = (vUvs-vec2(0.5))*2.0;\n    vec2 gUv = floor(uv*zoom);\n    vec4 color1 = vec4(0.8, 0.8, 0.8, 1.0);\n    vec4 color2 = vec4(0.4, 0.4, 0.4, 1.0);\n    vec4 outColor = mod(gUv.x + gUv.y, 2.) < 0.5 ? color1 : color2;\n    finalColor = outColor;\n\n}","ripple.frag":"precision mediump float;\nvarying vec2 vUvs;\nuniform float amount;\nuniform float phase;\nuniform sampler2D texIn;\n\nvoid main()\n{\n    //Generate a simple grid.\n    vec2 uv = vUvs;\n    //Calculate distance from center\n    float distance = length( uv - vec2(0.5));\n    vec4 color = texture2D(texIn, uv);\n    color.rgb *= sin(distance*25.0+phase) * amount+1.;\n    finalColor = color;\n}","noise.frag":"precision mediump float;\nvarying vec2 vUvs;\nuniform float limit;\nuniform sampler2D noise;\n\nvoid main()\n{\n    float color = texture2D(noise, vUvs).r;\n    color = step(limit, color);\n    gl_FragColor = vec4(color);\n}","wave.frag":"precision mediump float;\nvarying vec2 vUvs;\nuniform float amplitude;\nuniform float time;\n\nvoid main()\n{\n    //Offset uv so that center is 0,0 and edges are -1,1\n    vec2 uv = (vUvs-vec2(0.5))*2.0;\n\n    vec3 outColor = vec3(0.);\n\n    //Simple wavefunctions inversed and with small offsets.\n    outColor += 5./length(uv.y*200. - 50.0*sin( uv.x*0.25+ time*0.25)*amplitude);\n    outColor += 4./length(uv.y*300. - 100.0*sin(uv.x*0.5+time*0.5)*amplitude*1.2);\n    outColor += 3./length(uv.y*400. - 150.0*sin(uv.x*0.75+time*0.75)*amplitude*1.4);\n    outColor += 2./length(uv.y*500. - 200.0*sin(uv.x+time)*amplitude*1.6);\n\n    gl_FragColor = vec4(outColor,1.0);\n}","combine.frag":"precision mediump float;\nvarying vec2 vUvs;\n\nuniform sampler2D texRipple;\nuniform sampler2D texNoise;\nuniform sampler2D texWave;\n\nvoid main()\n{\n    //Read color from all\n    vec4 ripple = texture2D(texRipple, vUvs);\n    vec4 noise = texture2D(texNoise, vUvs);\n    vec4 wave = texture2D(texWave, vUvs);\n\n    gl_FragColor = mix(ripple, wave,noise.r);\n}"}})}function u(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);