"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["9260"],{37873:function(n,o,t){t.r(o),t.d(o,{frontMatter:()=>f,default:()=>h,toc:()=>m,metadata:()=>e,assets:()=>d,contentTitle:()=>x});var e=JSON.parse('{"id":"examples/text/text-filters","title":"Text Filters","description":"<ExampleEditor","source":"@site/docs/examples/text/text-filters.mdx","sourceDirName":"examples/text","slug":"/examples/text/text-filters","permalink":"/8.x/examples/text/text-filters","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":true,"hide_edit_this_page":true,"custom_edit_url":null,"title":"Text Filters"},"sidebar":"examplesSidebar","previous":{"title":"Web Font","permalink":"/8.x/examples/text/web-font"},"next":{"title":"SegmentedBitmapText Overlay","permalink":"/8.x/examples/text/text-split-bitmap-overlap"}}'),r=t(85893),i=t(50065),a=t(31531),l=t(57020),u=t(96302),s=t(50358),p=t(29021),c=t(12605);t(67294);let f={hide_table_of_contents:!0,hide_edit_this_page:!0,custom_edit_url:null,title:"Text Filters"},x=void 0,d={},m=[];function v(n){return(0,r.jsx)(a.N,{files:{"index.js":l.Z,"CartoonTextFilter.js":u.Z,"cartoonText.vert":s.Z,"cartoonText.frag":p.Z,"cartoonText.wgsl":c.Z}})}function h(n={}){let{wrapper:o}={...(0,i.a)(),...n.components};return o?(0,r.jsx)(o,{...n,children:(0,r.jsx)(v,{...n})}):v(n)}},96302:function(n,o,t){t.d(o,{Z:()=>e});let e="import { Color, Filter, GlProgram, GpuProgram, UniformGroup } from 'pixi.js';\nimport fragment from './cartoonText.frag?raw';\nimport vertex from './cartoonText.vert?raw';\nimport source from './cartoonText.wgsl?raw';\n\nconst defaultOptions = {\n  thickness: 1,\n  borderColor: 0xffffff,\n  topColor: 0xed427c,\n  bottomColor: 0xe91e63,\n};\n\n/**\n * CartoonTextFilter creates a cartoon-style text effect with outlines, shadows, and gradients.\n *\n * @example\n * ```js\n * import { CartoonTextFilter } from './CartoonTextFilter';\n *\n * const cartoonFilter = new CartoonTextFilter({\n *   thickness: 2.0,\n *   borderColor: 0x000000,\n *   topColor: 0xFFFFFF,\n *   bottomColor: 0x888888\n * });\n * text.filters = [cartoonFilter];\n * ```\n */\nexport class CartoonTextFilter extends Filter {\n  constructor(options) {\n    const { thickness, borderColor, topColor, bottomColor } = { ...defaultOptions, ...options };\n\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: 'mainVertex',\n      },\n      fragment: {\n        source,\n        entryPoint: 'mainFragment',\n      },\n    });\n\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: 'cartoon-text-filter',\n    });\n\n    super({\n      gpuProgram,\n      glProgram,\n      padding: thickness * 2.1,\n      resources: {\n        cartoonTextUniforms: new UniformGroup({\n          uThickness: { value: thickness, type: 'f32' },\n          uBorderColor: { value: new Color(borderColor), type: 'vec3<f32>' },\n          uTopColor: { value: new Color(topColor), type: 'vec3<f32>' },\n          uBottomColor: { value: new Color(bottomColor), type: 'vec3<f32>' },\n        }),\n      },\n    });\n  }\n\n  /**\n   * The thickness of the outline effect.\n   * @default 2.0\n   */\n  get thickness() {\n    const uniforms = this.resources.cartoonTextUniforms.uniforms;\n\n    return uniforms.uThickness;\n  }\n\n  set thickness(value) {\n    const uniforms = this.resources.cartoonTextUniforms.uniforms;\n\n    uniforms.uThickness = value;\n  }\n}\n"},29021:function(n,o,t){t.d(o,{Z:()=>e});let e="precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uThickness;\nuniform vec3 uBorderColor;\nuniform vec3 uTopColor;\nuniform vec3 uBottomColor;\n\nin vec2 vOut;\n\nuniform vec4 uInputClamp;\nuniform vec4 uInputSize;\n\nconst float DOUBLE_PI = 6.28318530718; // 2 * PI\nconst float ANGLE_STEP = 0.0628319;\n\nfloat outlineMaxAlphaAtPos(vec2 pos) {\n    vec2 thickness = vec2(uThickness) / uInputSize.xy;\n    float maxAlpha = 0.0;\n\n    for (float angle = 0.0; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        vec2 displacedPos = pos + thickness * vec2(cos(angle), sin(angle));\n        vec4 displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\nvoid main(void) {\n    vec4 contentColor = texture(uTexture, vTextureCoord);\n    vec2 thickness = uThickness / uInputSize.xy;\n    vec2 offset = vec2(0.0, thickness.y * 0.6);\n\n    float outlineAlpha = outlineMaxAlphaAtPos(vTextureCoord) * (1.0 - contentColor.a);\n    vec4 outlineColor = vec4(uBorderColor * outlineAlpha, outlineAlpha);\n\n    float outlineBaseAlpha = outlineMaxAlphaAtPos(vTextureCoord - offset);\n    vec4 outlineBaseColor = vec4(mix(uBorderColor, vec3(0.0), 0.35) * outlineBaseAlpha, outlineBaseAlpha);\n    outlineBaseColor *= (1.0 - outlineAlpha) * (1.0 - contentColor.a);\n\n    float outlineDropShadowAlpha = outlineMaxAlphaAtPos(vTextureCoord - (offset * 2.0));\n    vec4 outlineDropShadowColor = vec4(vec3(0.0) * outlineDropShadowAlpha, outlineDropShadowAlpha) * 0.3;\n    outlineDropShadowColor *= (1.0 - outlineAlpha) * (1.0 - contentColor.a);\n\n    vec4 innerShadowAlpha = texture(uTexture, vTextureCoord + vec2(0.0, -thickness.y * 0.35));\n    innerShadowAlpha.a = (1.0 - innerShadowAlpha.a) * contentColor.a;\n    vec4 innerShadowColor = vec4(vec3(0.0) * innerShadowAlpha.a, innerShadowAlpha.a) * 0.3;\n\n    float curveAmount = -0.05;\n    float horizonY = 0.54 + curveAmount * sin(vOut.x * 3.14159);\n    float gradientStart = horizonY - 0.005;\n    float gradientEnd = horizonY + 0.005;\n    float gradientRatio = smoothstep(gradientStart, gradientEnd, vOut.y);\n\n    vec4 gradientColor = mix(vec4(uTopColor, 1.0), vec4(uBottomColor, 1.0), gradientRatio);\n    gradientColor *= contentColor.a;\n\n    finalColor = mix(gradientColor, innerShadowColor, innerShadowColor.a) + outlineColor + outlineBaseColor + outlineDropShadowColor;\n}"},50358:function(n,o,t){t.d(o,{Z:()=>e});let e="in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vOut;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nvec4 filterVertexPosition( void ) {\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n    return vec4(position, 0.0, 1.0);\n}\nvec2 filterTextureCoord( void ) {\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\nvoid main(void) {\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vOut = aPosition;\n}\n"},12605:function(n,o,t){t.d(o,{Z:()=>e});let e="struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct CartoonTextUniforms {\n  uThickness:f32,\n  uBorderColor:vec3<f32>,\n  uTopColor:vec3<f32>,\n  uBottomColor:vec3<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> cartoonTextUniforms : CartoonTextUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) vOut : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   aPosition,\n  );\n}\n\nconst DOUBLE_PI: f32 = 6.28318530718; // 2 * PI\nconst ANGLE_STEP: f32 = 0.0628319;\n\nfn outlineMaxAlphaAtPos(pos: vec2<f32>) -> f32 {\n    let thickness = vec2<f32>(cartoonTextUniforms.uThickness) / gfu.uInputSize.xy;\n    var maxAlpha: f32 = 0.0;\n\n    for (var angle: f32 = 0.0; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        let displacedPos = pos + thickness * vec2<f32>(cos(angle), sin(angle));\n        let displacedColor = textureSample(uTexture, uSampler, clamp(displacedPos, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) vOut: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n    let contentColor = textureSample(uTexture, uSampler, uv);\n    let thickness = cartoonTextUniforms.uThickness / gfu.uInputSize.xy;\n    let offset = vec2<f32>(0.0, thickness.y * 0.6);\n\n    let outlineAlpha = outlineMaxAlphaAtPos(uv) * (1.0 - contentColor.a);\n    let outlineColor = vec4<f32>(cartoonTextUniforms.uBorderColor * outlineAlpha, outlineAlpha);\n\n    let outlineBaseAlpha = outlineMaxAlphaAtPos(uv - offset);\n    var outlineBaseColor = vec4<f32>(mix(cartoonTextUniforms.uBorderColor, vec3<f32>(0.0), 0.35) * outlineBaseAlpha, outlineBaseAlpha);\n    outlineBaseColor *= (1.0 - outlineAlpha) * (1.0 - contentColor.a);\n\n    let outlineDropShadowAlpha = outlineMaxAlphaAtPos(uv - (offset * 2.0));\n    var outlineDropShadowColor = vec4<f32>(vec3<f32>(0.0) * outlineDropShadowAlpha, outlineDropShadowAlpha) * 0.3;\n    outlineDropShadowColor *= (1.0 - outlineAlpha) * (1.0 - contentColor.a);\n\n    let innerShadowAlpha = textureSample(uTexture, uSampler, uv + vec2<f32>(0.0, -thickness.y * 0.35));\n    let innerShadowAlphaValue = (1.0 - innerShadowAlpha.a) * contentColor.a;\n    let innerShadowColor = vec4<f32>(vec3<f32>(0.0) * innerShadowAlphaValue, innerShadowAlphaValue) * 0.3;\n\n    let curveAmount: f32 = -0.05;\n    let horizonY = 0.54 + curveAmount * sin(vOut.x * 3.14159);\n    let gradientStart = horizonY - 0.005;\n    let gradientEnd = horizonY + 0.005;\n    let gradientRatio = smoothstep(gradientStart, gradientEnd, vOut.y);\n\n    var gradientColor = mix(vec4<f32>(cartoonTextUniforms.uTopColor, 1.0), vec4<f32>(cartoonTextUniforms.uBottomColor, 1.0), gradientRatio);\n    gradientColor *= contentColor.a;\n\n    return mix(gradientColor, innerShadowColor, innerShadowColor.a) + outlineColor + outlineBaseColor + outlineDropShadowColor;\n} "},57020:function(n,o,t){t.d(o,{Z:()=>e});let e="import { Application, Assets, Text } from 'pixi.js';\nimport { CartoonTextFilter } from './CartoonTextFilter';\n\n(async () => {\n  const app = new Application();\n\n  await app.init({\n    resizeTo: window,\n    backgroundColor: '#1099bb',\n    autoDensity: true,\n    antialias: true,\n  });\n  document.body.appendChild(app.canvas);\n\n  await Assets.load('https://pixijs.com/assets/webfont-loader/Grandstander-ExtraBold.ttf');\n\n  const filter = new CartoonTextFilter({\n    thickness: 7,\n  });\n\n  const text = new Text({\n    text: 'Hello World!',\n    style: {\n      fontFamily: 'Grandstander ExtraBold',\n      fontSize: 70,\n      fill: 0xffffff,\n      padding: 0,\n      filters: [filter],\n      fontWeight: '800',\n    },\n    x: app.screen.width / 2,\n    y: app.screen.height / 2,\n    anchor: 0.5,\n  });\n\n  app.stage.addChild(text);\n})();\n"}}]);