"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["1271"],{54715:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>o,default:()=>u,toc:()=>l,metadata:()=>i,assets:()=>a,contentTitle:()=>c});var i=JSON.parse('{"id":"guides/concepts/garbage-collection","title":"Garbage Collection","description":"Managing GPU resources and garbage collection in PixiJS for optimal performance.","source":"@site/docs/guides/concepts/garbage-collection.md","sourceDirName":"guides/concepts","slug":"/guides/concepts/garbage-collection","permalink":"/8.x/guides/concepts/garbage-collection","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/pixijs.com/tree/main/docs/guides/concepts/garbage-collection.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Garbage Collection","description":"Managing GPU resources and garbage collection in PixiJS for optimal performance."},"sidebar":"guidesSidebar","previous":{"title":"Environments","permalink":"/8.x/guides/concepts/environments"},"next":{"title":"Performance Tips","permalink":"/8.x/guides/concepts/performance-tips"}}'),r=t(85893),s=t(50065);let o={sidebar_position:5,title:"Garbage Collection",description:"Managing GPU resources and garbage collection in PixiJS for optimal performance."},c="Managing Garbage Collection in PixiJS",a={},l=[{value:"Explicit Resource Management with <code>destroy</code>",id:"explicit-resource-management-with-destroy",level:2},{value:"Managing Textures with <code>texture.unload</code>",id:"managing-textures-with-textureunload",level:2},{value:"Automatic Texture Garbage Collection with <code>TextureGCSystem</code>",id:"automatic-texture-garbage-collection-with-texturegcsystem",level:2},{value:"Customizing <code>TextureGCSystem</code>",id:"customizing-texturegcsystem",level:3},{value:"Best Practices for Garbage Collection in PixiJS",id:"best-practices-for-garbage-collection-in-pixijs",level:2}];function d(e){let n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"managing-garbage-collection-in-pixijs",children:"Managing Garbage Collection in PixiJS"})}),"\n",(0,r.jsx)(n.p,{children:"Efficient resource management is crucial for maintaining optimal performance in any PixiJS application. This guide explores how PixiJS handles garbage collection, the tools it provides, and best practices for managing GPU resources effectively."}),"\n",(0,r.jsxs)(n.h2,{id:"explicit-resource-management-with-destroy",children:["Explicit Resource Management with ",(0,r.jsx)(n.code,{children:"destroy"})]}),"\n",(0,r.jsxs)(n.p,{children:["PixiJS objects, such as textures, meshes, and other GPU-backed data, hold references that consume memory. To explicitly release these resources, call the ",(0,r.jsx)(n.code,{children:"destroy"})," method on objects you no longer need. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Sprite } from 'pixi.js';\n\nconst sprite = new Sprite(texture);\n// Use the sprite in your application\n\n// When no longer needed\nsprite.destroy();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Calling ",(0,r.jsx)(n.code,{children:"destroy"})," ensures that the object\u2019s GPU resources are freed immediately, reducing the likelihood of memory leaks and improving performance."]}),"\n",(0,r.jsxs)(n.h2,{id:"managing-textures-with-textureunload",children:["Managing Textures with ",(0,r.jsx)(n.code,{children:"texture.unload"})]}),"\n",(0,r.jsxs)(n.p,{children:["In cases where PixiJS\u2019s automatic texture garbage collection is insufficient, you can manually unload textures from the GPU using ",(0,r.jsx)(n.code,{children:"texture.unload()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Texture } from 'pixi.js';\n\nconst texture = Texture.from('image.png');\n\n// Use the texture\n\n// When no longer needed\ntexture.unload();\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is particularly useful for applications that dynamically load large numbers of textures and require precise memory control."}),"\n",(0,r.jsxs)(n.h2,{id:"automatic-texture-garbage-collection-with-texturegcsystem",children:["Automatic Texture Garbage Collection with ",(0,r.jsx)(n.code,{children:"TextureGCSystem"})]}),"\n",(0,r.jsxs)(n.p,{children:["PixiJS also includes the ",(0,r.jsx)(n.code,{children:"TextureGCSystem"}),", a system that manages GPU texture memory. By default:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Removes textures unused for 3600 frames"})," (approximately 1 minute at 60 FPS)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Checks every 600 frames"})," for unused textures."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"customizing-texturegcsystem",children:["Customizing ",(0,r.jsx)(n.code,{children:"TextureGCSystem"})]}),"\n",(0,r.jsxs)(n.p,{children:["You can adjust the behavior of ",(0,r.jsx)(n.code,{children:"TextureGCSystem"})," to suit your application:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"textureGCActive"})}),": Enable or disable garbage collection. Default: ",(0,r.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"textureGCMaxIdle"})}),": Maximum idle frames before texture cleanup. Default: ",(0,r.jsx)(n.code,{children:"3600"})," frames."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"textureGCCheckCountMax"})}),": Frequency of garbage collection checks (in frames). Default: ",(0,r.jsx)(n.code,{children:"600"})," frames."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Application } from 'pixi.js';\n\nconst app = new Application();\n\nawait app.init({\n  textureGCActive: true, // Enable texture garbage collection\n  textureGCMaxIdle: 7200, // 2 hours idle time\n  textureGCCheckCountMax: 1200, // Check every 20 seconds at 60 FPS\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-for-garbage-collection-in-pixijs",children:"Best Practices for Garbage Collection in PixiJS"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Explicitly Destroy Objects:"})," Always call ",(0,r.jsx)(n.code,{children:"destroy"})," on objects you no longer need to ensure GPU resources are promptly released."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Pooling:"})," Reuse objects with a pooling system to reduce allocation and deallocation overhead."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Proactively Manage Textures:"})," Use ",(0,r.jsx)(n.code,{children:"texture.unload()"})," for manual memory management when necessary."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"By following these practices and understanding PixiJS\u2019s garbage collection mechanisms, you can create high-performance applications that efficiently utilize system resources."})]})}function u(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},50065:function(e,n,t){t.d(n,{Z:()=>c,a:()=>o});var i=t(67294);let r={},s=i.createContext(r);function o(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);