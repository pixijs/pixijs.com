"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([["349"],{51662:function(e,s,n){n.r(s),n.d(s,{frontMatter:()=>c,default:()=>h,toc:()=>o,metadata:()=>i,assets:()=>l,contentTitle:()=>a});var i=JSON.parse('{"id":"guides/components/scene-objects/graphics/index","title":"Graphics","description":"Learn how to use PixiJS Graphics to create shapes, manage graphics contexts, and optimize performance in your projects.","source":"@site/docs/guides/components/scene-objects/graphics/index.md","sourceDirName":"guides/components/scene-objects/graphics","slug":"/guides/components/scene-objects/graphics/","permalink":"/8.x/guides/components/scene-objects/graphics/","draft":false,"unlisted":false,"editUrl":"https://github.com/pixijs/pixijs.com/tree/main/docs/guides/components/scene-objects/graphics/index.md","tags":[],"version":"current","frontMatter":{"description":"Learn how to use PixiJS Graphics to create shapes, manage graphics contexts, and optimize performance in your projects."},"sidebar":"guidesSidebar","previous":{"title":"Tiling Sprite","permalink":"/8.x/guides/components/scene-objects/tiling-sprite"},"next":{"title":"Graphics Fill","permalink":"/8.x/guides/components/scene-objects/graphics/graphics-fill"}}'),r=n(85893),t=n(50065);let c={description:"Learn how to use PixiJS Graphics to create shapes, manage graphics contexts, and optimize performance in your projects."},a="Graphics",l={},o=[{value:"<strong>Available Shapes</strong>",id:"available-shapes",level:2},{value:"Basic Primitives",id:"basic-primitives",level:3},{value:"Advanced Primitives",id:"advanced-primitives",level:3},{value:"SVG Support",id:"svg-support",level:3},{value:"<strong>GraphicsContext</strong>",id:"graphicscontext",level:2},{value:"Destroying a GraphicsContext",id:"destroying-a-graphicscontext",level:3},{value:"<strong>Creating Holes</strong>",id:"creating-holes",level:2},{value:"<strong>Graphics Is About Building, Not Drawing</strong>",id:"graphics-is-about-building-not-drawing",level:2},{value:"<strong>Performance Best Practices</strong>",id:"performance-best-practices",level:2},{value:"<strong>Caveats and Gotchas</strong>",id:"caveats-and-gotchas",level:2},{value:"<strong>API Reference</strong>",id:"api-reference",level:2}];function d(e){let s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"graphics",children:"Graphics"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.a,{href:"https://pixijs.download/release/docs/scene.Graphics.html",children:"Graphics"})," is a powerful and flexible tool for rendering shapes such as rectangles, circles, stars, and custom polygons. It can also be used to create complex shapes by combining multiple primitives, and it supports advanced features like gradients, textures, and masks."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"import { Graphics } from 'pixi.js';\n\nconst graphics = new Graphics().rect(50, 50, 100, 100).fill(0xff0000);\n"})}),"\n",(0,r.jsx)(s.h2,{id:"available-shapes",children:(0,r.jsx)(s.strong,{children:"Available Shapes"})}),"\n",(0,r.jsx)(s.p,{children:"PixiJS v8 supports a variety of shape primitives:"}),"\n",(0,r.jsxs)("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:"2rem"},children:[(0,r.jsxs)("div",{children:[(0,r.jsx)(s.h3,{id:"basic-primitives",children:"Basic Primitives"}),(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Line"}),"\n",(0,r.jsx)(s.li,{children:"Rectangle"}),"\n",(0,r.jsx)(s.li,{children:"Rounded Rectangle"}),"\n",(0,r.jsx)(s.li,{children:"Circle"}),"\n",(0,r.jsx)(s.li,{children:"Ellipse"}),"\n",(0,r.jsx)(s.li,{children:"Arc"}),"\n",(0,r.jsx)(s.li,{children:"Bezier / Quadratic Curves"}),"\n"]})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)(s.h3,{id:"advanced-primitives",children:"Advanced Primitives"}),(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Chamfer Rect"}),"\n",(0,r.jsx)(s.li,{children:"Fillet Rect"}),"\n",(0,r.jsx)(s.li,{children:"Regular Polygon"}),"\n",(0,r.jsx)(s.li,{children:"Star"}),"\n",(0,r.jsx)(s.li,{children:"Rounded Polygon"}),"\n",(0,r.jsx)(s.li,{children:"Rounded Shape"}),"\n"]})]})]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"const graphics = new Graphics()\n  .rect(50, 50, 100, 100)\n  .fill(0xff0000)\n  .circle(200, 200, 50)\n  .stroke(0x00ff00)\n  .lineStyle(5)\n  .moveTo(300, 300)\n  .lineTo(400, 400);\n"})}),"\n",(0,r.jsx)(s.h3,{id:"svg-support",children:"SVG Support"}),"\n",(0,r.jsx)(s.p,{children:"You can also load SVG path data, although complex hole geometries may render inaccurately due to Pixi's performance-optimized triangulation system."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:'let shape = new Graphics().svg(`\n  <svg>\n    <path d="M 100 350 q 150 -300 300 0" stroke="blue" />\n  </svg>\n`);\n'})}),"\n",(0,r.jsx)(s.h2,{id:"graphicscontext",children:(0,r.jsx)(s.strong,{children:"GraphicsContext"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"GraphicsContext"})," class is the core of PixiJS's new graphics model. It holds all the drawing commands and styles, allowing the same shape data to be reused by multiple ",(0,r.jsx)(s.code,{children:"Graphics"})," instances:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"const context = new GraphicsContext().circle(100, 100, 50).fill('red');\n\nconst shapeA = new Graphics(context);\nconst shapeB = new Graphics(context); // Shares the same geometry\n"})}),"\n",(0,r.jsx)(s.p,{children:"This pattern is particularly effective when rendering repeated or animated shapes, such as frame-based SVG swaps:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"let frames = [\n  new GraphicsContext().circle(100, 100, 50).fill('red'),\n  new GraphicsContext().rect(0, 0, 100, 100).fill('red'),\n];\n\nlet graphic = new Graphics(frames[0]);\n\nfunction update() {\n  graphic.context = frames[1]; // Very cheap operation\n}\n"})}),"\n",(0,r.jsx)(s.admonition,{type:"info",children:(0,r.jsxs)(s.p,{children:["If you don't explicitly pass a ",(0,r.jsx)(s.code,{children:"GraphicsContext"})," when creating a ",(0,r.jsx)(s.code,{children:"Graphics"})," object, then internally, it will have its own context, accessible via ",(0,r.jsx)(s.code,{children:"myGraphics.context"}),"."]})}),"\n",(0,r.jsx)(s.h3,{id:"destroying-a-graphicscontext",children:"Destroying a GraphicsContext"}),"\n",(0,r.jsxs)(s.p,{children:["When you destroy a ",(0,r.jsx)(s.code,{children:"GraphicsContext"}),", all ",(0,r.jsx)(s.code,{children:"Graphics"})," instances that share it will also be destroyed. This is a crucial point to remember, as it can lead to unexpected behavior if you're not careful."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"const context = new GraphicsContext().circle(100, 100, 50).fill('red');\nconst shapeA = new Graphics(context);\nconst shapeB = new Graphics(context); // Shares the same geometry\n\nshapeA.destroy({ context: true }); // Destroys both shapeA and shapeB\n"})}),"\n",(0,r.jsx)(s.h2,{id:"creating-holes",children:(0,r.jsx)(s.strong,{children:"Creating Holes"})}),"\n",(0,r.jsxs)(s.p,{children:["Use ",(0,r.jsx)(s.code,{children:".cut()"})," to remove a shape from the previous one:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"const g = new Graphics().rect(0, 0, 100, 100).fill(0x00ff00).circle(50, 50, 20).cut(); // Creates a hole in the green rectangle\n"})}),"\n",(0,r.jsx)(s.p,{children:"Ensure the hole is fully enclosed within the shape to avoid triangulation errors."}),"\n",(0,r.jsx)(s.h2,{id:"graphics-is-about-building-not-drawing",children:(0,r.jsx)(s.strong,{children:"Graphics Is About Building, Not Drawing"})}),"\n",(0,r.jsxs)(s.p,{children:["Despite the terminology of functions like ",(0,r.jsx)(s.code,{children:".rect()"})," or ",(0,r.jsx)(s.code,{children:".circle()"}),", ",(0,r.jsx)(s.code,{children:"Graphics"})," does not immediately draw anything. Instead, each method builds up a list of geometry primitives stored inside a ",(0,r.jsx)(s.code,{children:"GraphicsContext"}),". These are then rendered when the object is drawn to the screen or used in another context, such as a mask."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"const graphic = new Graphics().rect(0, 0, 200, 100).fill(0xff0000);\n\napp.stage.addChild(graphic); // The rendering happens here\n"})}),"\n",(0,r.jsxs)(s.p,{children:["You can think of ",(0,r.jsx)(s.code,{children:"Graphics"})," as a blueprint builder: it defines what to draw, but not when to draw it. This is why ",(0,r.jsx)(s.code,{children:"Graphics"})," objects can be reused, cloned, masked, and transformed without incurring extra computation until they're actually rendered."]}),"\n",(0,r.jsx)(s.h2,{id:"performance-best-practices",children:(0,r.jsx)(s.strong,{children:"Performance Best Practices"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Do not clear and rebuild graphics every frame"}),". If your content is dynamic, prefer swapping prebuilt ",(0,r.jsx)(s.code,{children:"GraphicsContext"})," objects instead of recreating them."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["Use ",(0,r.jsx)(s.code,{children:"Graphics.destroy()"})]})," to clean up when done. Shared contexts are not auto-destroyed."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["Use many simple ",(0,r.jsx)(s.code,{children:"Graphics"})," objects"]})," over one complex one to maintain GPU batching."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Avoid transparent overlap"})," unless you understand blend modes; overlapping semi-transparent primitives will interact per primitive, not post-composition."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"caveats-and-gotchas",children:(0,r.jsx)(s.strong,{children:"Caveats and Gotchas"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Memory Leaks"}),": Call ",(0,r.jsx)(s.code,{children:".destroy()"})," when no longer needed."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"SVG and Holes"}),": Not all SVG hole paths triangulate correctly."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Changing Geometry"}),": Use ",(0,r.jsx)(s.code,{children:".clear()"})," sparingly. Prefer swapping contexts."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Transparency and Blend Modes"}),": These apply per primitive. Use ",(0,r.jsx)(s.code,{children:"RenderTexture"})," if you want to flatten effects."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"api-reference",children:(0,r.jsx)(s.strong,{children:"API Reference"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://pixijs.download/release/docs/scene.Graphics.html",children:"Graphics"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://pixijs.download/release/docs/scene.GraphicsContext.html",children:"GraphicsContext"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://pixijs.download/release/docs/scene.FillStyle.html",children:"FillStyle"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://pixijs.download/release/docs/scene.StrokeStyle.html",children:"StrokeStyle"})}),"\n"]})]})}function h(e={}){let{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);